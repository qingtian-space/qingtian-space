<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ThreadLocal底层实现原理详解 | 晴天的空间站</title><meta name="keywords" content="ThreadLocal"><meta name="author" content="晴天"><meta name="copyright" content="晴天"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、ThreadLocal简介ThreadLocal顾名思义可以根据字面意思理解成线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程都可以在这个ThreadLocal中读写，这个读写是线程隔离的，线程之前不会有影响。 每个Thread都维护自己的一个ThreadLocalMap ，所以是线程隔离的。 123&#x2F;* ThreadLocal values pertaining to t">
<meta property="og:type" content="article">
<meta property="og:title" content="ThreadLocal底层实现原理详解">
<meta property="og:url" content="https://qtspace.cn/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="晴天的空间站">
<meta property="og:description" content="一、ThreadLocal简介ThreadLocal顾名思义可以根据字面意思理解成线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程都可以在这个ThreadLocal中读写，这个读写是线程隔离的，线程之前不会有影响。 每个Thread都维护自己的一个ThreadLocalMap ，所以是线程隔离的。 123&#x2F;* ThreadLocal values pertaining to t">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://qtspace.cn/articleimg/24.jpg">
<meta property="article:published_time" content="2022-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-01T16:26:51.672Z">
<meta property="article:author" content="晴天">
<meta property="article:tag" content="ThreadLocal">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qtspace.cn/articleimg/24.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qtspace.cn/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?18df237960f25ab608e95b4882123d33";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ThreadLocal底层实现原理详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-02 00:26:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="晴天的空间站" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-16"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-timeline-fill"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/img/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/articleimg/24.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">晴天的空间站</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw iconfont icon-16"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw iconfont icon-timeline-fill"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/img/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-comment-dots"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ThreadLocal底层实现原理详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-03-31T16:00:00.000Z" title="发表于 2022-04-01 00:00:00">2022-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ThreadLocal/">ThreadLocal</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ThreadLocal底层实现原理详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h3><p><code>ThreadLocal</code>顾名思义可以根据字面意思理解成线程本地变量。也就是说如果定义了一个<code>ThreadLocal</code>，每个线程都可以在这个<code>ThreadLocal</code>中读写，这个读写是线程隔离的，线程之前不会有影响。</p>
<p>每个<code>Thread</code>都维护自己的一个<code>ThreadLocalMap </code>，所以是线程隔离的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>通过这个<code>ThreadLocalMap</code>实现数据的读写，既然是<code>Map</code>肯定有<code>key</code>和<code>value</code>，但是这个<code>ThreadLocalMap</code>的<code>key</code>可以简单的看成是<code>ThreadLocal</code>，实际是并不是<code>ThreadLocal</code>的本身，而是它的一个<strong>弱引用</strong>。</p>
<h3 id="二、ThreadLocal学习大纲"><a href="#二、ThreadLocal学习大纲" class="headerlink" title="二、ThreadLocal学习大纲"></a>二、ThreadLocal学习大纲</h3><p>学习大纲思维导图如下图：</p>
<p><img src="https://qtspace.cn/contentimg/23.jpg"></p>
<h3 id="三、ThreadLocal方法和成员变量"><a href="#三、ThreadLocal方法和成员变量" class="headerlink" title="三、ThreadLocal方法和成员变量"></a>三、ThreadLocal方法和成员变量</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>ThreadLocal</code>的<code>API</code>很少就包含了4个，分别是<code>get()</code>、<code>set()</code>、<code>remove()</code>、<code>withInitial()</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>get()</code>：获取当前线程对应的<code>ThreadLocalMap</code>存储的值，<code>key</code>为当前<code>TheadLocal</code>（实际为<code>TheadLocal</code>的弱引用），也就是获取当前线程本地变量的值。</li>
<li><code>set(T value)</code>：给当前线程对应的<code>ThreadLocalMap</code>的设置值，也就是给当前线程本地变量设置值。</li>
<li><code>remove()</code>：清除前线程对应的<code>ThreadLocalMap</code>存储的<code>TheadLocal</code>，也就是清除当前线程本地变量的值。</li>
<li><code>withInitial()</code>：用于创建一个线程局部变量，变量的初始化值通过调用Supplier的get方法来确定</li>
</ul>
<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用nextHashCode()方法获取下一个hashCode值，用于计算ThreadLocalMap.tables数组下标</span></span><br><span class="line"><span class="comment">// key.threadLocalHashCode &amp; (len - 1)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类，用于计算hashCode值</span></span><br><span class="line"><span class="keyword">private</span> staitc <span class="type">AmoicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmoicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash增量值，斐波那契数也叫黄金分割数，可以让hash值分布非常均匀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个hashCode值方法，只用原子类操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、ThreadLocalMap"><a href="#四、ThreadLocalMap" class="headerlink" title="四、ThreadLocalMap"></a>四、ThreadLocalMap</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的一个静态内部类，在上面有说到每个线程都维护着一个<code>ThreadLocalMap</code>，这个&#96;&#96;ThreadLocalMap&#96; 就是用来储存数据的。</p>
<p><code>ThreadLocalMap</code>内部维护着一个<code>Entry</code>节点，这个节点继承了<code>WeakReference</code>类，泛型为<code>ThreadLocal</code>表示是弱引用，节点内部定义了一个为<code>Object</code>的<code>value</code>，这个<code>value</code>就是我们存放的值，<code>Entry</code>类的构造方法只有一个，传入<code>key</code>和<code>value</code>，这个<code>key</code>就是<code>ThreadLocal</code>，实际为<code>ThreadLocal</code>的弱引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreacLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    </span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v)&#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Thread、ThreadLocalMap、ThreadLocal结构关系"><a href="#Thread、ThreadLocalMap、ThreadLocal结构关系" class="headerlink" title="Thread、ThreadLocalMap、ThreadLocal结构关系"></a>Thread、ThreadLocalMap、ThreadLocal结构关系</h4><p>每个<code>Thread</code>都有一个<code>ThreadLocalMap</code>变量，<code>ThreadLocalMap</code>内部定义了<code>Entry</code>节点类，这个节点继承了<code>WeakReference</code>类泛型为<code>ThreacLocal</code>类，节点类的构造方法<code>ThreadLocal&lt;?&gt; k, Object v</code>，所以可以得到下面的结构关系图：</p>
<p><img src="https://qtspace.cn/contentimg/24.jpg"></p>
<h4 id="GC之后key是否为null？"><a href="#GC之后key是否为null？" class="headerlink" title="GC之后key是否为null？"></a>GC之后key是否为null？</h4><p>思考一个问题，既然<code>ThreadLocalMap</code>的<code>key</code>是弱引用，<code>GC</code>之后<code>key</code>是否为<code>null</code>？在搞清楚这个问题之前，我们需要先搞清楚<code>Java</code>的四种<strong>引用类型</strong>：</p>
<ul>
<li>强引用：<code>new</code>出来的对象就是强引用，只要强引用存在，垃圾回收器就永远不会回收被引用的对象，哪怕内存不足的时候。</li>
<li>软引用：使用<code>SoftReference</code>修饰的对象被称为软引用，在内存要溢出的时候软引用指向的对象会被回收。</li>
<li>弱引用：使用<code>WeakReference</code>修饰的对象被称为弱引用，只要发生垃圾回收，被弱引用指向的对象就会被回收。</li>
<li>虚引用：虚引用是最弱的引用，用<code>PhantomReference</code>进行定。唯一的作用就是用来队列接受对象即将死亡的通知。</li>
</ul>
<p>这个问题的答案是不为null，可以看下面的图：</p>
<p><img src="https://qtspace.cn/contentimg/25.jpg"></p>
<p>通过上图我们知道<code>ThreadLocal</code>的强引用是仍然存在的，所以不会被回收，不为<code>null</code></p>
<h4 id="ThreadLocalMap成员变量"><a href="#ThreadLocalMap成员变量" class="headerlink" title="ThreadLocalMap成员变量"></a>ThreadLocalMap成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化容量 必须为2的幂，位运算取代模运算提升计算效率，可以试hash值发生碰撞的概率更小，尽可能的使</span></span><br><span class="line"><span class="comment">// 元素在哈希表中均匀的散列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITTAL_CAPACIRY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry表</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry表存放的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阙值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure>

<h3 id="五、ThreadLocal-set-方法源码详解"><a href="#五、ThreadLocal-set-方法源码详解" class="headerlink" title="五、ThreadLocal.set()方法源码详解"></a>五、ThreadLocal.set()方法源码详解</h3><p><code>set()</code>方法用于给本地线程变量设值，我们先来看看<code>set()</code>方法的源码，从源码来一步一步解析实现原理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pubic <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Threac.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果map不为null， 调用ThreadLocalMap.set()方法设置值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// map为null，调用createMap()方法初始化创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线程的ThreadLocalMap.threadLocals</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用ThreadLocalMap构造方法创建ThreadLocalMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap构造方法，传入firstKey, firstValue</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化Entry表的容量 = 16</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 获取ThreadLocal的hashCode值与运算得到数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firsetKey.threadLocalHashCode &amp; (INITAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 通过下标Entry表赋值</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// Entry表存储元素数量初始化为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置Entry表扩容阙值 默认为 len * 2 / 3</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal.set()</code>方法还是很简单的，核心方法在<code>ThreadLocalMap.set()</code>方法，<code>ThreadLocal.set()</code>方法流程如下：</p>
<ol>
<li>获取当前线程的<code>ThreadLocalMap map</code> 。</li>
<li>如果<code>map</code>不为<code>null</code>则调用<code>map.set()</code>方法设置值。</li>
<li>如果<code>map</code>为<code>null</code>则调用<code>createMap</code>方法创建。</li>
<li><code>createMap()</code>方法通过<code>ThreadLocalMap</code>的构造方法创建，构造方法主要做了初始化<code>Entry[] table</code>容量16，通过<code>ThreadLocal</code>的<code>threadLocalHashCode</code>调用<code>nextHashCode()</code>方法获取<code>hashCode</code>值计算出下标，<code>table</code>数组通过下标赋值，初始化存储的元素数量，初始化数组扩容阙值。</li>
</ol>
<p><img src="https://qtspace.cn/contentimg/26.jpg"></p>
<p><code>ThreadLocalMap</code>在构造方法里处理的时候用到了我们学习大纲里说到的<code>hash</code>算法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code>，没创建一个<code>ThreadLocal</code>就会调用一次<code>nextHashCode()</code>方法，这个<code>HASH_INCREMENT</code>值就会增长<code>0x61c88647</code>，这个值很特殊，是斐波那契数也叫黄金分割数，这个值可以让<code>hash</code>分布非常均匀。</p>
<p>可以下一个小demo测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        hashCode = i * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> hashCode &amp; (<span class="number">16</span> - <span class="number">1</span>);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;在桶中的位置：&quot;</span> + bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面测试输出如下：可以看出数据在算列数组中分布的很均匀。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0在桶中的位置：7</span><br><span class="line">1在桶中的位置：14</span><br><span class="line">2在桶中的位置：5</span><br><span class="line">3在桶中的位置：12</span><br><span class="line">4在桶中的位置：3</span><br><span class="line">5在桶中的位置：10</span><br><span class="line">6在桶中的位置：1</span><br><span class="line">7在桶中的位置：8</span><br><span class="line">8在桶中的位置：15</span><br><span class="line">9在桶中的位置：6</span><br><span class="line">10在桶中的位置：13</span><br><span class="line">11在桶中的位置：4</span><br><span class="line">12在桶中的位置：11</span><br><span class="line">13在桶中的位置：2</span><br><span class="line">14在桶中的位置：9</span><br><span class="line">15在桶中的位置：0</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap-set-方法源码详解"><a href="#ThreadLocalMap-set-方法源码详解" class="headerlink" title="ThreadLocalMap.set()方法源码详解"></a>ThreadLocalMap.set()方法源码详解</h4><p><code>ThreadLocalMap.set()</code>方法分为好几种情况，主要有以下四种情况，针对不同的情况我们通过画图来说明。</p>
<blockquote>
<p>说明： 下面所有图中，绿色块<code>Entry</code>代表正常数据，灰色代表<code>Entry</code>的<code>key</code>值为<code>null</code>，已被<code>GC</code>回收，白色代表<code>Entry</code>为<code>null</code>。</p>
</blockquote>
<p><strong>第一种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>为<code>null</code>：</p>
<p><img src="https://qtspace.cn/contentimg/27.jpg"></p>
<p>这种情况直接将该数据放入该槽位即可。</p>
<p><strong>第二种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>不为<code>null</code>，但是<code>key</code>相同：</p>
<p><img src="https://qtspace.cn/contentimg/28.jpg"></p>
<p>这种情况直接该槽位的<code>value</code>值。</p>
<p><strong>第三种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>不为<code>null</code>，且<code>key</code>不相同，这种时候会遍历数组，线性往后查找，查找<code>Entry</code>为<code>null</code>的槽位，且在找到<code>Entry</code>为<code>null</code>之前没有遇到<code>key</code>过期的<code>Entry</code>，就该数据放入该槽位中，如果遍历过程中，遇到了<code>key</code>相等的槽位，直接更新<code>value</code>即可：</p>
<p><img src="https://qtspace.cn/contentimg/29.jpg"></p>
<p>注意：每次循环查找都会判断<code>key</code>是否相等，如果相等则更新<code>value</code>直接返回。</p>
<p><strong>第四种情况：</strong>基于第三种情况，如果在找到<code>Entry</code>为<code>null</code>之前遇到了<code>key</code>过期的<code>Entry</code>，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/30.jpg"></p>
<p>如上图散列数组下标为7位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，说明此数据<code>key</code>值已经被垃圾回收掉了，此时会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<code>index=7</code>为起点开始向前遍历，进行探测式数据清理工作。</p>
<p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = stateSlot = 7</code>。</p>
<p>以当前<code>stateSlot </code>开始向前迭代找到，找到其他过期的数据，然后更新过期数据起始扫描下标的<code>slotToExpunge </code>，直到找到了<code>Entry</code>为<code>null</code>的槽位则结束。</p>
<p>如果找到过期数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位则停止迭代，如下图所示，<code>slotToExpunge</code>被更新为0：</p>
<p><img src="https://qtspace.cn/contentimg/31.jpg"></p>
<p>上图以当前节点<code>index = 7</code>向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>的值，遇到<code>Entry</code>为<code>null</code>则结束探测，以上图为例<code>slotToExpunge</code>被更新为0。</p>
<p>上面向前迭代的操作是为了更新探测清理过期数据的起始位置<code>soltToExpunge</code>的值，这个值是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p>
<p>接着开始<code>staleSolt</code>位置<code>index = 7</code>向后迭代，<strong>如果找到了相等<code>key</code>的<code>Entry</code>的数据</strong>则更新<code>value</code>值，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/32.jpg"></p>
<p>从当前节点<code>staleSolt</code>位置开始向后寻找<code>key</code>相等的<code>Entry</code>位置，如果找到了<code>key</code>相等的<code>Entry</code>，则会交换<code>staleSlot</code>元素的位置，且更新<code>value</code>值，然后进行过期<code>Entry</code>的清理工作，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/33.jpg"></p>
<p>如果没有找到<strong>相等<code>key</code>的<code>Entry</code>的数据</strong>，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/34.jpg"></p>
<p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>，如果没有找到，则会继续往后查找直到找到<code>Entry</code>为<code>null</code>停止，然后创建新的<code>Entry</code>，替换<code>stableSlot</code>的位置。</p>
<p>替换完成之后也是进行过期元素的清理工作，清理工作的方法主要有两个<code>expungeStaleEntry</code>和<code>cleanSomeSlots</code>，具体详情后面会讲到。</p>
<p>上面已经图解了<code>set()</code>方法实现的原理，接下来我们结合源码再来看看，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Entry表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 获取当前要放入元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; </span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)])&#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果查找到key相等的entry，则更新value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            v.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果查找到为key为null的entry，说明key过期，被GC回收</span></span><br><span class="line">        <span class="comment">// 这个时候要初始化探测式清理的起始位置</span></span><br><span class="line">        <span class="comment">// 替换过期元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStateEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环查找过程中，没有找到key相等的entry，且没有key过期的entry</span></span><br><span class="line">    <span class="comment">// 则新建一个entry放入entry表中</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放元素数量+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 调用启发式清理， 且元素数量大于扩容阙值</span></span><br><span class="line">    <span class="comment">// 则调用rehash方法，该方法会进行key过期的entry清理工作，清理完成之后再判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    	rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码流程主要如下：</p>
<ol>
<li>首先获取<code>Entry</code>表，<code>Entry</code>表长度，通过<code>hashCode</code>计算下标，然后<code>for</code>循环<code>Entry</code>表。</li>
<li>如果循环查找过程中找到了<code>key</code>相等的<code>Entry</code>则更新<code>value</code>对应我们上面说的<strong>第二种情况</strong>。</li>
<li>如果循环查找过程找到了<code>key</code>为<code>null</code>的<code>Entry</code>，说明<code>key</code>过期了，替换过期元素，需要初始化探测式清理的其实位置，调用<code>replaceStaleEntry()</code>方法，这个方法我们下面再说，这个对应我们上面说的<strong>第四种情况。</strong></li>
<li><code>for</code>循环查找完毕，说明在查找过程中该下标对应的<code>Entry</code>为<code>null</code>，则在新建一个<code>Entry</code>放入该槽位，然后调用<strong>启发式清理</strong>工作。</li>
<li>如果<strong>启发式清理</strong>未清理任务数据，且<code>size</code>超过扩容阙值(2&#x2F;3)，则调用<code>rehash()</code>方法，该方法会先进行一次探测式清理，清理过期元素，清理完毕之后如果<code>size &gt;= threshold - threshold / 4 </code>，则会进行扩容操作。</li>
</ol>
<p>接下来看核心方法<code>replaceStaleEntry()</code>，该方法在查找过程中遇到<code>key = null</code>数据的时候会执行，该方法提供了替换过期数据的功能，可以对应上面说<strong>第四种情况</strong>来看，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Entry表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取Entry表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义探测式清理起始位置 slotToExpunge = staleSlot</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从staleSlot开始向前迭代查找是否有key=null的entry</span></span><br><span class="line">    <span class="comment">// 如果有则更新slotToExpunge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staleSlot开始向后循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查找到了key相等entry</span></span><br><span class="line">        <span class="comment">// 则替换staleSlot和i的位置，且更新value的值</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">			</span><br><span class="line">           	<span class="comment">// 替换staleSlot和i的位置</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            <span class="comment">// 更新value值</span></span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">// 如果slotToExpunge == staleSlot，说明向前循环的没有查找到key过期的entry</span></span><br><span class="line">            <span class="comment">// 更新slotToExpunge值</span></span><br><span class="line">            <span class="comment">// 则会调用启动式过期清理，先会进行一遍过期元素探测操作</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了key为null 且向前循环的没有查找到key过期的entry</span></span><br><span class="line">        <span class="comment">// 则更新slotToExpunge</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明没有找到k == key的数据，且碰到Entry为null的数据</span></span><br><span class="line">    <span class="comment">// 则将数据放入该槽位</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slotToExpunge != staleSlot 说明从staleSlot开始向前迭代查找有key=null的entry</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">// 启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理</span></span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码主要流程如下：</p>
<ol>
<li>首先获取<code>Entry</code>表，<code>Entry</code>表长度，定义探测式清理起始位置 <code>slotToExpunge = staleSlot</code>。</li>
<li>从staleSlot开始向前迭代查找是否有<code>key=null</code>的<code>entry</code>，如果有则更新<code>slotToExpunge</code>。</li>
<li><code>staleSlot</code>开始向后循环，如果查找到了<code>key</code>相等<code>entry</code>，则替换<code>staleSlot</code>和<code>i</code>的位置，且更新<code>value</code>的值，然后判断<code>slotToExpunge == staleSlot</code>，说明向前循环的没有查找到<code>key</code>过期的<code>entry</code>， 然后更新<code>slotToExpunge</code>值，则会调用启动式过期清理，先会进行一遍过期元素探测操作，如果发现了有过期的数据就会先进行探测式清理。</li>
<li>如果找到了<code>key</code>为<code>null </code>且向前循环的没有查找到<code>key</code>过期的<code>entry</code>，则更新<code>slotToExpunge</code>。</li>
<li>循环结束，方法没有退出，说明没有找到<code>k == key</code>的数据，且碰到<code>Entry=null</code>的数据，则将数据放入该槽位。</li>
<li>最后判断<code>slotToExpunge != staleSlot</code>，说明从<code>staleSlot</code>开始向前迭代查找有<code>key=null</code>的<code>entry</code>，则调用启动式清理，在启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理。</li>
</ol>
<p><code>ThreadLocalMap.set()</code>方法到这里已经解析完毕，我们接下来看看<code>ThreadLocalMap</code>过期 key 的启发式清理流程。</p>
<h4 id="ThreadLocalMap过期-key-的启发式清理流程"><a href="#ThreadLocalMap过期-key-的启发式清理流程" class="headerlink" title="ThreadLocalMap过期 key 的启发式清理流程"></a>ThreadLocalMap过期 key 的启发式清理流程</h4><p>上面我们提到的<code>ThreadLocalMap</code>两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p>
<h5 id="探测式清理"><a href="#探测式清理" class="headerlink" title="探测式清理"></a>探测式清理</h5><p>探测式清理方法<code>expungeStaleEntry</code>，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，遍历过程如果遇到未过期的数据则会将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了元素，则会将未过期的数据放在最靠近此位置的<code>Entry = null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶位置更近一点。这种优化会提高整个散列表查询性能。</p>
<p>如下图所示：</p>
<p><img src="https://qtspace.cn/contentimg/35.jpg"></p>
<p>探测式清理迭代的过程中遇到了空的槽位，则终止探测，这样子一轮探测式清理就工作完成，我们看看具体的源码实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// staleSlot探测式清理起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将起始位置置空</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 元素数量减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新迭代散列，直到发现空槽</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">		<span class="comment">// 如果key过期，则清空元素，数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果key没有过期，则重新计算hash，重新获取下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前下标存在值，则寻找离冲突key所在entry最近的空槽</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// i位置槽置空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 寻找离冲突key所在entry最近的空槽，放入该槽</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="启发式清理"><a href="#启发式清理" class="headerlink" title="启发式清理"></a>启发式清理</h5><p>启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong></p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len); <span class="comment">// 从下一个位置开始</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 遍历到key==null的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len; <span class="comment">// 重置n</span></span><br><span class="line">            removed = <span class="literal">true</span>; <span class="comment">// 标志有清理元素</span></span><br><span class="line">            i = expungeStaleEntry(i); <span class="comment">// 清理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">// log(n) 限制--对数次</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>i</code>的下一个位置判断元素是否需要清除，如果遇到<code>key==null</code>的元素则会重置<code>n</code>，需要清除且更新<code>i</code>的值，判断且清除完毕之后，<code>n = n &gt;&gt;&gt; 1</code>直到<code>n = 0</code>则退出清理。</p>
<h4 id="ThreadLocalMap-get-方法详解"><a href="#ThreadLocalMap-get-方法详解" class="headerlink" title="ThreadLocalMap.get()方法详解"></a>ThreadLocalMap.get()方法详解</h4><p>上面已经说完了<code>set()</code>方法的源码，接下来我们看看<code>get()</code>方法的操作原理，主要包含两种情况，一种是<code>hash</code>计算出下标，该下标对应的<code>Entry.key</code>和我们传入的<code>key</code>相等的情况，另外一种就是不相等的情况。</p>
<p><strong>相等情况：</strong>相等情况处理很简单，直接返回<code>value</code>，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/36.jpg"></p>
<p>上图中比如<code>get(ThreadLocal1)</code>计算下标为4，且4存在<code>Entry</code>，且<code>key</code>相等，则直接返回<code>value = 11</code>。</p>
<p><strong>不相等情况</strong>：不相等情况，先看图：</p>
<p>以<code>get(ThreadLocal2)</code>为例计算下标为4，且4存在<code>Entry</code>，但<code>key</code>相等，这个时候则为往后迭代寻找<code>key</code>相等的元素，如果寻找过程中发现了有<code>key = null</code>的元素则回进行探测式清理操作。如下图：</p>
<p><img src="https://qtspace.cn/contentimg/37.jpg"></p>
<p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图：</p>
<p><img src="https://qtspace.cn/contentimg/38.jpg"></p>
<p><code>ThreadLocalMap.get()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到的话，则调用setInitialValue()方法设置null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// key相等直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// key不相等调用getEntryAfterMiss()方法</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 迭代往后查找key相等的entry</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 遇到key=null的entry，先进行探测式清理工作</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="type">else</span></span><br><span class="line">            <span class="variable">i</span> <span class="operator">=</span> nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocalMap的扩容机制"><a href="#ThreadLocalMap的扩容机制" class="headerlink" title="ThreadLocalMap的扩容机制"></a>ThreadLocalMap的扩容机制</h4><p>在<code>ThreadLocalMap.set()</code>方法最后，如果执行完启发式清理工作之后，未清理任何数据，且当前散列数组中元素已经超过扩容阙值<code>len*2/3</code>，则执行<code>rehash()</code>逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure>

<p><code>rehash()</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先进行探测式清理工作</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//探测式清理完毕之后 如果size &gt;= threshold - threshold / 4</span></span><br><span class="line">    <span class="comment">// 也就是size &gt;= threshold * 3/4，也就是 size &gt;= len * 1/2，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rehash()</code>方法源码流程如下：</p>
<ol>
<li>首先进行探测式清理工作</li>
<li>如果探测式清理工作完毕之后，如果<code>size &gt;= threshold - threshold / 4</code>， 也就是<code>size &gt;= threshold * 3/4</code>，也就是 <code>size &gt;= len * 1/2</code>，则调用<code>resize()</code>扩容。</li>
</ol>
<p>扩容方法<code>resize()</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容方法执行之后<code>tab</code>的大小为原先的两倍<code>oldLen * 2</code>，然后变量老的散列表，重新计算<code>hash</code>位置，然后放到新的散列表中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位放入，扩容完成之后，重新计算扩容阙值。</p>
<h3 id="六、ThreadLocal-get-方法源码详解"><a href="#六、ThreadLocal-get-方法源码详解" class="headerlink" title="六、ThreadLocal.get()方法源码详解"></a>六、ThreadLocal.get()方法源码详解</h3><p><code>ThreadLcoal.get()</code>方法源码详解已经在<code>ThreadLocalMap.get()</code>方法源码解析中完成。</p>
<h3 id="七、ThreadLocal-remove-方法源码详解"><a href="#七、ThreadLocal-remove-方法源码详解" class="headerlink" title="七、ThreadLocal.remove()方法源码详解"></a>七、ThreadLocal.remove()方法源码详解</h3><p><code>ThreadLocal.remove()</code>方法流程比较简单，我们结合源码来说明，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从hash获取的下标开始，寻找key相等的entry元素清除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal.remove()</code>核心是调用<code>ThreadLocalMap.remove()</code>方法，流程如下：</p>
<ol>
<li>通过<code>hash</code>计算下标。</li>
<li>从散列表该下标开始往后查<code>key</code>相等的元素，如果找到则做清除操作，引用置为<code>null</code>，<code>GC</code>的时候<code>key</code>就会置为<code>null</code>，然后执行探测式清理处理。</li>
</ol>
<h3 id="八、InheritableThreadLocal"><a href="#八、InheritableThreadLocal" class="headerlink" title="八、InheritableThreadLocal"></a>八、InheritableThreadLocal</h3><p>我们在使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p>
<p>为了解决这个问题，<code>JDK</code>中还有一个<code>InheritableThreadLocal</code>类，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">    inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码输出结果为：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程获取父类ThreadLocal数据：null</span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span><br></pre></td></tr></table></figure>

<p>实现原理是子线程通过父线程中调用<code>new Thread()</code>方法创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用，<code>init()</code>方法中拷贝父线程数据源到子线程中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p>
<p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/threadlocal.html">https://javaguide.cn/java/concurrent/threadlocal.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">晴天</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://qtspace.cn/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/">https://qtspace.cn/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qtspace.cn" target="_blank">晴天的空间站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ThreadLocal/">ThreadLocal</a></div><div class="post_share"><div class="social-share" data-image="/articleimg/24.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/03/29/Java%E9%94%81(%E4%B8%89)Semaphore%E5%85%B1%E4%BA%AB%E9%94%81%E8%AF%A6%E8%A7%A3/"><img class="prev-cover" src="/articleimg/23.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java锁(三)：Semaphore共享锁详解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">晴天</div><div class="author-info__description">热衷学习，热衷生活</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/qingtian-space"><i class="fab fa-github"></i><span>关注Follow</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/qingtian-space" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_34222160" target="_blank" title="CSDN"><i class="iconfont icon-csdn1-copy"></i></a><a class="social-icon" href="https://juejin.cn/user/2911973447579854" target="_blank" title="掘金"><i class="iconfont icon-juejin-logo"></i></a><a class="social-icon" href="https://segmentfault.com/u/qtspace" target="_blank" title="思否"><i class="iconfont icon-sf"></i></a><a class="social-icon" href="https://www.jianshu.com/u/480ce6570ae1" target="_blank" title="简书"><i class="iconfont icon-jianshu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">认清生活的真相，并仍然热爱它</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ThreadLocal%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、ThreadLocal简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ThreadLocal%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2"><span class="toc-number">2.</span> <span class="toc-text">二、ThreadLocal学习大纲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ThreadLocal%E6%96%B9%E6%B3%95%E5%92%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">三、ThreadLocal方法和成员变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API"><span class="toc-number">3.1.</span> <span class="toc-text">API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.2.</span> <span class="toc-text">成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ThreadLocalMap"><span class="toc-number">4.</span> <span class="toc-text">四、ThreadLocalMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E3%80%81ThreadLocalMap%E3%80%81ThreadLocal%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">Thread、ThreadLocalMap、ThreadLocal结构关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E4%B9%8B%E5%90%8Ekey%E6%98%AF%E5%90%A6%E4%B8%BAnull%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">GC之后key是否为null？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">ThreadLocalMap成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81ThreadLocal-set-%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">五、ThreadLocal.set()方法源码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-set-%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.1.</span> <span class="toc-text">ThreadLocalMap.set()方法源码详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E8%BF%87%E6%9C%9F-key-%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B8%85%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">ThreadLocalMap过期 key 的启发式清理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A2%E6%B5%8B%E5%BC%8F%E6%B8%85%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">探测式清理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E6%B8%85%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">启发式清理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap-get-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.3.</span> <span class="toc-text">ThreadLocalMap.get()方法详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">ThreadLocalMap的扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81ThreadLocal-get-%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">六、ThreadLocal.get()方法源码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81ThreadLocal-remove-%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">七、ThreadLocal.remove()方法源码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81InheritableThreadLocal"><span class="toc-number">8.</span> <span class="toc-text">八、InheritableThreadLocal</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/" title="ThreadLocal底层实现原理详解"><img src="/articleimg/24.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ThreadLocal底层实现原理详解"/></a><div class="content"><a class="title" href="/2022/04/01/ThreadLocal%E8%AF%A6%E8%A7%A3/" title="ThreadLocal底层实现原理详解">ThreadLocal底层实现原理详解</a><time datetime="2022-03-31T16:00:00.000Z" title="发表于 2022-04-01 00:00:00">2022-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/Java%E9%94%81(%E4%B8%89)Semaphore%E5%85%B1%E4%BA%AB%E9%94%81%E8%AF%A6%E8%A7%A3/" title="Java锁(三)：Semaphore共享锁详解"><img src="/articleimg/23.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java锁(三)：Semaphore共享锁详解"/></a><div class="content"><a class="title" href="/2022/03/29/Java%E9%94%81(%E4%B8%89)Semaphore%E5%85%B1%E4%BA%AB%E9%94%81%E8%AF%A6%E8%A7%A3/" title="Java锁(三)：Semaphore共享锁详解">Java锁(三)：Semaphore共享锁详解</a><time datetime="2022-03-28T16:00:00.000Z" title="发表于 2022-03-29 00:00:00">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/27/Java%E9%94%81(%E4%BA%8C)AbstractQueuedSynchronizer%E3%80%81ReentrantLock%E8%AF%A6%E8%A7%A3/" title="Java锁(二)：AbstractQueuedSynchronizer、ReentrantLock详解"><img src="/articleimg/22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java锁(二)：AbstractQueuedSynchronizer、ReentrantLock详解"/></a><div class="content"><a class="title" href="/2022/03/27/Java%E9%94%81(%E4%BA%8C)AbstractQueuedSynchronizer%E3%80%81ReentrantLock%E8%AF%A6%E8%A7%A3/" title="Java锁(二)：AbstractQueuedSynchronizer、ReentrantLock详解">Java锁(二)：AbstractQueuedSynchronizer、ReentrantLock详解</a><time datetime="2022-03-26T16:00:00.000Z" title="发表于 2022-03-27 00:00:00">2022-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/26/Java%E9%94%81(%E4%B8%80)volatile%E3%80%81synchronized%E8%AF%A6%E8%A7%A3/" title="Java锁(一)：volatile、synchronized详解"><img src="/articleimg/21.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java锁(一)：volatile、synchronized详解"/></a><div class="content"><a class="title" href="/2022/03/26/Java%E9%94%81(%E4%B8%80)volatile%E3%80%81synchronized%E8%AF%A6%E8%A7%A3/" title="Java锁(一)：volatile、synchronized详解">Java锁(一)：volatile、synchronized详解</a><time datetime="2022-03-25T16:00:00.000Z" title="发表于 2022-03-26 00:00:00">2022-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/JVM-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JVM-GC垃圾回收"><img src="/articleimg/20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM-GC垃圾回收"/></a><div class="content"><a class="title" href="/2022/03/22/JVM-GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="JVM-GC垃圾回收">JVM-GC垃圾回收</a><time datetime="2022-03-21T16:00:00.000Z" title="发表于 2022-03-22 00:00:00">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2022 By 晴天</div><div class="footer_custom_text">欢迎来到晴天的空间</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '05a2203ed22bac4384cb',
      clientSecret: '9fa0bd0b7962aa3b1632ad774079bc8258d628c8',
      repo: 'blog-comments',
      owner: 'qingtian-space',
      admin: ['qingtian-space'],
      id: '0225cfb803475275f1fe5d55464d86bc',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="/js/iconfont.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>