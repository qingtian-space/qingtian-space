<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晴天的博客</title>
  
  
  <link href="http://qtspace.cn/atom.xml" rel="self"/>
  
  <link href="http://qtspace.cn/"/>
  <updated>2022-03-08T12:31:15.187Z</updated>
  <id>http://qtspace.cn/</id>
  
  <author>
    <name>晴天</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>String类详解</title>
    <link href="http://qtspace.cn/2022/03/08/String%E7%B1%BB%E8%A7%A3%E6%9E%90/"/>
    <id>http://qtspace.cn/2022/03/08/String%E7%B1%BB%E8%A7%A3%E6%9E%90/</id>
    <published>2022-03-07T16:00:00.000Z</published>
    <updated>2022-03-08T12:31:15.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-String描述"><a href="#一-String描述" class="headerlink" title="一  String描述"></a>一  String描述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>String</code>是一个用<code>final</code>声明的常量类，不能被任何类继承，底层是由<code>char[]</code>数组实现，这个数组也是<code>final</code>，一旦String对象被创建，包含这个对象中的字符序序列是不可被改变的，改类后续的所有方法都是不能改变该对象的，直至该对象被销毁（该类的有些方法看似改变了字符串比如<code>substring</code>、<code>replace</code>等，其实都是内部创建了一个新的字符串）。实现了<code>Serializable</code>系列化接口，实现了<code>Comparable</code>接口，用于比较两个字符串的大小（按顺序比较单个字符的ASCII码），最后实现<code>CharSequence</code>表示是一个有序字符的集合。</p><h3 id="二-创建方法"><a href="#二-创建方法" class="headerlink" title="二  创建方法"></a>二  创建方法</h3><p>String最常用的创建方法就是<code>String str = &quot;str&quot;</code>，实际上String底层是由一个<code>char[]</code>数组实现的，所以也可以<code>String str = new String(new char[]&#123;&#39;s&#39;, &#39;t&#39;, &#39;r&#39;&#125;)</code>，还可以由下面方法创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str01</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// int方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// byte方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>&#125;);</span><br></pre></td></tr></table></figure><p>声明一个字符串对象的方法一般有两种：</p><ul><li><p>通过“字面量”的形式直接赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过new关键字调用构造方法创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;str&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过”+”运算符创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str01</span> <span class="operator">=</span> <span class="string">&quot;s&quot;</span> + <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str02</span> <span class="operator">=</span> str01 + <span class="string">&quot;str&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><p>那么这两种声明方式有什么不一样呢？首先我们要介绍一个常量池，Java在运行时会维护一个String池(String Pool)，也叫<strong>字符串缓存区</strong>。String池用来存放运行时中产生的各种字符串。并且字符串的内容不重复。</p><p>在JDK1.7之前，常量池是存放在方法区的，用来储存编译期生成的字符串引用。而在JDK1.7之后，常量池存放在堆中了。</p><ul><li>字面量创建字符串或者纯字符串(常量)拼接字符串时会现在字符串池中查找，看是否有相等的对象，有的话则直接使用String池中的引用；没有的话就在字符串池中创建该对象，避免重复创建对象。</li><li>new关键字创建时，直接在堆中创建一个新对象，变量所引用的都是这个新对象的地址，但是如果创建的字符串内容在常量池存在了，那么会由堆再指向常量池的字符串；如果不存在，那么通过new关键字创建的字符串对象是不会在常量池中维护的。</li><li>使用包含变量表达式来创建String对象时，不仅检查维护String池，还会在堆区创建这个对象，最后指向堆内存中的对象。</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//true</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//fasle</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//fasle</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//true</span></span><br><span class="line">System.out.println(str2.equals(str3));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>对于上面情况，首先<code>String str1 = &quot;hello&quot;</code>，会先在常量池检查是否有<code>hello</code>存在，发现是不存在的，则在常量池中创建<code>hello</code>对象，并将常量池中的引用赋值给str1；紧接着<code>String str2 = &quot;hello&quot;</code>，在常量池中检测到有<code>hello</code>，所以讲常量池中的引用赋值给str2，所以<code>str1 == str2</code>是<code>true</code>；紧接着<code>String str3 = new String(&quot;hello&quot;)</code>，常量池中有了<code>hello</code>，所以不用在常量池中创建，然后在堆中创建该对象并将对象的引用赋值给str3，再将该对象指向常量池。如下图所示：</p><p><img src="https://qtspace.cn/contentimg/1.jpg"></p><p>使用包含变量表达式创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1+<span class="string">&quot;world&quot;</span>;<span class="comment">//编译器不能确定为常量(会在堆区创建一个String对象)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;world&quot;</span>;<span class="comment">//编译器确定为常量，直接到常量池中引用</span></span><br><span class="line"></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//fasle</span></span><br><span class="line">System.out.println(str2==str4);<span class="comment">//true</span></span><br><span class="line">System.out.println(str3==str4);<span class="comment">//fasle</span></span><br></pre></td></tr></table></figure><p>str3由于含有变量str1，编译器不能确定是常量，会在堆中创建一个String对象。而str4是两个常量相加，编译器确定会常量，直接饮用常量池中的对象。如下图所示：</p><p><img src="https://qtspace.cn/contentimg/2.jpg"></p><h3 id="三-不可变（final）"><a href="#三-不可变（final）" class="headerlink" title="三  不可变（final）"></a>三  不可变（final）</h3><p>String最重要的特性就是不可变，这种不可变性是通过底层<code>private final char value[]</code>属性，以及没有任务修改<code>char[]</code>的方法实现。举个经典的例子，不考虑其他情况，下面初始化String分别创建了几个对象呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str01</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str02</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span> + <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str03</span> <span class="operator">=</span> str01 + <span class="string">&quot;def&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>str01创建一个对象，引用指向abc</li><li>str02创建一个对象，引用指向abcdef，这是因为JVM编译期的优化两个字符串会拼接起来。</li><li>str03会创建三个对象，str01对象，+的时候会创建StringBuilder对象进行append操作，append完成toString创建对象。</li></ul><p>但是真的不可以变吗？</p><p>我们知道String底层是由<code>char[] value</code>实现，<code>value</code>被<code>final</code>修饰，只能保证引用不被改变，<code>value</code>是可以被改变的，即使被<code>private</code>声明，我们还是可以通过反射来改变<code>value</code>值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="comment">// 输出 str</span></span><br><span class="line">System.out.println(str);</span><br><span class="line"><span class="comment">// 通过反射获取String类中的value字段</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="comment">// 因为value是private的, 所以要修改其访问权限</span></span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 获取str对象的value值</span></span><br><span class="line"><span class="type">char</span>[] value = (<span class="type">char</span>[])field.get(str);</span><br><span class="line"><span class="comment">// 修改value值</span></span><br><span class="line">value[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line"><span class="comment">// 输出 Str</span></span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>通过前后的两次打印的结果，我们可以看到String被改变了，但是在代码里面几乎不会用反射去改变String的值，所以我们认为String类型是不可以变的。</p><p>那么，String类为什么要设计成不可变呢？我们可以从安全和性能两个方面来考虑：</p><ul><li>安全：<ol><li>引发安全问题，譬如数据库名称、密码都是字符串的的形式传入获取数据库连接，或者在socket编程中主机名和端口都是以字符串的形式传入。因为字符串是不可以变的，所以它的值是不可变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，搞成安全漏洞。</li><li>保证线程安全，在并发环境中多个线程同时读写资源时，会引起线程不安全，由于String是不可以变的，不会引起线程问题。</li><li>HashCode，当String被创建的时候，HashCode的值也会被缓存，HashCode的值与value有关，如果String改变，那么HashCode也会随之改变，针对Map、Set等容器的键值需要保证唯一性和一致性，String不可以变保证了这个特性。</li></ol></li><li>性能<ol><li>当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字符的字符串，让不同的引用指向同一个字符串，为运行时节约了很多堆内存。若字符串改变，字符串常量池则失去意义，基于常量池的<code>String.intern()</code>方法也会失效，每次创建新的String将在堆内存创建新的空间，占用更多更多的内存。</li></ol></li></ul><h3 id="四-intern-方法"><a href="#四-intern-方法" class="headerlink" title="四  intern()方法"></a>四  intern()方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt; </span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the </span></span><br><span class="line"><span class="comment"> * class &lt;code&gt;String&lt;/code&gt;. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt; </span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a </span></span><br><span class="line"><span class="comment"> * string equal to this &lt;code&gt;String&lt;/code&gt; object as determined by </span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is </span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &lt;code&gt;String&lt;/code&gt; object is added to the </span></span><br><span class="line"><span class="comment"> * pool and a reference to this &lt;code&gt;String&lt;/code&gt; object is returned. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt; </span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt;, </span></span><br><span class="line"><span class="comment"> * &lt;code&gt;s.intern() == t.intern()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; </span></span><br><span class="line"><span class="comment"> * if and only if &lt;code&gt;s.equals(t)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt; </span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are </span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the </span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java™ Language Specification&lt;/cite&gt;. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is </span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings. </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>从源码中可以看出<code>intern()</code>是一个<code>native</code>方法，但是注释写的非常清楚了。”如果常量池中存在当前字符串，则直接返回当前字符串，如果常量池中没有该字符串，会将此字符串放入常量池中后，再返回”。</p><p><code>native</code>是一个本地方法，底层通过JNI调用C++方法，核心方法如下：<br>\openjdk8\jdk\src\share\native\java\lang\String.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Java_java_lang_String_intern</span>(JNIEnv *env, jobject <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JVM_InternString</span>(env, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oop result = StringTable::<span class="built_in">intern</span>(string, CHECK_NULL);</span><br><span class="line"></span><br><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(Handle string_or_null, jchar* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> len, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hashValue = java_lang_String::<span class="built_in">hash_string</span>(name, len);</span><br><span class="line">  <span class="type">int</span> index = <span class="built_in">the_table</span>()-&gt;<span class="built_in">hash_to_index</span>(hashValue);</span><br><span class="line">  oop string = <span class="built_in">the_table</span>()-&gt;<span class="built_in">lookup</span>(index, name, len, hashValue);</span><br><span class="line">  <span class="comment">// Found</span></span><br><span class="line">  <span class="keyword">if</span> (string != <span class="literal">NULL</span>) <span class="keyword">return</span> string;</span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">the_table</span>()-&gt;<span class="built_in">basic_add</span>(index, string_or_null, name, len,</span><br><span class="line">                                hashValue, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的大体实现就是：Java通过JNI调用C++实现的<code>StringTable.intern</code>方法，StringTable.intern方法跟Java中的<code>HashMap</code>实现差不多，只是不能扩容，默认大小1009。要注意的是String的String Pool是一个固定的大小<code>HashTable</code>，默认值大小是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表很长，而链表长了就会直接造成调用<code>String.intern</code>性能下降。在JDK6中<code>StringTable</code>是固定的，JDK7可以通过参数<code>-XX:StringTableSize=99991</code>指定。</p><h4 id="JDK6和JDK7下intern的区别"><a href="#JDK6和JDK7下intern的区别" class="headerlink" title="JDK6和JDK7下intern的区别"></a>JDK6和JDK7下intern的区别</h4><p>我们都做过类似<code>String abc = new String(&quot;abc&quot;)</code>这个语句创建了几个对象的题目。这种题目主要是为了考察我们对字符串对象的常量池掌握与否。上面的语句创建了2个对象，一个对象是”abc”字符串储存在常量池，另一个是在Java堆中的String对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>打印结果是</p><ul><li>JDK6 <code>false</code> <code>false</code></li><li>JDK7 <code>false</code> <code>true</code></li></ul><h5 id="JDK6中的解释"><a href="#JDK6中的解释" class="headerlink" title="JDK6中的解释"></a>JDK6中的解释</h5><p><img src="https://qtspace.cn/contentimg/3.png"></p><p>注：图中红色线条代表 string 对象的内容指向。 黑色线条代表地址指向。</p><p>在JDK6中都是<code>false</code>，因为JDK6中常量池是在方法区中，方法(Perm)区和堆(Heap)是完全分开的。上面代码中用引号直接创建的对象会直接在常量池中，而new出来的String对象是在堆中的，所以拿一个方法(Perm)区的对象地址和堆(Heap)中的对象地址做比较是肯定不相同的。</p><h5 id="JDK7中的解释"><a href="#JDK7中的解释" class="headerlink" title="JDK7中的解释"></a>JDK7中的解释</h5><p><img src="https://qtspace.cn/contentimg/4.jpg"></p><p>在JDK7中，打印结果是<code>false true</code>，字符串常量池是在堆(Heap)中的，解释如下：</p><ul><li>在第一段代码<code>String s = new String(&quot;1&quot;);</code>生成两个对象，一个是常量池中的“1”和JAVA堆(Heap)中的字符串对象。<code>s.intern;</code>这一句是s对象去常量池中寻址后发现有”1”已经才常量池中了。</li><li>接下来<code>String s2 = &quot;1&quot;;</code>这句代码是生成s2的引用对象指向常量池中的”1”对象，s1和s2的引用地址明显不同，所以是<code>false</code>。</li><li>再看<code>String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);</code>这句代码最终生成2个对象，是字符串常量池中的”1”和堆(Heap)中s3引用的对象，中间还有两个匿名对象先不讨论。此时s3引用对象的内容是”11”，而且”11”在常量池中是不存在的。</li><li>接下来<code>s3.intern();</code>，将s3中的”11”字符串存入String常量池，因为此时常量池中没有”11”，所以在常量池中生成”11”对象，关键JDK中常量池不存在方法区了，而是存在堆中，常量池中不需要在储存一份对象了，可以直接存储堆中的引用，也就是说引用地址就是s3的引用地址。</li><li>最后<code>String s4 = &quot;11&quot;;</code>是声明创建字符串，所以是直接去常量池创建，此时常量池存在”11”对象了，所以会s4引用指向该对象，也就是指向s3的引用了，所以s3和s4引用是一样的，所以<code>s3 == s4</code>是<code>true</code>。</li></ul><p>再看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">s3.intern();</span><br><span class="line">System.out.println(s3 == s4);</span><br></pre></td></tr></table></figure><p>打印结果是：</p><ul><li>JDK6 <code>false</code> <code>false</code></li><li>JDK7 <code>false</code> <code>false</code></li></ul><p>JDK6中解释是和上面一样的，在JDK7中解释有点不一样，如图：</p><p><img src="https://qtspace.cn/contentimg/5.jpg"></p><ul><li>在代码s和s1中，s引用对象是指向堆中，s2引用对象是指向常量池中，<code>s.intern();</code>这行代码往后执行不会有什么影响，因为”1”在常量池中已经存在了，所以s和s1的引用对象是不同的。</li><li>再看s3和s4，区别就是<code>s3.intern();</code>往后执行，首先先执行<code>String s4 = &quot;11&quot;; </code>常量池不存在”11”，所以生成”11”对象，s4引用并指向该对象，然后<code>s3.intern();</code>此时”11”在常量池中已经存在了，所以没有什么影响，s3引用对象在堆中，s4引用对象在常量池中，所以引用对象是不同的，所以<code>s3 == s4</code>是<code>false</code>。</li></ul><p>从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点：</p><ul><li>将String常量池从Perm区移动到了Java Heap区</li><li><code>String.intern</code> 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。</li></ul><h3 id="五-常用API"><a href="#五-常用API" class="headerlink" title="五  常用API"></a>五  常用API</h3><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>str.concat()</code></td><td align="center">字符串连接，替换+号</td></tr><tr><td align="center"><code>str.lengt()</code></td><td align="center">获取字符串长度</td></tr><tr><td align="center"><code>isEmpty()</code></td><td align="center">判断字符串是否为空</td></tr><tr><td align="center"><code>str.charAt(0)</code></td><td align="center">获取指定位置元素</td></tr><tr><td align="center"><code>str.codePointAt(0)</code></td><td align="center">获取指定位置元素，并返回ASCII码值</td></tr><tr><td align="center"><code>str.getBytes()</code></td><td align="center">获取byte[]</td></tr><tr><td align="center"><code>str.equals(&quot;abc&quot;)</code></td><td align="center">字符串内容比较</td></tr><tr><td align="center"><code>str.equalsIgnoreCase(&quot;abc&quot;)</code></td><td align="center">忽略大小写内容比较</td></tr><tr><td align="center"><code>str.startsWith(&quot;abc&quot;)</code></td><td align="center">开始位置值判断</td></tr><tr><td align="center"><code>str.endsWith(&quot;abc&quot;)</code></td><td align="center">结束位置值判断</td></tr><tr><td align="center"><code>str.indexOf(&quot;abc&quot;)</code></td><td align="center">判断元素开始位置</td></tr><tr><td align="center"><code>str.lastIndexOf(&quot;abc&quot;)</code></td><td align="center">判断元素结束位置</td></tr><tr><td align="center"><code>str.substring(0 ,1)</code></td><td align="center">字符串截取</td></tr><tr><td align="center"><code>str.split(&quot;,&quot;)</code></td><td align="center">字符串拆分，支持正则</td></tr><tr><td align="center"><code>str.replace(&quot;a&quot;,&quot;b&quot;)</code><br /><code>str.replaceAll</code></td><td align="center">字符串替换</td></tr><tr><td align="center"><code>str.toUpperCase()</code></td><td align="center">转大写</td></tr><tr><td align="center"><code>str.toLowerCase()</code></td><td align="center">转小写</td></tr><tr><td align="center"><code>str.toCharArray()</code></td><td align="center">转char[]</td></tr><tr><td align="center"><code>String.format(str, &quot;&quot;)</code></td><td align="center">格式化</td></tr><tr><td align="center"><code>str.valueOf(&quot;123&quot;)</code></td><td align="center">转字符串</td></tr><tr><td align="center"><code>str.trim()</code></td><td align="center">首位去空格</td></tr><tr><td align="center"><code>str.hashCode()</code></td><td align="center">获取hashcode值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一-String描述&quot;&gt;&lt;a href=&quot;#一-String描述&quot; class=&quot;headerlink&quot; title=&quot;一  String描述&quot;&gt;&lt;/a&gt;一  String描述&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="String" scheme="http://qtspace.cn/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>HashCode &amp; HashMap扰动函数</title>
    <link href="http://qtspace.cn/2022/03/05/HashCode%20&amp;%20HashMap%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://qtspace.cn/2022/03/05/HashCode%20&amp;%20HashMap%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-04T16:00:00.000Z</published>
    <updated>2022-03-05T14:20:27.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-HashCode为什么用31作为乘数？"><a href="#1-HashCode为什么用31作为乘数？" class="headerlink" title="1.HashCode为什么用31作为乘数？"></a>1.HashCode为什么用31作为乘数？</h3><p>String.class的hashCode方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.lengt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span>[] val = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i]</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法中有一个写死固定值31，想必大家在看String的hashCode方法源码时都会有这个疑问，为什么是31？</p><ul><li>hash函数必须选用质数，这是被科学家论证过的hash函数减少冲突的理论。</li><li>如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为使用偶数相当于位运算（低位补0）。</li><li>使用31有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能：31*i &#x3D; (i &lt;&lt; 5) - i，目前使用的JVM自动完成此类优化。</li><li>31是个不大不小的质数，hash碰撞概率很低，而且生成的hash值很均匀的散列。（可以通过实验得出）</li></ul><h3 id="2-HashMap"><a href="#2-HashMap" class="headerlink" title="2. HashMap"></a>2. HashMap</h3><h4 id="2-1-HashMap扰动函数"><a href="#2-1-HashMap扰动函数" class="headerlink" title="2.1 HashMap扰动函数"></a>2.1 HashMap扰动函数</h4><p>Java8中HashMap获取hash值的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> h;</span><br><span class="line">   <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode() ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法中获取key的下标值方法为：n是map的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><p>看到HashMap的获取hash方法的源码时，都会思考为什么使用扰动函数计算，为什么不能直接用key的hashCode的值？</p><ul><li>首先，hashCode的取值范围是[-2^32, 2^31]，也就是[[-2147483648, 2147483647]，有将近40亿的长度，不可能把数组初始化得这么大，内存也放不下。</li><li>所以，我们要将hashCode的值进行扰动计算（h &#x3D; key.hashCode() ^ (h &gt;&gt;&gt; 16)）,把hash值往右移16位，右移高位补0，相当于把高位移到了低位，然后再与原先的hash值做异或运算(相同为0，不相同为1)，这就相当于混合了原hash值中的高位和低位，得到一个更加散列的低 16 位的 Hash 值，增大了随机性。最后与map数组的大小-1做与运算，高位全部归0，只保留末四位<br>计算方式如下图：比如原hash值为：00000000 11111111 00000000 00001010</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashCode()      00000000 11111111 00000000 00001010hash值</span><br><span class="line">hashCode() &gt;&gt;&gt; 16     00000000 00000000 00000000 11111111右移16位</span><br><span class="line">hashCode() ^ (hashCode() &gt;&gt;&gt; 16)    00000000 11111111 00000000 11110101  异或高低位(相同为0,不相同为1)</span><br><span class="line">hashCode() ^ (hashCode() &gt;&gt;&gt; 16) &amp; 15 00000000 00000000 00000000 00001111 与运算下标(都为1则为1,否则为0)</span><br><span class="line">  00000000 00000000 00000000 00000101</span><br><span class="line">                                         = 0101 </span><br><span class="line">                                         = 5</span><br></pre></td></tr></table></figure><ul><li>一句话，使用扰动函数就是为了增加随机性，让数据元素更加均匀的散列，减少碰撞。</li></ul><h4 id="2-2-HashMap初始化容量"><a href="#2-2-HashMap初始化容量" class="headerlink" title="2.2 HashMap初始化容量"></a>2.2 HashMap初始化容量</h4><p>HashMap的初始化含量是16，最大容量是2的30次方，而且容量大小必须是2的倍数，因为只有2的倍数在减1的时候，二进制都是1，从而在与hash值做与运算的时候随机性更大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITAL_CAPCITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span></span><br></pre></td></tr></table></figure><p>如果我们传的值不是2的倍数，比如我们传17，这个时候HashMap会怎么处理呢？</p><p>HashMap构造方法里面，会调用一个tableSizeFor方法进行计算，得到大于我们传的值最小的2倍数的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadlFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tablSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUN_CAPACITY ? MAXIMUM_CAPACITY : n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>MAXIMUN_CAPACITY  &#x3D; 1 &lt;&lt; 30，这个是临界范围，也就是最大的Map集合。</p></li><li><p>tableSizeFor都是在向右移1、2、4、8、16位，然后做或运算(两个位都为0则为0，否则为1)，因为这样子可把二进制的各个位置都填上1，加上1之后，就是一个标准的2的倍数的数了。</p></li><li><p>可以把传入17初始化计算阙值的过程用图展示出来，方便理解，最后得到的数就是32</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span> - <span class="number">1</span> <span class="number">10000</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">1</span>  <span class="number">01000</span> </span><br><span class="line">n | n &gt;&gt;&gt; <span class="number">1</span><span class="number">11000</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">2</span><span class="number">00110</span></span><br><span class="line">n | n &gt;&gt;&gt; <span class="number">2</span><span class="number">11110</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">4</span> <span class="number">00001</span></span><br><span class="line">n | n &gt;&gt;&gt; <span class="number">4</span><span class="number">11111</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">8</span><span class="number">00000</span></span><br><span class="line">n | n &gt;&gt;&gt; <span class="number">8</span>     <span class="number">11111</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">16</span><span class="number">00000</span></span><br><span class="line">n | n &gt;&gt;&gt; <span class="number">16</span>    <span class="number">11111</span> = <span class="number">31</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-3-HashMap负载因子"><a href="#2-3-HashMap负载因子" class="headerlink" title="2.3 HashMap负载因子"></a>2.3 HashMap负载因子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>负载因子用于当容量超过某个阙值时，要进行扩容操作。在HashMap中，负载因子决定了数据量多少了以后可以进行扩容。比如HashMap的容量大小为16，当容量超过 16*0.75&#x3D;12个元素时，就要进行扩容操作了，这样子做的原因是因为可能出现即使你的元素数量比容量大时也不一定能填满容量，因为某些位置会出现碰撞，使用链表存放了，如果存在大量的链表，这样子就失去了Map的数组的性能了。所以要选择一个合理的大小进行扩容，HashMap默认值是0.75，当阙值容量占了3&#x2F;4时进行扩容操作，减少Hash碰撞。同时0.75是一个默认构造值，在创建HashMap也可以做调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一点，减少碰撞。</p><h6 id="2-4-HashMap扩容元素拆分"><a href="#2-4-HashMap扩容元素拆分" class="headerlink" title="2.4 HashMap扩容元素拆分"></a>2.4 HashMap扩容元素拆分</h6><p>HashMap在扩容的时候要把原先的元素拆分到新的数组中，拆分过程中，原jdk1.7中会需要重新计算哈希值，但在jdk1.8中进行了优化，不再重新计算，提升了拆分的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;zuio&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;zuio的扰动hash值：&quot;</span> + Integer.toBinaryString(hash));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为16的下标二进制值：&quot;</span> + Integer.toBinaryString(hash &amp; (<span class="number">16</span> - <span class="number">1</span>) ));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为16的下标十进制值：&quot;</span> + ((<span class="number">16</span> - <span class="number">1</span>) &amp; hash));</span><br><span class="line">System.out.println(<span class="string">&quot;zuio hash值原容量16与运算结果为：&quot;</span> + (hash &amp; <span class="number">16</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为32的下标二进制值：&quot;</span> + Integer.toBinaryString(hash &amp; (<span class="number">32</span> - <span class="number">1</span>) ));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为32的下标十进制值：&quot;</span> + ((<span class="number">32</span> - <span class="number">1</span>) &amp; hash));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> <span class="string">&quot;plop&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">hash2</span> <span class="operator">=</span> key2.hashCode() ^ (key2.hashCode() &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;zuio的扰动hash值：&quot;</span> + Integer.toBinaryString(hash2));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为16的下标二进制值：&quot;</span> + Integer.toBinaryString(hash2 &amp; (<span class="number">16</span> - <span class="number">1</span>) ));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为16的下标十进制值：&quot;</span> + ((<span class="number">16</span> - <span class="number">1</span>) &amp; hash2));</span><br><span class="line">System.out.println(<span class="string">&quot;plop hash值与原容量16与运算结果为：&quot;</span> + (hash2 &amp; <span class="number">16</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为32的下标二进制值：&quot;</span> + Integer.toBinaryString(hash2 &amp; (<span class="number">32</span> - <span class="number">1</span>) ));</span><br><span class="line">System.out.println(<span class="string">&quot;容量为32的下标十进制值：&quot;</span> + ((<span class="number">32</span> - <span class="number">1</span>) &amp; hash2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面输出结果为</span></span><br><span class="line"><span class="comment">// zuio的扰动hash值：1110010011100110011000</span></span><br><span class="line"><span class="comment">// 容量为16的下标二进制值：1000</span></span><br><span class="line"><span class="comment">// 容量为16的下标十进制值：8</span></span><br><span class="line"><span class="comment">// zuio hash值与原容量16与运算结果为：16</span></span><br><span class="line"><span class="comment">// 容量为32的下标二进制值：11000</span></span><br><span class="line"><span class="comment">// 容量为32的下标十进制值：24</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// plop的扰动hash值：1101001000110011101001</span></span><br><span class="line"><span class="comment">// 容量为16的下标二进制值：1001</span></span><br><span class="line"><span class="comment">// 容量为16的下标十进制值：9</span></span><br><span class="line"><span class="comment">// plop hash值与原容量16与运算结果为：0</span></span><br><span class="line"><span class="comment">// 容量为32的下标二进制值：1001</span></span><br><span class="line"><span class="comment">// 容量为32的下标十进制值：9</span></span><br></pre></td></tr></table></figure><p>通过上面两个例子可以得出以下结论：原hash值与原容量进行&amp;运算，如果结果为0，则下标位置不变，如果不为0，则新的下标在原先的位置上加上原先的容量（我只举了两个例，可以多举些例子，最后都可以得到上面结论）。在HashMap扩容方法resize核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// hash值与原容量&amp;运算</span></span><br><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 原索引</span></span><br><span class="line">    <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">    loHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    loTail.next = e;</span><br><span class="line">    loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 原索引 + 原容量</span></span><br><span class="line">    <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">    hiHead = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    hiTail.next = e;</span><br><span class="line">    hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap每一次执行扩容后，数组长度都变成原来的2倍，所以就是数组长度转为二进制后比原来多了一位，比如原先16-1，二进制为1111，扩容之后为32-1，二进制为11111，二进制都多了一位。多出来的这一位与hash值的同一位做&amp;运算，结果为0则索引不变，结果为1则索引为原索引+原数组长度，栗子如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">多出来的二进制一位1与hash做与运算为1, 为索引为原索引 + 原数组长度</span><br><span class="line">原数组上次16-1的二进制:   0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">新数组长度32-1的二进制:    0000 0000 0000 0000 0000 0000 0001 1111</span><br><span class="line">字符串zuio的扰动hash值:   0000 0000 0011 1001 0011 1001 1001 1000</span><br><span class="line">多出来的这一位与运算结果     1 </span><br><span class="line"> </span><br><span class="line">多出来的二进制一位1与hash做与运算为0, 为索引为原索引    </span><br><span class="line">原数组上次16-1的二进制:   0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">新数组长度32-1的二进制:    0000 0000 0000 0000 0000 0000 0001 1111</span><br><span class="line">字符串plop的扰动hash值:   0000 0000 0011 0100 1000 1100 1110 1001</span><br><span class="line">        多出来的这一位与运算结果     0</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-HashCode为什么用31作为乘数？&quot;&gt;&lt;a href=&quot;#1-HashCode为什么用31作为乘数？&quot; class=&quot;headerlink&quot; title=&quot;1.HashCode为什么用31作为乘数？&quot;&gt;&lt;/a&gt;1.HashCode为什么用31作为乘数？&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="HashCode" scheme="http://qtspace.cn/tags/HashCode/"/>
    
    <category term="HashMap" scheme="http://qtspace.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java中ArrayList和LinkedList的区别</title>
    <link href="http://qtspace.cn/2022/03/02/ArrayList%E5%92%8CLinkedList/"/>
    <id>http://qtspace.cn/2022/03/02/ArrayList%E5%92%8CLinkedList/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:39.029Z</updated>
    
    <content type="html"><![CDATA[<p>两者数据结构不同，ArrayList是基于数组实现、LinkedList是基于双向链表实现。从获取、删除、插入、内存开销这几个点来说明两者的区别。</p><h3 id="1、-获取："><a href="#1、-获取：" class="headerlink" title="1、 获取："></a>1、 获取：</h3><p>ArrayList的获取比LinkedList获取相比非常快，因为ArrayList的get方法的时间复杂度为O(1)，而LinkList的为O(n)。</p><p>ArrayList的get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 直接下标获取数组值, 时间复杂度为O(1)</span></span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkList的get方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkList还提供获取首位元素的方法，getFirst、getList，这两个方法的时间复杂度为O(1)。</p><p>结论：ArrayList元素的获取性能比LinkedList高。</p><h3 id="2、删除："><a href="#2、删除：" class="headerlink" title="2、删除："></a>2、删除：</h3><p>LinkedList删除时间复杂度为O(1)，这个O(1)只是从删除的操作来说，因为LinkedList在删除的时候也会进行for循环获取删除的节点。而ArrayList删除时间复杂度是可变的，删除第一个元素是最坏的情况时间复杂度为O(n)，这是因为删除第一个元素要进行数组的copy从而移动数组，删除最后一个元素是最好的情况时间复杂度为O(1)，这是因为ArrayList删除最后一个元素时就是把最后一个元素置为null。</p><p>LinkedList删除方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">emelemt</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>LinkedList还提供了删除收尾元素的方法，removeFirst()、removeLast()。</p><p>ArrayList删除源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">     rangeCheck(index);</span><br><span class="line"></span><br><span class="line">     modCount++;</span><br><span class="line">     <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">         System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                          numMoved);</span><br><span class="line">     elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结论：LinkedList元素删除比ArrayList要快。</p><p>原因：LinkedList的每个元素都维护着两个指针，它们指向列表中的两个相邻元素。因此删除只需要更改将要删除的节点的两个相邻节点中的指针位置。而ArrayList都要进行数组copy移动填充删除元素创建的空间。</p><h3 id="3、-插入"><a href="#3、-插入" class="headerlink" title="3、 插入"></a>3、 插入</h3><p>LinkedList add方法就是向尾部插入方法，时间复杂度为O(1)，而ArrayList add方法时间复杂度是可变的最坏为O(n)，原因是ArrayList扩容的时候需要元素的复制移动。</p><p>LinkedList add方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList add方法扩容源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下插入LinkedList性能比ArrayList性能要高，但是也不能绝对的说LinkedList插入的性能高，因为这个要根据容量和插入操作（头插、尾插、中间插）来决定。可以通过实验得出以下结论，10万、100万、1000万数据插入的时候：</p><p>头插：LinkedList性能比ArrayList高，因为ArrayList要进行大量的复制和位置操作，而LinkedList只是一个对象的实例化。</p><p>尾插：ArrayList性能比LinkedList高，因为ArrayList不需要频繁的扩容，而LinkedList需要大量的创建对象。</p><p>中间插：ArrayList性能比LinkedList高，因为LinkedList需要遍历寻址。</p><p>所以在不同的情况下，需要选择不同的List集合做业务。</p><h3 id="4、内存开销"><a href="#4、内存开销" class="headerlink" title="4、内存开销"></a>4、内存开销</h3><p>ArrayList维护索引和元素数据，而LinkedList维护元素数据和相邻节点的两个指针，所以LinkedList的内存消耗相对较高。</p><h4 id="什么时候用LinkedList，什么时候用ArrayList？"><a href="#什么时候用LinkedList，什么时候用ArrayList？" class="headerlink" title="什么时候用LinkedList，什么时候用ArrayList？"></a>什么时候用LinkedList，什么时候用ArrayList？</h4><p>通过上面对比，从时间复杂度来说，LinkedList的插入和删除提供了更好的性能，因此在业务中需要频繁的增删操作，查询较少选择LinkedList较合适。而ArrayList的获取性能比LinkedList高，因此在业务中增删操作较少，获取操作比较多选择ArrayList较合适。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两者数据结构不同，ArrayList是基于数组实现、LinkedList是基于双向链表实现。从获取、删除、插入、内存开销这几个点来说明两者的区别。&lt;/p&gt;
&lt;h3 id=&quot;1、-获取：&quot;&gt;&lt;a href=&quot;#1、-获取：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="ArrayList" scheme="http://qtspace.cn/tags/ArrayList/"/>
    
    <category term="LinkedList" scheme="http://qtspace.cn/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Collcetions 工具类</title>
    <link href="http://qtspace.cn/2022/03/02/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://qtspace.cn/2022/03/02/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:34.678Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.util.Collections</code> 是java集合框架中的一个工具类，主要用于Collectiont提供的通用算法，比如：<strong>排序</strong>(<code>sort</code>)、<strong>二分查找</strong>(<code>binarySearch</code>)、<strong>洗牌</strong>(<code>shuffle</code>)、<strong>旋转</strong>(<code>rotate</code>)</p><h3 id="1-Collections-sort-排序"><a href="#1-Collections-sort-排序" class="headerlink" title="1.  Collections.sort 排序"></a>1.  Collections.sort 排序</h3><ul><li><p>方法使用，代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;9&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认排序(正序) 测试结果为3, 4, 7, 8, 9</span></span><br><span class="line">list.sort(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator排序 可以已定义正序、倒叙, 还可以支持以对象的某个字段进行排序</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="comment">// 倒叙 正序的话 return o1.compareTo(o2);</span></span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverseOrder 倒叙 </span></span><br><span class="line">Collections.sort(list, Collections.&lt;String&gt;reverseOrder());</span><br></pre></td></tr></table></figure></li><li><p>源码分析</p><p>Collections.sort集合排序最终调用的是<code>java.util</code>包下<code>Arrays</code>类的  <code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>，这个方法根据有没有传入<code>Compararot c</code> 调用快速排序(<code>sort()</code>)和优化的归并排序(<code>TimSort.sort()</code>)，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实际调用的是ComparableTimSort.sort</span></span><br><span class="line">        sort();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 默认关闭</span></span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认关闭</span></span><br><span class="line">    <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">        legacyMergeSort(a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ComparableTimSort.sort(a, <span class="number">0</span>, a.length, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在快速排序和归并排序中，会判断个数是否大于32，从而选择分段排序和二分插入排序，部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComparableTimSort类 和TimSort类方法一样</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, <span class="type">int</span> lo, <span class="type">int</span> hi, Object[] work, <span class="type">int</span> workBase, <span class="type">int</span> workLen)</span> &#123;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">initRunLen</span> <span class="operator">=</span> countRunAndMakeAscending(a, lo, hi);</span><br><span class="line">        <span class="comment">// 二分插入排序</span></span><br><span class="line">        binarySort(a, lo, hi, lo + initRunLen);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分段排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Collections-binarySearch-二分查找"><a href="#2-Collections-binarySearch-二分查找" class="headerlink" title="2. Collections.binarySearch 二分查找"></a>2. Collections.binarySearch 二分查找</h3><p>二分查找的前提是集合有序，否则不能满足二分算法的查找过程。</p><ul><li><p>方法使用，代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"><span class="comment">// 二分查找, 传入list和需要查找的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Collections.binarySearch(list, <span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">// 输出4</span></span><br><span class="line">System.out.println(<span class="string">&quot;二分查找：&quot;</span> + idx);</span><br></pre></td></tr></table></figure></li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>&lt;T&gt; <span class="title function_">binarySearch</span> <span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="comment">// list继承RandAccess或者list的大小小于二分查找最大阙值5000</span></span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="comment">// 调用下标二分查找</span></span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 调用迭代器二分查找 考虑到LinkedList的get方法时间复杂度是O(n)</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteartorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标二分查找</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始低位为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始高位为list.size() - 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while循环低位小于等于高位</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 位运算获取中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取中间下标元素</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = list.get(mid);</span><br><span class="line">        <span class="comment">// 调用compareTo方法, 中间元素和寻找元素做对比 大于返回大于0, 小于返回小于0, 相等返回0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 小于0说明中间元素小于寻找元素, 说明寻找元素在右边, 低位 = 中间下标 + 1</span></span><br><span class="line">            low = mit + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 大于0说明中间元素大于寻找元素, 说明寻找元素在左边, 高位 = 中间下标 - 1</span></span><br><span class="line">            high = mit - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 相等 找到该值 返回中间下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到返回 -(low + 1)</span></span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器二分查找, 原理和下标二分查找一样, 核心通过compareTo做比较查找元素, 区别就是在获取中间下标元素上</span></span><br><span class="line"><span class="comment">// 迭代器二分查找通过迭代器获取元素, 时间复杂度为O(n), 也做了优化,通过迭代器的下一个元素的下标和中间下标做比较,</span></span><br><span class="line"><span class="comment">// 判断中间下标元素是在前面(previous)还是后面(next)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始低位为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始高位为集合大小 - 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取集合迭代器</span></span><br><span class="line">    ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while循环低位小于等于高位</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 通过位运算获取中间下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过迭代器获取中间下标元素值</span></span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; mitVal = get(i, mid);</span><br><span class="line">        <span class="comment">// 中间值和寻找值做对于 大于返回大于0, 小于返回小于0, 相等返回等于0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> mitVal.compareTo(key);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 中间值小于寻找值, 说明寻找值在右边, 低位 = 中间下标 + 1 </span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 中间值大于寻找值, 说明寻找值在左边, 高位 = 中间下标 - 1</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 找到该值 返回下标</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到返回 -(low + 1)</span></span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器获取中间下标元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(ListIterator&lt;? extends T&gt; i, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 迭代器下一个元素下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i.nextIndex();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= inde)&#123;</span><br><span class="line">        <span class="comment">// 下一个元素下标值小于等于寻找下标值, 所以寻找下标值在链表的后面(next)</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.next();</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos++ &lt; index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 下一个元素下标值小于寻找下标值, 所以寻找下标值在链表的前面(prev)</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.previous();</span><br><span class="line">        &#125; <span class="keyword">while</span> (--pos &gt; index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面二分查找源码流程如下：</p><ol><li>判断list是RandomAccess或者list的容量小于二分查找阙值5000，则调用下标二分查找，否则调用迭代器二分查找。</li><li>初始化低位为0，高位为<code>list.size()-1</code>，while循环知道直到元素或者<code>low &gt; high</code> </li><li>通过位运算获取中间下标<code>(low + high) &gt;&gt;&gt; 1</code> 返回<code>mid</code></li><li>通过<code>mid</code>下标元素(二分查找直接通过<code>list.get()</code>获取，迭代器二分查找通过迭代器<code>get()</code>获取)。</li><li>中间元素和寻找元素调用<code>comparteTo()</code>方法做比较返回<code>cmp</code>，如果<code>cmp &lt; 0</code>，说明中间值小于寻找值，则寻找元素在右边，低位 &#x3D; <code>mid + 1</code>，如果<code>cmp &gt; 0</code>，说明中间值大于寻找值，则寻找元素在左边，高位 &#x3D; <code>mid - 1</code>，如果<code>mid = 0</code>说明找到寻找元素，返回中间下标。</li></ol></li></ul><h3 id="3-Collections-shuffle-洗牌算法"><a href="#3-Collections-shuffle-洗牌算法" class="headerlink" title="3. Collections.shuffle 洗牌算法"></a>3. Collections.shuffle 洗牌算法</h3><p>洗牌算法就是将List集合中的元素打乱，一般可以用于抽奖、摇号、洗牌等场景。</p><ul><li><p>方法使用，代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两种使用方式 一种是直接传入list </span></span><br><span class="line"><span class="comment">//另一种还可以传入固定随机种子, 这种方式可以控制洗牌范围</span></span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">Collections.shuffle(list, <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure></li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> r;</span><br><span class="line">    <span class="comment">// 没有传入固定随机种子则初始化</span></span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="literal">null</span>)</span><br><span class="line">        r = rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="comment">// 洗牌算法</span></span><br><span class="line">    shuffle(list, rnd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> &#123;</span><br><span class="line">    <span class="comment">// 集合容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="comment">// 集合容量小于洗牌阙值5 或者 是RandomAccess</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list.<span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="comment">// for循环调用交换算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i - <span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 集合容量大于洗牌阙值5, 且不是RandomAccess, 比如LindedList</span></span><br><span class="line">        <span class="comment">// 转成数组,对数组做调换操作, 不调用list的set方法主要是因为LindedList的set方法要获取传入下标的元素,获取元素</span></span><br><span class="line">        <span class="comment">// 时间复杂度为O(n)性能低</span></span><br><span class="line">        Object[] arr = list.toArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for循环对数组进行调换算法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; <span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i - <span class="number">1</span>, rnd,nextInt(i));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过迭代器进行元素的调换, 使用迭代器的set方法性能就是很高,因为可以通过迭代器获取元素</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">it</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            it.next();</span><br><span class="line">        it.set(arr[i]);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> list;</span><br><span class="line">    <span class="comment">// 通过list.set(int index, E e)方法进行元素调换, 该方法返回原元素</span></span><br><span class="line">    <span class="comment">// 比如list(1, 2, 3, 4, 5, 6, 7, 8) i = 7, j = 0</span></span><br><span class="line">    <span class="comment">// 首先 l.set(j, l.get(i)) 将下标为7的元素调到下位为0的位置,并返回元素1, 此时list为(8,2,3,4,5,6,7,8)</span></span><br><span class="line">    <span class="comment">// l.set(i, 1), 将元素1设置到下标7, 此时list为(8,2,3,4,5,6,7,1)</span></span><br><span class="line">    <span class="comment">// 这样子就完成了元素调换</span></span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Object[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标i元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    <span class="comment">// 将下标j元素赋值到下标i位置</span></span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    <span class="comment">// 下标i元素赋值到下标j位置</span></span><br><span class="line">    <span class="comment">// 完成下标i, j的调换</span></span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面洗牌算法<code>shuffle(List&lt;?&gt; list, Random rnd)</code>流程如下</p><ol><li>判断容量是否小于洗牌阙值<code>5</code>或者是<code>RandomAccess</code>，来调用不同的调换算法</li><li>容量小于<code>5</code>或者是<code>RandomAccess</code>，通过循环容量大小得到当前下标和随机下标，然后通过<code>list.set(int index, E e)</code>方法将两个下标元素调换。</li><li>如果容量大于<code>5</code>且不是<code>RandomAccess</code>，通过将<code>list</code>转成数组，然后循环容量大小得到当前下标和随机下标，然后通过数组赋值调换元素，最后通过循环数组，通过list的迭代器将数组里面的元素赋值到<code>list</code>。</li></ol></li></ul><h3 id="1-4-Collections-rotate-旋转算法"><a href="#1-4-Collections-rotate-旋转算法" class="headerlink" title="1.4 Collections.rotate 旋转算法"></a>1.4 Collections.rotate 旋转算法</h3><p><code>rotate</code>旋转算法可以把<code>ArrayList</code>、<code>LinkedList</code>从指定的位置开始，进行顺时针或者逆时针旋转操作。</p><ul><li><p>方法使用，代码测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将list顺时针旋转2位, 逆时针旋转为负数</span></span><br><span class="line"><span class="comment">// 输出为 4,5,1,2,3</span></span><br><span class="line">Collections.rotate(list, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出为 3,4,5,1,2</span></span><br><span class="line">Collections.rotate(list, -<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">        rotate1(list, distance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rotate2(list, distance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">rotate1</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="comment">// 集合容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="comment">// 集合容量为0直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算旋转的距离</span></span><br><span class="line">    distance = distance % size;</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">        distance += size;</span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// for循环和do while,配合每次的旋转操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cycleStart</span> <span class="operator">=</span> <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        <span class="comment">// 旋转的元素</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">displaced</span> <span class="operator">=</span> list.get(cycleStart);</span><br><span class="line">        <span class="comment">// 旋转的元素下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cycleStart;</span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">           i += distance;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; size)</span><br><span class="line">               i -= size;</span><br><span class="line">            <span class="comment">// 通过list.set方法旋转元素</span></span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  -distance % size;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">        reverse(list.subList(mid, size));</span><br><span class="line">        reverse(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">            swap(list, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">fwd</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">rev</span> <span class="operator">=</span> list.listIterator(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">tmp</span> <span class="operator">=</span> fwd.next();</span><br><span class="line">            fwd.set(rev.previous());</span><br><span class="line">            rev.set(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rotate1</code>方法流程如下：</p><ol><li>判断集合容量，并计算旋转的距离。</li><li><code>for</code>循环和<code>do while</code>配合每次的旋转，比如这里第一次会把0位置元素替换到2位置，此时<code>list</code>是<code>1,2,1,4,5</code>,<code>do while</code>中会判断<code>i != cycleStart</code>，当<code>i == cycleStart</code>的时候说明旋转全部的元素了，然后继续把被替换2位置的元素继续往下替换，比如这里第二次会把被替换2位置替换到4位置，此时list是<code>1,2,1,4,3</code>，直到一轮循环把所有元素都放置到正确位置。</li><li>移动的次数为<code>size</code>表明<code>list</code>全部元素都旋转，结束for循环。</li></ol><p><code>rotate2</code>方法流程如下：该方法主要针对大于100个元素的LinkedList进行操作。</p><ol><li>定位拆链位置， distance % size + size ，也就是我们要旋转后找到的元素位置。</li><li>第一次翻转，把从位置 0 到拆链位置</li><li>第三次翻转，翻转整个链表。</li></ol></li></ul><h3 id="1-5-Collections其他API"><a href="#1-5-Collections其他API" class="headerlink" title="1.5 Collections其他API"></a>1.5 Collections其他API</h3><ul><li><p>最大最小值，主要依赖compareTo方法比较大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"><span class="comment">// 最小值 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(list);</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);</span><br></pre></td></tr></table></figure></li><li><p>元素替换，会判断list是RandomAccess，小于替换阙值11，调用不同的替换值方法，一个是使用list的set方法，一个是使用迭代器的set方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">Collections.replaceAll(list, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>连续集合位置判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); </span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>); </span><br><span class="line">list.add(<span class="string">&quot;9&quot;</span>); </span><br><span class="line"><span class="comment">// 返回2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> Collections.indexOfSubList(list, Arrays.asList(<span class="string">&quot;8&quot;</span>, <span class="string">&quot;3&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>synchronized方法，将非线程安全的集合转换成线程安全集合。Collections内部定义了静态类<code>SynchronizedList</code>、<code>SynchronizedMap</code>，这两个类定义List、Map然后操作方法加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;java.util.Collections&lt;/code&gt; 是java集合框架中的一个工具类，主要用于Collectiont提供的通用算法，比如：&lt;strong&gt;排序&lt;/strong&gt;(&lt;code&gt;sort&lt;/code&gt;)、&lt;strong&gt;二分查找&lt;/strong</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="Collections" scheme="http://qtspace.cn/tags/Collections/"/>
    
  </entry>
  
  <entry>
    <title>Github上传本地项目</title>
    <link href="http://qtspace.cn/2022/03/02/Github%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/"/>
    <id>http://qtspace.cn/2022/03/02/Github%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:32.013Z</updated>
    
    <content type="html"><![CDATA[<p>1.选择项目，右键Git Bash Here（需要安装Git）</p><p>2.在Git命令窗口输入git init命令之后，会生成一个.git文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>3.输入git add . 命令将全部的文件添加到缓存去(注意这个”.”，是有空格的，”.”代表这个test这个文件夹下的目录全部都提交。你也可以通过git add 文件名  提交指定的文件)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>4.输入git commit -m “这里是注释”，把文件提交到本地仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit-m &quot;初始化项目&quot;</span><br></pre></td></tr></table></figure><p>5.连接远程仓库，克隆自己的github项目地址，比如为<a href="https://gitcode.net/CreativeAlliance/lottery-1195-qingtian.git%EF%BC%8C%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E3%80%82%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5github%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81">https://gitcode.net/CreativeAlliance/lottery-1195-qingtian.git，输入命令。连接过程中需要输入github账号密码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://gitcode.net/CreativeAlliance/lottery-1195-qingtian.git</span><br></pre></td></tr></table></figure><p>6.输入命令git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数。然后进去GitHub仓库刷新下就会有已经上传的文件夹了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>7.最后输入git push origin master 将本地仓库推送到远程master分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.选择项目，右键Git Bash Here（需要安装Git）&lt;/p&gt;
&lt;p&gt;2.在Git命令窗口输入git init命令之后，会生成一个.git文件夹&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="Github" scheme="http://qtspace.cn/categories/Github/"/>
    
    
    <category term="Github" scheme="http://qtspace.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Java创建线程池的四种方式</title>
    <link href="http://qtspace.cn/2022/03/02/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://qtspace.cn/2022/03/02/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:25.357Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h5 id="newCachedThreadPool的方式"><a href="#newCachedThreadPool的方式" class="headerlink" title="newCachedThreadPool的方式"></a>newCachedThreadPool的方式</h5><p>这种方式创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程用于执行任务，如果没有空闲线程则新建线程用于执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)&#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">          System.out.println(t + <span class="string">&quot;正在执行任务。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.execute(run);<span class="comment">//将任务指派给线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码控制台输出如下，发现执行任务有相同线程，说明了线程池对空闲线程灵活回收再利用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">4</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">3</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">7</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">8</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">5</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">9</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">11</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">10</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">6</span>,<span class="number">5</span>,main]正在执行任务。</span><br></pre></td></tr></table></figure></li><li><h5 id="newFixedThreadPool的方式"><a href="#newFixedThreadPool的方式" class="headerlink" title="newFixedThreadPool的方式"></a>newFixedThreadPool的方式</h5><p>这种方式创建一个定长线程池，可控制线程的最大并发数，如果超出该并发数，则超出的线程会在队列中等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//创建一个线程个数为2的线程池</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">          System.out.println(t + <span class="string">&quot;正在执行任务。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.execute(run);<span class="comment">//将任务指派为线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码控制台输出如下，说明执行任务只有2两个线程，控制了并发数，超出的线程会进入等待状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-1-thread-1,5,main]正在执行任务。</span><br><span class="line">Thread[pool-1-thread-2,5,main]正在执行任务。</span><br><span class="line">Thread[pool-1-thread-1,5,main]正在执行任务。</span><br><span class="line">Thread[pool-1-thread-1,5,main]正在执行任务。</span><br><span class="line">Thread[pool-1-thread-2,5,main]正在执行任务。</span><br></pre></td></tr></table></figure></li><li><h5 id="newScheduledThreadPool的方式"><a href="#newScheduledThreadPool的方式" class="headerlink" title="newScheduledThreadPool的方式"></a>newScheduledThreadPool的方式</h5><p>创建一个定长线程池，但是该线程池支持定时及周期性执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程个数为2的线程池</span></span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">       System.out.println(t + <span class="string">&quot;正在执行任务。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.schedule(run, <span class="number">3</span>, TimeUnit.SECONDS);<span class="comment">//延迟3秒执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码控制台输出如下，会延迟3秒执行，且执行任务只有2两个线程，控制了并发数，超出的线程会进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h5 id="newSingleThreadExecutor的方式"><a href="#newSingleThreadExecutor的方式" class="headerlink" title="newSingleThreadExecutor的方式"></a>newSingleThreadExecutor的方式</h5><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO，LIFO)执行。这个线程池只是只能存在一个线程，这个线程死后另外一个线程会补上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          System.out.println(t + <span class="string">&quot;正在执行任务。&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span>(index == <span class="number">5</span>) &#123; <span class="comment">//模拟线程死掉了</span></span><br><span class="line">            System.out.println(t + <span class="string">&quot;死掉了。&quot;</span>);</span><br><span class="line">            t.stop();<span class="comment">//调用destory方法会报错</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      threadPool.execute<span class="comment">//将任务指派为线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码在控制台输出如下，说明当线程Thread[pool-1-thread-1,5,main]死掉之后，该线程池会创建Thread[pool-1-thread-2,5,main]线程继续执行任务，线程池里只能有一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">1</span>,<span class="number">5</span>,main]死掉了。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br><span class="line">Thread[pool-<span class="number">1</span>-thread-<span class="number">2</span>,<span class="number">5</span>,main]正在执行任务。</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;newCachedThreadPool的方式&quot;&gt;&lt;a href=&quot;#newCachedThreadPool的方式&quot; class=&quot;headerlink&quot; title=&quot;newCachedThreadPool的方式&quot;&gt;&lt;/a&gt;newCachedTh</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="线程池" scheme="http://qtspace.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDK8-HashMap实现原理</title>
    <link href="http://qtspace.cn/2022/03/02/Jdk8-HashMap/"/>
    <id>http://qtspace.cn/2022/03/02/Jdk8-HashMap/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:21.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HashMap插入"><a href="#一、HashMap插入" class="headerlink" title="一、HashMap插入"></a>一、HashMap插入</h3><p>HashMap插入的流程主要包括：计算下标、何时扩容、何时链表转红黑树等，具体如下：</p><ol><li><p>首先对key进行hash值的扰动，获取一个新的hash值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(key == <span class="literal">null</span>) ? <span class="number">0</span> : h = key.hashCode() ^ (h &gt;&gt;&gt; <span class="number">16</span>)</span><br></pre></td></tr></table></figure></li><li><p>判断tab是否为null或者长度为0，如果是则进行扩容操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab == table) == <span class="literal">null</span> || (n = tab.length == <span class="number">0</span>))</span><br><span class="line">n = (tab = resize()).length;</span><br></pre></td></tr></table></figure></li><li><p>根据hash值计算下标，如果tab对应下标没有存放数据，则直接插入该数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((p = tab[i = (n-<span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果键值对键的值以及节点 hash 等于链表中的第一个键值对节点时，则将e指向该键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp; </span><br><span class="line">((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br></pre></td></tr></table></figure></li><li><p>如果桶中引用类型是树节点，则向树插入该节点，否则向链表中插入该节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">    e = ((TreeNode&lt;K, V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br></pre></td></tr></table></figure></li><li><p>如果链表插入节点的时候，链表长度大于等于8，则需要将链表转换为红黑树。treeifyBin是一个链表转树的方法，但不是所有链表长度大于等于8时都会转成树，还需要对当前数组桶长度是否小于64做判断，如果小于则需要扩容，大于64则进行链表转树操作。因为当数组长度小于64时，使用链表比使用红黑树查询速度更快。数组长度较小时应该尽量避开红黑树，因为红黑树需要进行左旋、右旋、变色操作来保持平衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure></li><li><p>判断需要插入的键值对是否存在HashMap中，如果存在根据onlyIfAbsent(默认false)或者值为null，则更新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后元素处理完成之后，判断容量是否超过阙值，如果超过则进行扩容操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">resize();</span><br></pre></td></tr></table></figure></li></ol><p>JDK1.8 HashMap的put方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 判断数组桶tab是否为null或者长度为0，如果是则进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中不包含键值对节点引用, 则将新键值对节点的引用存入桶中</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K, V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果键值对键的值以及节点hash等于链表中的第一个键值对节点时, 则将e指向该键值对</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶中的引用类型为TreeNode, 则调用红黑树插入值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K, V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对链表进行遍历, 并统计链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 链表中不包含要插入的键值对节点时, 则将该节点接在链表的最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>)&#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于或等于树化阙值时, 则进行链表转红黑树操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前链表包含需要插入的键值对时, 终止遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash </span><br><span class="line">                    &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要插入的键值对是否存在HashMap中,</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            =<span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 键值对数量超过阙值时, 则进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、HashMap扩容机制"><a href="#二、HashMap扩容机制" class="headerlink" title="二、HashMap扩容机制"></a>二、HashMap扩容机制</h3><ol><li>扩容时计算出新的newCap、newThr，这两个单词是Capacity、Threshold，分别代表容量、阙。</li><li>newCap用于创建新的数组桶new Node[new Cap]。</li><li>随着扩容后，原来那些因为hash碰撞，存放成链表和红黑树的元素，都需要进行拆分存放到新的位置中。</li></ol><h3 id="三、链表树化"><a href="#三、链表树化" class="headerlink" title="三、链表树化"></a>三、链表树化</h3><p>HashMap这种散列表的数据结构，最大的性能在于可以O(1)时间复杂度定位到元素，但是因为哈希碰撞不得已在一个下标里存放多组数据，在jdk1.8之前的设计只是采用链表的方式进行存放，时间复杂度为O(n)，链表越长性能越低。所以在jdk1.8把链表长度超过8个(包含8个)的链表转成自平衡的红黑树结构，以此让定位元素的时间复杂度为O(logn)提升查找效率。</p><p>链表树化源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treefyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="comment">// 数组容量大于64才进行链表树化</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头部、尾部</span></span><br><span class="line">        TreeNode&lt;K, V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将普通节点转换为树节点, 此时还不是红黑树</span></span><br><span class="line">            TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (t1 == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>((tab[index] == hd) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 转红黑树操作</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li>链表树化的条件有两个：链表长度大于等于8、桶容量大于64，否则只是扩容，不会树化。</li><li>链表树化的过程中是先由链表转成树节点，此时的树还不是平衡树。同时在树转换过程中会记录链表的顺序，tl.next &#x3D; p，这主要是方便后续树转链表和拆分更方便。</li><li>链表转换成树完成之后，再进行红黑树的转换。</li></ol><h3 id="四、红黑树转链"><a href="#四、红黑树转链" class="headerlink" title="四、红黑树转链"></a>四、红黑树转链</h3><p>因为在链表树化的时候，记录了原有链表的顺序，所以直接把TreeNode转换成Node即可，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K, V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历TreeNode</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// TreeNode转成Node</span></span><br><span class="line">        Node&lt;K, V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl = <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            t1.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K, V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K, V&gt; p, Node&lt;K, V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K, V&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、HashMap查找get方法"><a href="#五、HashMap查找get方法" class="headerlink" title="五、HashMap查找get方法"></a>五、HashMap查找get方法</h3><p>get方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span>&#123;</span><br><span class="line">    Node&lt;K, V&gt; e;</span><br><span class="line">    <span class="comment">// 通过扰动函数计算hash值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab; Node&lt;K, V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断桶数组不为空, 且通过hash值计算下标存在节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">       (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断是否为第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span>((e = first.next) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果为红黑树节点 调用红黑树查找方法</span></span><br><span class="line">            <span class="keyword">if</span>(first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt; first)).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表节点遍历查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash </span><br><span class="line">                   &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">                   <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li>通过扰动函数计算hash值。</li><li>通过hash值计算下标，并判断数组桶不为空且该下标存在节点。</li><li>判断存在的节点是否为第一个节点。</li><li>判断节点是红黑树节点还是链表节点，再进行节点获取。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、HashMap插入&quot;&gt;&lt;a href=&quot;#一、HashMap插入&quot; class=&quot;headerlink&quot; title=&quot;一、HashMap插入&quot;&gt;&lt;/a&gt;一、HashMap插入&lt;/h3&gt;&lt;p&gt;HashMap插入的流程主要包括：计算下标、何时扩容、何时链表转红黑</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="HashMap" scheme="http://qtspace.cn/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建个人博客(一)</title>
    <link href="http://qtspace.cn/2022/03/02/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://qtspace.cn/2022/03/02/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:27.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo?"></a>什么是Hexo?</h3><p><a href="https://hexo.io/zh-cn/docs/">Hexo</a> 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="安装Hexo前提"><a href="#安装Hexo前提" class="headerlink" title="安装Hexo前提"></a>安装Hexo前提</h3><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><p>成功安装好Git，Node.js之后可以使用下面命令行查看版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Git和Nodejs安装好后，就可以安装Hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）</p><p>输入以下命令安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成之后输入<code>hexo -v</code>查看一下版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。folder是自己建的文件夹，也可以建好文件夹然后右键git bash打开，输入<code>hexo init</code>、<code>npm install</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>初始化完成之后，指定文件夹的目录如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   #配置文件</span><br><span class="line">├── package.json  #应用程序的信息</span><br><span class="line">├── scaffolds     #生成文件的一些模版</span><br><span class="line">├── source        #存放写的文章</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes        #主题</span><br></pre></td></tr></table></figure><p>输入以下命令，生成静态文件和启动Hexo服务，在浏览器输入<code>localhost:4000</code>就可以看到你生成的博客了，可以<code>ctrl + c</code>停止服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>到这里Hexo已经全部安装完毕，如果要访问自己的博客就是一直启动Hexo服务，而且是在本地这肯定是不行，所以接下来我们要白嫖GitHub。</p><h3 id="创建GitHub个人仓库"><a href="#创建GitHub个人仓库" class="headerlink" title="创建GitHub个人仓库"></a>创建GitHub个人仓库</h3><p>首先，你先有一个Github账户，如果没有先注册，有了账号之后，创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。比如我创建的是<code>qingtian-space.github.io) </code>。</p><h3 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h3><p>回到 git bash中，这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>创建SSH，一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;240661198@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹<code>C:\Users\用户\.ssh</code>的<code>id_rsa</code>文件。</p><p>然后在GitHub的setting中(点击头像的setting)，找到SSH keys的设置选项，点击New SSH key 把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，输入下面命令查看是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="Hexo部署到GitHub"><a href="#Hexo部署到GitHub" class="headerlink" title="Hexo部署到GitHub"></a>Hexo部署到GitHub</h3><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为YourgithubName就是你的GitHub账户，我这里是<code>qingtian-space.github.io</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/qingtian-space/qingtian-space.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入以下命令，其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p><p>注意deploy时可能要你输入username和password。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>成功之后，可以再浏览器输入<code>http://qingtian-space.github.io</code>就可以看到自己的博客啦！</p><h3 id="设置个人域名"><a href="#设置个人域名" class="headerlink" title="设置个人域名"></a>设置个人域名</h3><p>现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。</p><p>注册一个阿里云账户,在阿里云上买一个域名，我买的是<code> qtspace.cn</code>，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。买好域名之后，添加解析其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。<strong>注意，解析线路选择默认</strong>。</p><p>登录GitHub，进入之前创建的仓库，点击settings，打开GitHub Pages 设置Custom domain，输入你的域名<code>qtspace.cn</code></p><p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。</p><p>设置完之后，最后再git bash输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p><p>这一篇就是Hexo+GitHub搭建个人博客，并设置个人域名，下一篇Hexo的基本配置，更换主题等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Hexo&quot;&gt;&lt;a href=&quot;#什么是Hexo&quot; class=&quot;headerlink&quot; title=&quot;什么是Hexo?&quot;&gt;&lt;/a&gt;什么是Hexo?&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/docs/&quot;&gt;Hexo&lt;/a&gt; 是</summary>
      
    
    
    
    <category term="Hexo" scheme="http://qtspace.cn/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://qtspace.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://qtspace.cn/2022/03/02/java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://qtspace.cn/2022/03/02/java%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:23.254Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">栗子</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与运算，两个位都为1时，结果为1，否则为0</td><td align="center">比如2 &amp; 3，2的二进制为10，3的二进制为11，与运算为10，转成十进制为2</td></tr><tr><td align="center">|</td><td align="center">或运算，两个位都为0时，结果为0，否则为1</td><td align="center">比如2 | 3，2的二进制为10，3的二进制为11，或运算为11，转成十进制为3</td></tr><tr><td align="center">^</td><td align="center">异或运算，两个位相同为0，不相同为1</td><td align="center">比如2 ^ 3，2的二进制为10，3的二进制为11，与或运算为01，转成十进制为1</td></tr><tr><td align="center">~</td><td align="center">取反运算，1变0，0变1</td><td align="center">比如~2 ，2的二进制为10，取反运算为01，转成十进制为1</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">按位右移运算，高位补0</td><td align="center">比如10&gt;&gt;2，10的二进制为1010，往右移2位高位补0为0010，转成十进制就为2</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">按位左移运算，低位补0</td><td align="center">比如10&lt;&lt;2，10的二进制为1010，往左移2位低位补0为101000，转成十进制为40</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">按位右移补0操作运算</td><td align="center">比如10&gt;&gt;&gt;2，10的二进制为1010，右移2位补0为0010，转成十进制为2</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;符号&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;描述&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;栗子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;</summary>
      
    
    
    
    <category term="位运算" scheme="http://qtspace.cn/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
    <category term="位运算" scheme="http://qtspace.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>windows安装kafka</title>
    <link href="http://qtspace.cn/2022/03/02/windows%E5%AE%89%E8%A3%85kafka/"/>
    <id>http://qtspace.cn/2022/03/02/windows%E5%AE%89%E8%A3%85kafka/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:19.290Z</updated>
    
    <content type="html"><![CDATA[<h5 id="1-先下载并启动zookeeper（启动窗口不能关闭）"><a href="#1-先下载并启动zookeeper（启动窗口不能关闭）" class="headerlink" title="1. 先下载并启动zookeeper（启动窗口不能关闭）"></a>1. 先下载并启动zookeeper（启动窗口不能关闭）</h5><h5 id="2-下载kafka：http-kafka-apache-org-downloads-html-（注意下载binary版本的，不要下载3-0版本的，3-0windows下有问题，启动报错，换成2-8就没问题）"><a href="#2-下载kafka：http-kafka-apache-org-downloads-html-（注意下载binary版本的，不要下载3-0版本的，3-0windows下有问题，启动报错，换成2-8就没问题）" class="headerlink" title="2. 下载kafka：http://kafka.apache.org/downloads.html （注意下载binary版本的，不要下载3.0版本的，3.0windows下有问题，启动报错，换成2.8就没问题）"></a>2. 下载kafka：<a href="http://kafka.apache.org/downloads.html">http://kafka.apache.org/downloads.html</a> （注意下载binary版本的，不要下载3.0版本的，3.0windows下有问题，启动报错，换成2.8就没问题）</h5><h5 id="3-解压到相应文件夹，进入config目录下，找到server-properties文件，并作以下修改："><a href="#3-解压到相应文件夹，进入config目录下，找到server-properties文件，并作以下修改：" class="headerlink" title="3. 解压到相应文件夹，进入config目录下，找到server.properties文件，并作以下修改："></a>3. 解压到相应文件夹，进入config目录下，找到server.properties文件，并作以下修改：</h5><p>　　找到并编辑 log.dirs&#x3D;D:\soft\kafka\kafka_2.13-2.8.0\kafka-logs  (kafka的解压目录，kafka-logs文件夹不用自己新建)</p><p>　　找到并编辑zookeeper.connect&#x3D;localhost:2181 （一般默认就是localhost:2181）</p><h5 id="4-打开命令命令进到kafka目录，输入下面命令启动kakfa（窗口不能关闭）"><a href="#4-打开命令命令进到kafka目录，输入下面命令启动kakfa（窗口不能关闭）" class="headerlink" title="4. 打开命令命令进到kafka目录，输入下面命令启动kakfa（窗口不能关闭）"></a>4. 打开命令命令进到kafka目录，输入下面命令启动kakfa（窗口不能关闭）</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-server-start.bat .\config\server.properties</span><br></pre></td></tr></table></figure><h5 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h5><h6 id="1）打开一个新的命令窗口，输入下面命令创建主题，提示Created-topic-主题名则表示成功"><a href="#1）打开一个新的命令窗口，输入下面命令创建主题，提示Created-topic-主题名则表示成功" class="headerlink" title="1）打开一个新的命令窗口，输入下面命令创建主题，提示Created topic 主题名则表示成功"></a>1）打开一个新的命令窗口，输入下面命令创建主题，提示Created topic 主题名则表示成功</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h6 id="2）查看已经创建的主题命令："><a href="#2）查看已经创建的主题命令：" class="headerlink" title="2）查看已经创建的主题命令："></a>2）查看已经创建的主题命令：</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-topics.bat --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><h6 id="3）打开一个新的命令窗口，创建生产者，输入以下命令，创建完毕之后可以输入-hello-world消息"><a href="#3）打开一个新的命令窗口，创建生产者，输入以下命令，创建完毕之后可以输入-hello-world消息" class="headerlink" title="3）打开一个新的命令窗口，创建生产者，输入以下命令，创建完毕之后可以输入 hello world消息"></a>3）打开一个新的命令窗口，创建生产者，输入以下命令，创建完毕之后可以输入 hello world消息</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-producer.bat --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h6 id="4）打开一个新的命令窗口，创建消费者，输入以下命令，可以看到消费了hello-world消息"><a href="#4）打开一个新的命令窗口，创建消费者，输入以下命令，可以看到消费了hello-world消息" class="headerlink" title="4）打开一个新的命令窗口，创建消费者，输入以下命令，可以看到消费了hello world消息"></a>4）打开一个新的命令窗口，创建消费者，输入以下命令，可以看到消费了hello world消息</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bin\windows\kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;1-先下载并启动zookeeper（启动窗口不能关闭）&quot;&gt;&lt;a href=&quot;#1-先下载并启动zookeeper（启动窗口不能关闭）&quot; class=&quot;headerlink&quot; title=&quot;1. 先下载并启动zookeeper（启动窗口不能关闭）&quot;&gt;&lt;/a&gt;1. 先</summary>
      
    
    
    
    <category term="Kafka" scheme="http://qtspace.cn/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://qtspace.cn/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>双端队列ArrayDeque、LinkedList</title>
    <link href="http://qtspace.cn/2022/03/02/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97ArrayDeque%E3%80%81LinkedList/"/>
    <id>http://qtspace.cn/2022/03/02/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97ArrayDeque%E3%80%81LinkedList/</id>
    <published>2022-03-01T16:00:00.000Z</published>
    <updated>2022-03-05T14:15:40.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>Stack栈：先进后出</p><p>Queue队列：先进先出</p><p>在Java里有一个Stack类，但是这个类已经不推荐使用了，而Queue是一个接口，当我们需要使用栈和队列时，推荐使用更加高效的ArrayDeque该类实现Deque接口，次选使用LinkedList。</p><h3 id="二、总体介绍"><a href="#二、总体介绍" class="headerlink" title="二、总体介绍"></a>二、总体介绍</h3><p>要讲栈和队列，首先要讲Deque接口。Deque的含义是”double ended queue”，即双端队列，既可以当栈使用，也可以当队列使用。</p><p>下表列出Deque和Queue相对应的接口：</p><table><thead><tr><th>Queue 方法</th><th>Deque 方法</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下标列出Deque和Stack对应的接口：</p><table><thead><tr><th>Stack 方法</th><th>Deque 方法</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上表Deque总共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（<code>false</code>或<code>null</code>）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然Deque的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><h3 id="三、ArrayDeque"><a href="#三、ArrayDeque" class="headerlink" title="三、ArrayDeque"></a>三、ArrayDeque</h3><p>ArrayDeque是基于数组实现的可动态扩容的双端队列，定义和<strong>head、tail头尾</strong>两个下标值，默认为0。为了满足可以同时在数组两端插入或者删除元素，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可以被看作是起点或者终点。ArrayDeque是非线程安全的，另外不允许插入null元素。</p><p>当ArrayDeque作为<strong>队列</strong>使用时，核心方法是<strong>addLast()<strong>，该方法的作用是在ArrayDeque的尾部插入元素，也就是在</strong>tail</strong>的位置插入元素，tail总是指向下一个可以插入元素的空位，所以在源码中只需<strong>elements[tali] &#x3D; e;</strong> 插入完成之后再检查空间是否需要扩容，如果需要扩容则调用**doubleCapacity()**进行扩容，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">// 不允许插入null值</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 尾部赋值</span></span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="comment">// 因为数组长度是2^n的倍数,所以长度-1就是一个全是1的二进制, 可以用于与运算得出下标</span></span><br><span class="line">    <span class="comment">// 计算下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> ((tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法：两倍扩容，通过数组copy数据位移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">assert</span> <span class="variable">head</span> <span class="operator">=</span>= tail;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">        elements = a;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当Deque作为<strong>栈</strong>使用时，核心方法为<strong>addFirst()<strong>，也就是在ArrayDeque首段插入元素，在数组空间没有越界的情况下</strong>elements[–elements.length] &#x3D; e</strong> 即可。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许插入null值</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 赋值并计算下标是否越界</span></span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、LinkedList"><a href="#四、LinkedList" class="headerlink" title="四、LinkedList"></a>四、LinkedList</h3><p>LinkedList是由双向链表实现的双端队列，定义了<strong>first、last</strong>首尾两个节点用于连接链表，核心方法同样是**addFirst()<strong>和</strong>addLast()**。</p><p>LinkedList作为队列使用，addLast()源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">linkLast</span><span class="params">(E e)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 创建要插入的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(l, e <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 要插入的节点赋成最后一个节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 如果尾节点为null(第一次插入的时候为null)</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 要插入的节点为节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 当前尾节点的下一节点链上要插入的节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList作为栈使用，addFirst()源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前首节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">     <span class="comment">// 创建要插入的节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>(l, e <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 要插入的节点赋成首节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果首节点为null(第一次插入的时候为null)</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 要插入的节点为尾节点</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 当前首节点的上一节点链上要插入的节点</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;Stack栈：先进后出&lt;/p&gt;
&lt;p&gt;Queue队列：先进先出&lt;/p&gt;
&lt;p&gt;在Java里有一个Stack类，但是这个类已经</summary>
      
    
    
    
    <category term="Java" scheme="http://qtspace.cn/categories/Java/"/>
    
    
    <category term="LinkedList" scheme="http://qtspace.cn/tags/LinkedList/"/>
    
    <category term="ArrayDeque" scheme="http://qtspace.cn/tags/ArrayDeque/"/>
    
  </entry>
  
</feed>
