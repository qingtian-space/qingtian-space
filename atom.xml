<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晴天的空间站</title>
  
  
  <link href="https://qtspace.cn/atom.xml" rel="self"/>
  
  <link href="https://qtspace.cn/"/>
  <updated>2022-05-03T09:58:51.584Z</updated>
  <id>https://qtspace.cn/</id>
  
  <author>
    <name>晴天</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis三种常用的缓存读写策略</title>
    <link href="https://qtspace.cn/2022/04/23/redis-used-cache-read-write-strategies/"/>
    <id>https://qtspace.cn/2022/04/23/redis-used-cache-read-write-strategies/</id>
    <published>2022-04-22T16:00:00.000Z</published>
    <updated>2022-05-03T09:58:51.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、Redis三种常用的缓存读写策略"><a href="#一、Redis三种常用的缓存读写策略" class="headerlink" title="一、Redis三种常用的缓存读写策略"></a>一、Redis三种常用的缓存读写策略</h3><p>Redis有三种读写策略分别是：<strong>旁路缓存模式策略、读写穿透策略、异步缓存写入策略。</strong></p><p><strong>这三种缓存读写策略各有优势，不存在最佳，需要我们根据实际的业务场景选择最合适的。</strong></p><h3 id="二、旁路缓存模式（Cache-Aside-Pattern）"><a href="#二、旁路缓存模式（Cache-Aside-Pattern）" class="headerlink" title="二、旁路缓存模式（Cache Aside Pattern）"></a>二、旁路缓存模式（Cache Aside Pattern）</h3><p>旁路缓存模式是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</p><p>旁路缓存模式中服务端需要同时维护<code>DB</code>和<code>Cache</code>，并且是以<code>DB</code>的结果为准。</p><h4 id="读写步骤"><a href="#读写步骤" class="headerlink" title="读写步骤"></a>读写步骤</h4><h5 id="写："><a href="#写：" class="headerlink" title="写："></a>写：</h5><ul><li>先更新<code>DB</code>。</li><li>然后直接删除<code>cache</code>。</li></ul><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/91.jpg"></p><h5 id="读："><a href="#读：" class="headerlink" title="读："></a>读：</h5><ul><li>从<code>cache</code>中读取数据，读取到就直接返回。</li><li><code>cache</code>中读取不到的话，就从<code>DB</code>读取返回。</li><li>再把数据写到<code>cache</code>中。</li></ul><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/92.jpg"></p><h4 id="自我思考"><a href="#自我思考" class="headerlink" title="自我思考"></a>自我思考</h4><p>思考这样子的一个问题：“<strong>如果在写数据的过程中，可以先删除cache，再更新DB吗？</strong>”</p><p><strong>答案：</strong>答案肯定是不行的，因为这样子可能造成<strong>数据库和缓存数据不一致</strong>的问题，比如这个时候有一个数据在DB和缓存都为100，请求1需要将这个数据更新写成200，如果先删除换出再更新数据库的话，在请求1已经删除缓存但是数据库还没写完的时候，有一个请求2读取数据，首先去缓存读取，发现缓存被删除了，然后去数据库读取得到100（这个时候请求1还没写完）再写入缓存，这个时候请求1写完了，这个时候数据库里数据为200，缓存里为100，不一致。</p><p>可以简单描述为：</p><blockquote><p>请求1先把cache中的数据删除 -&gt; 请求2从DB中读取数据 -&gt; 请求1再把DB中的数据更新</p></blockquote><p>紧接着思考：“在写数据的过程中，<strong>如果先写BD，再删除cache就不会造成数据不一致了吗？</strong>”</p><p><strong>答案：</strong>理论上来说还是会出现数据不一致的问题，不过概率很小，因为缓存的写入速度是比数据库写入速度快很多。</p><p>比如请求1先读数据A，请求2随后写数据A，并且数据A不在缓存中存在的话就会去数据库读取，读取完请求2再更新完并删除缓存，然后请求1把数据A写入缓存，这个时候数据库和缓存就不一致了。</p><p>这个过程可以简单的描述为：</p><blockquote><p>请求1从DB读取数据A -&gt; 请求2写更新数据A到数据库再删除cache中的A数据 -&gt; 请求1将数据A写入缓存</p></blockquote><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p><strong>首次请求的数据一定不在cache的问题</strong></p><p>解决办法：可以将热点数据提前写入<code>cache</code>中。</p></li><li><p>写操作比较频繁的话导致cache中的数据会被频繁的删除，这样会影响缓存命中率。</p><p>解决办法：</p><ul><li>数据库和缓存强一直场景：更新<code>DB</code>的时候同样更新<code>cache</code>，不过需要加一个锁&#x2F;分布式锁来保证更新<code>cache</code>的时候不存在线程安全问题。</li><li>可以短暂的允许数据库和缓存数据不一致的场景：更新<code>DB</code>的时候同样更新<code>cache</code>，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul></li></ol><h3 id="三、读写穿透（Read-x2F-Write-Through-Pattern）"><a href="#三、读写穿透（Read-x2F-Write-Through-Pattern）" class="headerlink" title="三、读写穿透（Read&#x2F;Write Through Pattern）"></a>三、读写穿透（Read&#x2F;Write Through Pattern）</h3><p>读写穿透中服务端把<code>cache</code>视为主要数据存储，从中读取数据并将数据写入其中。<code>cache</code>服务负责将此数据读取和写入<code>DB</code>，从而减轻应用程序的职责。</p><h4 id="读写步骤-1"><a href="#读写步骤-1" class="headerlink" title="读写步骤"></a>读写步骤</h4><h5 id="写：-1"><a href="#写：-1" class="headerlink" title="写："></a>写：</h5><ul><li>先查<code>cache</code>，<code>cache</code>中不存在，直接更新<code>DB</code>。</li><li><code>cache</code>中存在，则先更新<code>cache</code>，然后<code>cache</code>服务自己更新<code>DB</code>（同时更新<code>DB</code>和<code>cache</code>）。</li></ul><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/93.jpg"></p><h5 id="读：-1"><a href="#读：-1" class="headerlink" title="读："></a>读：</h5><ul><li>先从<code>cache</code>中读取数据，读取到直接返回。</li><li>从<code>cache</code>中读取不到，则先从<code>DB</code>加载写入到<code>cache</code>后返回响应。</li></ul><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/94.jpg"></p><p>读写穿透实际是在旁路缓存之上进行了封装。在旁路缓存下，发生读请求的时候，如果<code>cache</code>中不存在对应的数据，是由客户端自己负责把数据写入<code>cache</code>，而读写穿透则是<code>cache</code>服务自己来写入缓存，这对客户端是透明的。</p><p>和旁路缓存一样，读写穿透也存在首次请求数据一定不在<code>cache</code>中的问题，对于热点数据可以提前写入缓存中。</p><h3 id="四、异步缓存写入（Write-Behind-Pattern）"><a href="#四、异步缓存写入（Write-Behind-Pattern）" class="headerlink" title="四、异步缓存写入（Write Behind Pattern）"></a>四、异步缓存写入（Write Behind Pattern）</h3><p>异步缓存写入和读写穿透很相似，两者都是由<code>cache</code>服务来负责<code>cache</code>和<code>DB</code>的读写。</p><p>两者最大的不同点就是：读写穿透是同步更新<code>DB</code>和<code>cache</code>，而异步缓存写入则是只更新<code>cache</code>，不直接更新<code>DB</code>，而是改为异步批量的方式更新<code>DB</code>。</p><p>很明显，这种方式对数据一致性带来了更大的挑战，比如<code>cache</code>数据可能还没异步更新<code>DB</code>，<code>cache</code>服务可能就挂了。</p><p>这种策略在我们平时开发过程中也非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、<code>MySQL</code>的<code>InnoDB Buffer Pool</code>机制都用到了这种策略。</p><p>异步缓存写入的写性能非常高，非常适合写数据经常变化又对数据一致性要求没那么高的场景下使用，比如浏览量、点赞量等。</p><blockquote><p>参考：<a href="https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html">https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、Redis三种常用的缓存读写策略&quot;&gt;&lt;a href=&quot;#一、Redis三种常用的缓存读写策略&quot; cla</summary>
      
    
    
    
    <category term="Redis" scheme="https://qtspace.cn/categories/Redis/"/>
    
    
    <category term="缓存读写策略" scheme="https://qtspace.cn/tags/%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎对MVCC的实现</title>
    <link href="https://qtspace.cn/2022/04/21/mysql-innodb-implementation-of-mvcc/"/>
    <id>https://qtspace.cn/2022/04/21/mysql-innodb-implementation-of-mvcc/</id>
    <published>2022-04-20T16:00:00.000Z</published>
    <updated>2022-05-02T07:21:39.670Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、一致性非锁定读"><a href="#一、一致性非锁定读" class="headerlink" title="一、一致性非锁定读"></a>一、一致性非锁定读</h3><p>对于<strong>一致性非锁定度</strong>的实现，通常的方式是加一个版本号或者时间戳，在更新数据的时候版本号+1或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号做对比，如果记录的版本号小于可见版本，则表示该记录可见。</p><p>在<code>InnoDB</code>存储引擎中，<strong>多版本控制</strong>就是对一致性非锁定读的实现。如果读取的行正在执行<code>delete</code>或者<code>update</code>操作，这时候读取操作不会去等待行释放锁，而是会去读取行的一个快照数据，对于这种读取历史数据的方式，叫做<strong>快照度。</strong></p><p>在<strong>可重复读</strong>和<strong>读取已提交</strong>两个隔离级别下，如果是执行普通的<code>select</code>语句（不包括<code>select ... lock in share mode, select ... for update</code>）则会使用<code>一致性非锁定读</code>。</p><p>并且在<strong>可重复读</strong>下 <code>MVCC</code> 实现了可重复读和防止部分幻读。</p><h3 id="二、锁定读（当前读）"><a href="#二、锁定读（当前读）" class="headerlink" title="二、锁定读（当前读）"></a>二、锁定读（当前读）</h3><p>如果执行的是下面语句，就是<strong>锁定读</strong>。</p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code>操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为<strong>当前读</strong>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加<code>S</code>锁，其他事务也可以加<code>S</code>锁，如果加<code>X</code>锁则会被阻塞。</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加<code>X</code>锁，且其他事务不能加任何锁。</li></ul><p>在一致性非锁定读下，即使读取的数据已经被其它事务加上了<code>X</code>锁，记录也是可以被读取的，读取的是快照数据。上面说了在<strong>可重复读隔离级别</strong>下<code>MVCC</code>防止了部分幻读，这个<strong>部分</strong>是指在<code>一致性锁定读</code>情况下，只能读取到第一次查询之前插入的数据（根据<code>Read View</code>判断数据可见性，<code>Read View</code>在第一次查询时生成）。但是如果是<strong>当前读</strong>，每次读取的都是最新数据，这个如果两次查询中间有其他事物插入数据就可以产生幻读。所以<code>InnoDB</code>在<strong>可重读</strong>时，如果当前执行的是当前读，则会对读取的记录<strong>使用<code>Next-Key Lock</code>，来防止其他事物在间隙间插入数据。</strong></p><h4 id="快照读和当前读栗子"><a href="#快照读和当前读栗子" class="headerlink" title="快照读和当前读栗子"></a>快照读和当前读栗子</h4><p>开启A和B两个会话。</p><p>首先在A会话中查询<code>user_id = 1</code>的<code>user_name</code>的记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_user <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>查询出来的结果是：<code>user_name = &#39;张三&#39;</code>。</p><p>然后再B会话对<code>user_id = 1</code>的<code>user_name</code>进行修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_user <span class="keyword">set</span> user_name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span> <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>然后再回到A会话继续做查询操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_user <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_user <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> user_name <span class="keyword">from</span> t_user <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p>三条数据查询出来的结果分别是：<code>user_name = &#39;张三&#39;</code>、<code>user_name = &#39;李四&#39;</code>、<code>user_name = &#39;李四&#39;</code></p><p>可以看出A会话中的第一条查询是快照读，读取到的当前事务开启时的数据记录，后面两个查询是当前读，读取到的是最新数据。</p><h3 id="三、InnoDB对MVCC的实现"><a href="#三、InnoDB对MVCC的实现" class="headerlink" title="三、InnoDB对MVCC的实现"></a>三、InnoDB对MVCC的实现</h3><p><code>MVCC（Multi-Version Concurrency Control）</code> 多版本并发控制。</p><p><code>MVCC</code>的实现主要依赖于：隐藏字段、<code>Read View</code>、<code>undo log</code>。在内部实现中通过数据行的<code>DB_TRX_ID</code>和<code>Read View</code>来判断数据的可见性，如不可见，则通过数据行的<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的历史版本。每个事务读取到的数据版本可能是不一致的，在同一个事务中，用户只能看到该事务创建<code>Read View</code>之前已经提交的修改或者该事务本身做的修改。</p><h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><p>在内部，<code>InnoDB</code>存储引擎为每行数据添加了三个隐藏字段，如下：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或者更新改行的事务id，当我们要开始一个事务时，会向<code>InnoDB</code>的事务系统申请一个事务id，这个事务id是<strong>一个严格递增且唯一的数字</strong>，当前行是被哪个事务修改的，就会把对应的事务id记录在当前行中。对于<code>delete</code>操作会在记录头<code>Record header</code>中的<code>delete_flag</code>字段将其标记为已删除。</li><li><code>DB_ROLL_PTR（7字节）</code>：回滚指针，这个回滚指针指向一个<code>undo log</code>日志的地址，可以通过<code>undo log</code>日志放这条记录恢复到历史版本，如果该行未被更新，则为空。</li><li><code>DB_ROW_ID（6字节）</code>：行id，用来唯一标识一行数据，如果没有设置主键且该表没有唯一非空索引时，会使用该id来当主键生成聚簇索引。</li></ul><h4 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadView</span> &#123;</span></span><br><span class="line">    private:</span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_id;   <span class="comment">/*大于等于这个id的事务均不可见*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_up_limit_id;    <span class="comment">/*小于这个id的事务均可见*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_creator_trx_id; <span class="comment">/*创建该Read View的事务id*/</span></span><br><span class="line">    <span class="type">trx_id_t</span> m_low_limit_no;   <span class="comment">/*事务Number, 小于该Number的Undo log均可以被purge*/</span></span><br><span class="line">    <span class="type">ids_t</span> m_ids;   <span class="comment">/*创建该Read View时的活跃事务列表*/</span></span><br><span class="line">        m_closed;   <span class="comment">/*标记Read View是否关闭*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Read View</code>主要是用来做可见性判断，里面保存了“当前对本事务不可见的其他活跃事务”。</p><p>主要有以下字段：</p><ul><li><code>m_low_limit_id</code>：目前出现过的最大事务id+1，即下一个将为分配的事务id，大于等于这个id的数据版本均不可见。</li><li><code>m_up_limit_id</code>：活跃事务列表<code>m_ids</code>中最小的事务id，如果<code>m_ids</code>为空，则为<code>m_low_limit_id</code>，小于这个id的数据版本均可见。</li><li><code>m_ids</code>：<code>Read View</code>创建时其他未提交活跃事务ID列表。创建<code>Read View</code>时，将当前未提交事务id记录下来，后续即使他们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code>不包括当前事务自己和已提交的事务。</li><li><code>m_creator_trx_id</code>：创建该<code>Read View</code>的事务id。</li></ul><h5 id="事务可见性示意图"><a href="#事务可见性示意图" class="headerlink" title="事务可见性示意图"></a><strong>事务可见性示意图</strong></h5><p><img src="https://qtspace.cn/contentimg/83.jpg"></p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p><code>undo log</code>主要有两个作用：</p><ul><li>将事务回滚时用于将数据恢复到修改前的样子。</li><li>另一个作用是<code>MVCC</code>，当读取记录时，若该条记录被其他事务占用或者当前版本对该事务不可见时，则可以通过<code>undo log</code>读取之前的版本数据，实现非锁定读。</li></ul><p><strong>在<code>InnoDB</code>存储引擎中<code>undo log</code>分为了两种：<code>insert undo log</code>和<code>update undo log</code>：</strong></p><ul><li><p><code>insert undo log</code>：在<code>insert </code>操作中产生的<code>undo log</code>。因为<code>insert</code>操作的记录只对事务本身可见，对其他事务不可见，所以<code>insert undo log</code>可以在事务提交后直接删除。不需要<code>purge</code>操作。</p><p><code>insert</code>时数据初始化状态：</p><p><img src="https://qtspace.cn/contentimg/84.jpg"></p></li><li><p><code>update undo log</code>：<code>update</code>或者<code>delete</code>操作中产生的<code>undo log</code>。该<code>undo log</code>可能需要提供<code>MVCC</code>机制，因此不能在事务提交后就进行删除。提交时放入<code>undo log</code>链表，等待<code>purge线程</code>进行最后的删除。</p><p>数据第一次被修改时：</p><p><img src="https://qtspace.cn/contentimg/85.jpg"></p><p>数据第二次被修改时：</p><p><img src="https://qtspace.cn/contentimg/86.jpg"></p></li></ul><p>不同事务或者相同事务对同一记录进行的修改，会使该行记录的<code>undo log</code>成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p><h4 id="数据可见性算法"><a href="#数据可见性算法" class="headerlink" title="数据可见性算法"></a>数据可见性算法</h4><p>在<code>InnoDB</code>存储引擎中，创建一个新事务后，执行每个<code>select</code>语句前都会创建一个快照（<code>Read View</code>），快照中<strong>保存了当前数据库所有正在处于活跃的事务（没有提交）id。</strong>说简单点就是保存了不应该被当前事务所能见的其他事务id（即m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code>会将该记录行的<code>DB_TRX_ID</code>与<code>Read View</code>中的当前事务事务id进行比较，判断是否满足可见条件。</p><p>具体的比较算法源码如下：<a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1">图源</a></p><p><img src="https://qtspace.cn/contentimg/87.jpg"></p><ol><li>如果记录<code>DB_TRX_ID &lt; m_up_limit_id</code>表示最新修改的该行事务在当前事务创建快照之前就已经提交了，所以改行记录的值对当前事务是可见的。</li><li>如果记录<code>DB_TRX_ID &gt;= m_low_limit_id</code>表示最新修改的行事务在当前事务创建快照之后再才修改该行，所以该记录行的值对当前事务是不可见的，跳到步骤5。</li><li><code>md_ids</code>为空，说明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对所有事务都可见。</li><li>如果<code>m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id </code>，表明最新修改行的事务在当前事务创建快照时可能处于“活跃状态”或者“已提交状态”。所以要对活跃事务列表<code>m_ids</code>进行查找（源码中用的二分查找法）：<ul><li>如果在活跃事务列表<code>m_ids</code>能找到<code>DB_TRX_ID</code>说明：①在当前事务创建快照时，改行记录的值被事务<code>DB_TRX_ID</code>的事务修改了，但没有提交；或者②在当前事务创建快照后，该记录行的值被ID为<code>DB_TRX_ID</code>的事务修改了，这些情况下这个记录行的值对当前事务是不可见的。跳到步骤5。</li><li>如果在活跃事务列表<code>m_ids</code>找不到，说明<code>DB_TRX_ID</code>的事务在修改该记录行的值在当前事务创建快照前已经提交了，所以该行记录的值对当前事务是可见的。</li></ul></li><li>在该行记录的<code>DB_ROLL_PTR</code>执行所指向的<code>undo log</code>取出快照数据，用快照数据的<code>DB_TRX_ID</code>跳到步骤1重新开始判断直到找到满足的快照版本或返回空。</li></ol><h3 id="四、读取已提交（RC）和可重复（RR）隔离级别下MVCC的差异。"><a href="#四、读取已提交（RC）和可重复（RR）隔离级别下MVCC的差异。" class="headerlink" title="四、读取已提交（RC）和可重复（RR）隔离级别下MVCC的差异。"></a>四、读取已提交（RC）和可重复（RR）隔离级别下MVCC的差异。</h3><p>在事务隔离级别<code>RC</code>和<code>RR</code>下，<code>InnoDB</code>存储引擎使用<code>MVCC</code>生成的<code>Read View</code>的时机不同。</p><ul><li>在<code>RC</code>隔离级别下<code>每次 select</code>查询前都生成一个<code>Read View</code>（<code>m_ids</code>列表）。</li><li>在<code>RR</code>隔离级别下只在事务开始后<code>第一次select</code>数据前生成一个<code>Read View</code>（<code>m_ids</code>列表）。</li></ul><h3 id="五、MVCC解决不可重复读问题"><a href="#五、MVCC解决不可重复读问题" class="headerlink" title="五、MVCC解决不可重复读问题"></a>五、MVCC解决不可重复读问题</h3><p>虽然<code>RC</code>和<code>RR</code>都通过<code>MVCC</code>来读取快照数据，但是由于<strong>生成<code>Read View</code>时机不同，</strong>从而在<code>RR</code>级别下实现可重复读。</p><p>举个例子：</p><table><thead><tr><th align="center"></th><th align="center">事务101</th><th align="center">事务102</th><th align="center">事务103</th></tr></thead><tbody><tr><td align="center">T1</td><td align="center">begin;</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">T2</td><td align="center"></td><td align="center">begin;</td><td align="center">begin;</td></tr><tr><td align="center">T3</td><td align="center">update user set name &#x3D; ‘张三’ where id &#x3D; 1;</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">T4</td><td align="center">update user set name &#x3D; ‘李四’ where id &#x3D; 1;</td><td align="center">…</td><td align="center">select * from user where id &#x3D; 1;</td></tr><tr><td align="center">T5</td><td align="center">commit;</td><td align="center">update uset set name &#x3D; ‘王五’ where id &#x3D; 1;</td><td align="center"></td></tr><tr><td align="center">T6</td><td align="center"></td><td align="center"></td><td align="center">select * from user where id &#x3D; 1;</td></tr><tr><td align="center">T7</td><td align="center"></td><td align="center">update uset set name &#x3D; ‘赵六’ where id &#x3D; 1;</td><td align="center"></td></tr><tr><td align="center">T8</td><td align="center"></td><td align="center">commit;</td><td align="center"></td></tr><tr><td align="center">T9</td><td align="center"></td><td align="center"></td><td align="center">select * from user where id &#x3D; 1;</td></tr><tr><td align="center">T10</td><td align="center"></td><td align="center"></td><td align="center">commit;</td></tr></tbody></table><h4 id="在RC下Read-View生成情况"><a href="#在RC下Read-View生成情况" class="headerlink" title="在RC下Read View生成情况"></a>在RC下Read View生成情况</h4><ul><li><p><code>假设时间线来到T4，那么此时数据行 id = 1的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/88.jpg"></p><p>由于<code>RC</code>级别下每次查询都会生成<code>Read View</code>，并且事务101、102没有提交，此时103事务生成的<code>Read View</code>中活跃事务为<code>m_ids</code>为[101,102]，<code>m_low_limit_id</code>为104，<code>m_up_limit_id</code>为101，<code>m_creator_id</code>为103。</p><ul><li>此时最新记录的<code>DB_TRX_ID</code>为101，所以<code>m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id</code>，所以要在<code>m_ids</code>列表中查找，发现<code>DB_TRX_ID</code>存在列表中，所以这个记录不可见。</li><li>根绝<code>DB_ROLL_PTR</code>找到<code>undo_log</code>中上一版本记录，上一条记录的<code>DB_TRX_ID</code>还是101不可见。</li><li>继续找上一条<code>DB_TRX_ID</code>为1，满足<code>1 &lt; m_up_limit_id</code>所以可见，所以事务103查询的数据为<code>name = 菜花</code>。</li></ul></li><li><p><code>假设时间线来到T6，数据的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/89.jpg"></p><p>因为在<code>RC</code>级别下，重新生成<code>Read View</code>，此时事务101已经提交，102事务未提交，所以此时<code>Read View</code>中活跃的事务<code>m_ids</code>为[102]，<code>m_low_limit_id</code>为104，<code>m_up_limit_id</code>为102，<code>m_creator_id</code>为103。</p><ul><li>此时最新记录的<code>DB_TRX_ID</code>为102，<code>m_up_limit_id &lt;= DB_TRX_ID &lt; m_up_limit_ud</code>，所以要在<code>m_ids</code>中查找，发现<code>DB_TRX_ID</code>存在列表中，那么这个记录不可见。</li><li>根据<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的上一版本记录，上一条记录的<code>DB_TRX_ID</code>为101，满足<code>101 &lt; t_up_limit_id</code>，所以记录可见，所以在<code>T6</code>时间点查询到的数据为<code>name = 李四 </code>，与时间<code>T4</code>查询到的结果不一致，发生了不可重复读。</li></ul></li><li><p><code>假设时间先来到T9，数据的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/90.jpg"></p><ul><li>因为在<code>RC</code>级别下，重新生成<code>Read View</code>，此时事务101、102都已经提交，所以<code>m_ids</code>为空，则<code>m_up_limit_id = m_low_limit_id = 104</code>，最新版本事务ID为102，满足<code>102 &lt; m_up_limit_id</code>，所以可见，查询结果为<code>name = 赵六</code>。</li></ul></li></ul><p><strong>总结：在RC隔离级别下，事务在每次查询的开始都会生成<code>Read View</code>，所以导致不可重复读。</strong></p><h4 id="在RR选Read-View生成情况"><a href="#在RR选Read-View生成情况" class="headerlink" title="在RR选Read View生成情况"></a>在RR选Read View生成情况</h4><p><strong>在可重复读级别下，只会在事务开始后的第一次读取数据是生成一个<code>Read View</code>（m_ids）。</strong></p><ol><li><p><code>假设时间线来到T4，那么此时数据行 id = 1的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/88.jpg"></p><p>在执行当前<code>select</code>语句时生成一个<code>Read View</code>，事务101，102未提交，此时<code>m_ids</code>为[101,102]，<code>m_low_limit_id</code>为104，<code>m_up_limit_id</code>为101，<code>m_creator_trx_id</code>为103</p><p>此时和RC级别下一样：</p><ul><li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;&#x3D; 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li><li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li><li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code>。</li></ul></li><li><p><code>假设时间线来到T6，那么此时数据行 id = 1的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/89.jpg"></p><p>因为在<code>RR</code>级别下只会生成一次<code>Read View</code>，所以此时<code>m_ids</code>还是为[101,102]，<code>m_low_limit_id</code>为104，<code>m_up_limit_id</code>为101，<code>m_creator_trx_id</code>为103</p><ul><li>最新记录<code>DB_TRX_ID</code>为102，满足<code>m_up_limit_id &lt;= 102 &lt; m_low_limit_id</code>，且在<code>m_ids</code>中存在102，所以这个记录不可见。</li><li>根据<code>BD_ROLL_PTR</code>找到<code>undo log</code>中的上一版本，上一条记录的<code>DB_TRX_ID</code>为101，和上面一样，不可见。</li><li>继续根据<code>DB_ROLL_PTR</code>找到<code>undo log</code>的中上一版本记录，上一条记录的<code>DB_TRX_ID</code>还是101，还是不可见。</li><li>继续找上一条<code>DB_TRX_UD</code>为1，满足<code>1 &lt; m_up_limit_id</code>，可见，所以事务103查询到的数据为<code>name=菜花</code>，和<code>T4</code>查询出来的结果一样，避免了不可重复。</li></ul></li><li><p><code>假设时间线来到T9，那么此时数据行 id = 1的版本链为：</code></p><p><img src="https://qtspace.cn/contentimg/90.jpg"></p><p>此时情况和<code>T6</code>完全一样，由于已经生成了 <code>Read View</code>，此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code>。</p></li></ol><p><strong>总结：在<code>RR</code>级别下只会在事务开始后的第一次查询生成<code>Read View</code>，所以可以避免不可重复的现象。</strong></p><h3 id="六、MVCC-Next-key-Lock防止幻读"><a href="#六、MVCC-Next-key-Lock防止幻读" class="headerlink" title="六、MVCC+Next-key Lock防止幻读"></a>六、MVCC+Next-key Lock防止幻读</h3><p><code>InnoDB</code>存储引擎在RR级别下通过<code>MVCC</code>和<code>Next-key Lock</code>来解决幻读问题：</p><ol><li><p><strong>执行普通<code>select</code>，此时会以<code>MVCC</code>快照读的方式读取数据</strong></p><p>在快照读的情况下，<code>RR</code>隔离级别只会在事务开始后的第一次查询生成<code>Read View</code>，并使用至事务提交。所以在生成<code>Read View</code>之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的“幻读”。</p></li><li><p><strong>执行<code>select for update/lock int share mode、insert、update、delete</code>等当前读</strong>、</p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读。<code>InnoDB</code>使用<code>Next-key lock</code>来防止这种情况，在执行当前读时，会锁定读取到的记录，同时也会锁定它们的间隙，防止其它事务在查询范围内插入数据，只要我不让你插入，就不会发生幻读。</p></li></ol><blockquote><p>参考：<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、一致性非锁定读&quot;&gt;&lt;a href=&quot;#一、一致性非锁定读&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="MySQL" scheme="https://qtspace.cn/categories/MySQL/"/>
    
    
    <category term="MVCC" scheme="https://qtspace.cn/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务隔离级别详解</title>
    <link href="https://qtspace.cn/2022/04/20/mysql-transaction-isolation-level/"/>
    <id>https://qtspace.cn/2022/04/20/mysql-transaction-isolation-level/</id>
    <published>2022-04-19T16:00:00.000Z</published>
    <updated>2022-04-28T12:42:39.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、什么是事务？"><a href="#一、什么是事务？" class="headerlink" title="一、什么是事务？"></a>一、什么是事务？</h3><p>事务是逻辑上的一组操作，要么全执行，要么全不执行。</p><p>事务最经典栗子也经常被拿出来的栗子就是银行转账了。比如小明要给小红转账1000元，这个转账会涉及到两个关键操作：将小明的余额减1000元，将小红的余额减1000元。万一这两个操作之间突然出现错误，导致小明余额减少但是小红余额没有增加，这种情况是肯定不允许的。事务就是保证这两个关键操作要么都成功，要么都不成功。</p><h3 id="二、事务的特性（ACID）"><a href="#二、事务的特性（ACID）" class="headerlink" title="二、事务的特性（ACID）"></a>二、事务的特性（ACID）</h3><p><img src="https://qtspace.cn/contentimg/77.jpg"></p><ul><li><strong>原子性：</strong>事务最小的执行单位，不允许分割。事务的原子性确保动作要么全部执行，要么全部不执行。</li><li><strong>一致性：</strong>执行事务的前后，数据保持一致。例如转账的业务中，无论事务是否成功，转账者和收款人的总额应该是不变的。</li><li><strong>隔离性：</strong>并发访问数据库时，一个用户的事务不应该被其他事务所影响，各并发事务之间数据库是独立的。</li><li><strong>持久性：</strong>一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有影响。</li></ul><h3 id="三、并发事务带来的问题"><a href="#三、并发事务带来的问题" class="headerlink" title="三、并发事务带来的问题"></a>三、并发事务带来的问题</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但是可能会带来以下的问题：</p><ul><li><strong>脏读（Dirty read）：</strong>当一个事务正在访问数据并且对其进行了修改，但是还没提交事务，这时另外一个事务也访问了这个数据，然后使用了这个数据，因为这个数据的修改还没提交到数据库，所以另外一个事务读取的数据就是“<strong>脏数据</strong>”，这种行为就是“<strong>脏读</strong>”，依据“<strong>脏数据</strong>”所做的操作可能是会出现问题的。</li><li><strong>修改丢失（Lost of modify）：</strong>是指一个事务读取一个数据时，另外一个数据也访问了该数据，那么在第一个事务修改了这个数据之后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，这种情况就被称为<strong>修改丢失</strong>。例如：事务1读取表中数据<code>A=20</code>，事务2也读取<code>A=20</code>，事务1修改<code>A=A-1</code>，事务2也修改<code>A=A-1</code>，最终结果都是<code>19</code>，但是事务1的修改记录丢失了。</li><li><strong>不可重复读（Unrepeatableread）：</strong>指在一个事务内多次读取同一数据，在这个事务还没结束时，另外一个事务也访问了这个数据并对这个数据进行了修改，那么就可能造成第一个事务两次读取的数据不一致，这种情况就被称为<strong>不可重复读。</strong></li><li><strong>幻读（Phantom read）：</strong>幻读与不可重复读类似，幻读是指一个事务读取了几行数据，这个事务还没结束，接着另外一个事务插入了一些数据，在随后的查询中，第一个事务读取到的数据就会比原本读取到的多，就好像发生了幻觉一样，所以称为<strong>幻读</strong>。</li></ul><h4 id="不可重复读和幻读区别："><a href="#不可重复读和幻读区别：" class="headerlink" title="不可重复读和幻读区别："></a>不可重复读和幻读区别：</h4><p>不可重复读的重点是修改，幻读的重点是新增或者删除。</p><p>栗子1（同样的条件，你读取过的数据，再次读取的时候不一样了）：事务1中的A先生读取自己的工资是1000的操作还没结束，事务2的B先生就修改了A先生的工资为2000，A先生再次读取自己工资的时候就变成2000了，这就是不可重复读。</p><p>栗子2（同样的条件，第1次和第2次读取出来的记录条数不一样）：假如某工资表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，总共查询到4条记录，这是事务2又查询了一条工资大于3000的记录，事务1再次读取查询到的记录就是5条了，这就是幻读。</p><h3 id="四、事务隔离级别"><a href="#四、事务隔离级别" class="headerlink" title="四、事务隔离级别"></a>四、事务隔离级别</h3><p><strong>SQL标准定义了四个隔离级别：</strong></p><ul><li><strong>读取未提交（READ-UNCOMMITTED）：</strong>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能造成脏读、不可重复读、幻读。</strong></li><li><strong>读取已提交（READ-COMMITTED）：</strong>允许读取并发事务已经提交的数据，<strong>可以避免脏读，但是可能造成不可重复、幻读。</strong></li><li><strong>可重复读（REPEATABLE-READ）：</strong>对同一字段多次读取的结果都是一致的，除非本身事务修改，<strong>可以避免脏读和不可重复读，但是可能造成幻读。</strong></li><li><strong>可串行化（SERIALIZABLE）：</strong>最高的隔离级别，完全服从ACID的隔离级别，所以的事务依次执行，<strong>可以避免脏读、不可重复读、幻读。</strong></li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">读取未提交</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">读取已提交</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">可串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><p><code>MySQL InnoDB</code>存储引擎默认的事务隔离级别是<strong>可重复读（REPEATABLE-READ）</strong>，可以通过命令<code>select @@tx_isolation;</code>语句来查看，<code>MySQL 8.0</code> 该语句改为<code>SELECT @@transaction_isolation;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure><p>**<code>MySQL InnoDB</code>存储引擎的可重复读并不能避免幻读，需要应用使用加锁读来保证，这加锁读使用到的机制就是<code>Next-Key Locks</code>**。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>读取已提交（READ-COMMITTED）</strong>，<code>InnoDB</code> 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong> 并不会有任何性能损失。</p><p><code>InnoDB</code>存储引擎在分布式事务的情况下一般会用到<strong>可串行化</strong>隔离级别。</p><p>🌈 拓展一下(以下内容摘自《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章)：</p><blockquote><p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对事务的原有ACID要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p></blockquote><h3 id="四、实际情况演示"><a href="#四、实际情况演示" class="headerlink" title="四、实际情况演示"></a>四、实际情况演示</h3><p><code>MySQL</code>命令行的默认配置中事务都是自动提交的，即执行<code>SQL</code>语句就会马上执行<code>COMMIT</code>操作。可以用命令<code>START TRANSACTION</code>开始一个事务。</p><p>我们可以通过下面命令设置事务隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE]</span><br></pre></td></tr></table></figure><p>我们再来看一下我们在实际操作中使用到的一些并发控制语句：</p><ul><li><code>START TRANSACTION | BEGIN</code> ：显示的开启一个事务。</li><li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li><li><code>ROLLBACK</code>：回滚到结束用户的事务，并撤销正在进行的所有未提交的修改。</li></ul><h4 id="（脏读）读取未提交"><a href="#（脏读）读取未提交" class="headerlink" title="（脏读）读取未提交"></a>（脏读）读取未提交</h4><p><img src="https://qtspace.cn/contentimg/78.jpg"></p><h4 id="（避免脏读）读取已提交"><a href="#（避免脏读）读取已提交" class="headerlink" title="（避免脏读）读取已提交"></a>（避免脏读）读取已提交</h4><p><img src="https://qtspace.cn/contentimg/79.jpg"></p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p><p><img src="https://qtspace.cn/contentimg/80.jpg"></p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p><img src="https://qtspace.cn/contentimg/81.jpg"></p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>演示幻读出现的情况</p><p><img src="https://qtspace.cn/contentimg/82.jpg"></p><p>sql 脚本 1 在第一次查询工资为 500 的记录时只有一条，sql 脚本 2 插入了一条工资为 500 的记录，提交之后；sql 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p><p>幻读和不可重复读有些相似之处 ，但是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>解决幻读的方法</p><ul><li>将事务隔离级别调整为 <code>SERIALIZABLE</code>。</li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-Key Locks</code>。</li></ul><blockquote><p>说明：<code>Next-Key Locks</code> 相当于 行锁 + 间隙锁</p></blockquote><blockquote><p>参考：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">https://javaguide.cn/database/mysql/transaction-isolation-level.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、什么是事务？&quot;&gt;&lt;a href=&quot;#一、什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是事务？&quot;&gt;&lt;/a&gt;一、什么是事务？&lt;/h3&gt;&lt;p&gt;事务是逻辑上的一组操作，要么全执行，要么全不执行。&lt;/p&gt;
&lt;p&gt;事务最经典栗子也经常被拿出</summary>
      
    
    
    
    <category term="MySQL" scheme="https://qtspace.cn/categories/MySQL/"/>
    
    
    <category term="事务隔离级别" scheme="https://qtspace.cn/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL三大日志(binlog,redo log,undo log)详解</title>
    <link href="https://qtspace.cn/2022/04/18/mysql-logs/"/>
    <id>https://qtspace.cn/2022/04/18/mysql-logs/</id>
    <published>2022-04-17T16:00:00.000Z</published>
    <updated>2022-04-25T13:11:45.542Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、MySQL日志"><a href="#一、MySQL日志" class="headerlink" title="一、MySQL日志"></a>一、MySQL日志</h3><p><code>MySQL</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中比较重要的就是二进制日志<code>binlog</code>（归档日志）、事务日志<code>redo log</code>（重做日志）和<code>undo log</code>（回滚日志）。</p><p>日志关系如下图：</p><p><img src="https://qtspace.cn/contentimg/55.jpg"></p><h3 id="二、redo-log"><a href="#二、redo-log" class="headerlink" title="二、redo log"></a>二、redo log</h3><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>有了崩溃恢复的能力。</p><p>当<code>MySQL</code>实例挂了或者宕机了，重启的时候<code>InnoDB</code>存储引擎会使用<code>rede log</code>日志恢复数据，保证事务的持久性和完整性。如下图：</p><p><img src="https://qtspace.cn/contentimg/56.jpg"></p><p><code>MySQL</code>中数据是以页为单数存储，当你查询一条记录时，硬盘会把一整页的数据加载出来，加载出来的数据叫做数据页，会放到<code>Buffer Pool</code>中。后续的查询都是先从<code>Buffer Pool</code>中找，没有找到再去硬盘加载其他的数据页直到命中，这样子可以减少磁盘<code>IO</code>的次数，提高性能。更新数据的时候也是一样，优先去<code>Buffer Pool</code>中找</p><p>，如果存在需要更新的数据就直接更新。然后会把“在某个数据页做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，在刷盘的时候会写入<code>redo log</code>日志文件里。</p><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/57.jpg"></p><blockquote><p>小贴士：每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成。</p></blockquote><h4 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h4><p>理想情况下，事务一提交就会进行刷盘操作，但是实际上是刷盘的时机是根据策略来决定的。</p><p><code>InnoDB</code>存储引擎为<code>redo log</code>的刷盘策略提供了<code>innodb_flush_log_at_trx_commit</code>参数，它支持三种策略：</p><ul><li>0：设置为0的时候，每次提交事务时不刷盘。</li><li>1：设置为1的时候，每次提交事务时刷盘。</li><li>2：设置为2的时候，每次提交事务时都只把<code>redo log buffer</code>写入<code>page cache</code>。</li></ul><p><code>innodb_flush_log_at_trx_commit</code>参数默认为1，当事务提交的时候会调用<code>fsync</code>对<code>redo log</code>进行刷盘，将<code>redo log buffer</code>写入<code>redo log</code>文件中。</p><p>另外，<code>Innodb</code>存储引擎有一个后台线程，每隔<code>1</code>秒，就会把会<code>redo log buffer</code>中的内容写入到文件系统缓存<code>page cache</code>，然后调用<code>fsync</code>刷盘。</p><p><img src="https://qtspace.cn/contentimg/58.jpg"></p><p>如上图，所以说一个没有提交事务的<code>redo log</code>记录，也会被刷盘。</p><p>下面是各种刷盘策略的流程图。</p><h5 id="innodb-flush-log-at-trx-commit-x3D-0"><a href="#innodb-flush-log-at-trx-commit-x3D-0" class="headerlink" title="innodb_flush_log_at_trx_commit &#x3D; 0"></a>innodb_flush_log_at_trx_commit &#x3D; 0</h5><p><img src="https://qtspace.cn/contentimg/59.jpg"></p><p>如上图，如果宕机了或者<code>MySQL</code>挂了可能造成<code>1</code>秒内的数据丢失。</p><h5 id="innodb-flush-log-at-trx-commit-x3D-1"><a href="#innodb-flush-log-at-trx-commit-x3D-1" class="headerlink" title="innodb_flush_log_at_trx_commit &#x3D; 1"></a>innodb_flush_log_at_trx_commit &#x3D; 1</h5><p>如上图，只要事务提交成功，<code>redo log</code>记录就一定在磁盘里，不会有任务数据丢失。</p><p>如果执行事务的时候<code>MySQL</code>挂了或者宕机了，这部分日志丢失了，但是因为事务没有提交，所以日志丢了也不会有损失。</p><p><img src="https://qtspace.cn/contentimg/60.jpg"></p><h5 id="innodb-flush-log-at-trx-commit-x3D-2"><a href="#innodb-flush-log-at-trx-commit-x3D-2" class="headerlink" title="innodb_flush_log_at_trx_commit &#x3D; 2"></a>innodb_flush_log_at_trx_commit &#x3D; 2</h5><p><img src="https://qtspace.cn/contentimg/61.jpg"></p><p>如上图，当事务提交成功时，<code>redo log buffer</code>日志会被写入<code>page cache</code>，然后后台线程会刷盘写入<code>redo log</code>，由于后台线程是<code>1</code>秒执行一次所以宕机或者<code>MySQL</code>挂了可能造成<code>1</code>秒内的数据丢失。</p><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p>硬盘上存储的<code>redo log</code>日志文件不止一个，而是一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo log</code>文件大小都是一样的。它采用的是环形数组形式，从头开始写，写到末尾回到头循环写，如下图所示：</p><p><img src="https://qtspace.cn/contentimg/62.jpg"></p><p>在<strong>日志文件组</strong>中有两个重要的属性，分别是<code>witre pos、checkpoint</code></p><ul><li><strong>wirte pos</strong>：是当前记录的位置，一边写一边后移。</li><li><strong>checkpoint</strong>：是当前要擦除的位置，也是后台推移。</li></ul><p>每次刷盘<code>redo log</code>记录到<strong>日志文件组</strong>中，<code>wirte log</code>位置就会后移更新。</p><p>每次<code>MySQL</code>加载<strong>日志文件组</strong>恢复数据时，会清空加载过的<code>redo log</code>，并把<code>checkpoint</code>后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p><p><img src="https://qtspace.cn/contentimg/63.jpg"></p><p>如果  <code>witre pos</code>追上<code>checkpoint</code>，表示<strong>日志文件组</strong>满了，这时候不能再写入新的<code>redo log</code>记录，<code>MySQL</code>得停下来，清空一些记录，把<code>checkpoint</code>推荐一下。</p><p><img src="https://qtspace.cn/contentimg/64.jpg"></p><h4 id="redo-log小结"><a href="#redo-log小结" class="headerlink" title="redo log小结"></a>redo log小结</h4><p><code>redo log</code>的作用和它的刷盘时机、存储形式。</p><p>可以思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，为什么还要用<code>redo log</code>刷盘？不都是刷盘吗？有什么区别？</strong></p><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页的几<code>byte</code>数据，没有必要把整页的数据刷盘。而且数据页刷盘都是随机写，因为一个数据页对应的位置可能是在硬盘文件的随机位置，所以性能很差。</p><p>如果是写<code>redo log</code>，一行记录就占了几十<code>byte</code>，只要包含了表空间号、数据页号、磁盘文件偏移量、修改值，再加上是顺序写，所以刷盘效率很高。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><h3 id="三、binlog"><a href="#三、binlog" class="headerlink" title="三、binlog"></a>三、binlog</h3><p><code>redo log</code>是物理日志，记录的是“在某个数据页做了什么修改”，属于<code>Innodb</code>存储引擎。</p><p>而<code>binlog</code>日志是逻辑日志，记录内容是语句的原始逻辑，属于<code>MySQL Server</code>层。所有的存储引擎只要发生了数据更新，都会产生<code>binlog</code>日志。</p><h4 id="binlog日志的作用"><a href="#binlog日志的作用" class="headerlink" title="binlog日志的作用"></a><code>binlog</code>日志的作用</h4><p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、住从</strong>都离不开<code>binlog</code>，需要依赖<code>binlog</code>来同步数据，保证数据一致性。</p><p><img src="https://qtspace.cn/contentimg/65.jpg"></p><p><code>binlog</code>会记录所有涉及更新数据的逻辑规则，并且按顺序写。</p><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><p><code>binlog</code>日志有三种格式，可以通过<code>binlog_format</code>参数设置，有以下三种：</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>设置<code>statement</code>记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time = now() where id = 1</code>，记录内容如下：<br><img src="https://qtspace.cn/contentimg/66.jpg"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题<code>update_time = now()</code>这里会获取到当前系统问题，直接执行会导致与原库数据不一致。</p><p>为了解决这种问题，我们需要将<code>binlog_format</code>设置成<code>row</code>，记录的不再是简单的<code>SQL</code>语句了，还包含了操作的具体数据，记录内容如下：</p><p><img src="https://qtspace.cn/contentimg/67.jpg"></p><p><code>row</code>格式记录的内容看不到详细信息，通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time = now()</code>变成了具体的时间，条件后面的<code>@1、@2</code>都是该行数据第1个~2个字段的原始值（假设这张表只有2个字段）。</p><p>设置成<code>row</code>带来的好处就是同步数据的一致性，通常情况都设置成<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式需要大量的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以又有了一种折中方案，设置为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否会引起数据不一致，如果是就用<code>row</code>格式，否则就用<code>statement</code>格式。</p><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p><code>binlog</code>的写入时机为事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候再把<code>binlog cache</code>写到<code>binlog</code>文件中（实际先会写入<code>page cache</code>，然后再由<code>fsync</code>写入<code>binlog</code>文件）。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为<code>binlog cache</code>。可以通过<code>binlog_cache_size</code>参数控制单线程<code>binlog_cache</code>大小，如果存储内容超过了这个参数，就要暂存到磁盘。</p><p><code>binlog</code>日志刷盘流程如下：</p><p><img src="https://qtspace.cn/contentimg/68.jpg"></p><ul><li><strong>上图的<code>write</code>，是指把日志写入到文件系统的<code>page cache</code>，并没有把数据持久化硬盘，所以速度比较快。</strong></li><li><strong>上图的<code> fsync</code>才是将数据库持久化到硬盘的操作。</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机可以由参数<code>sync_binlog</code>控制，可以配置成<code>0、1、N(N&gt;1)</code>。</p><ul><li>设置成0时：表示每次提交事务都只会<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</li><li>设置成1时：表示每次提交事务都会执行<code>fsync</code>，就和<code>redo log</code>日志刷盘流程一样。</li><li>设置成N时：表示每次提交事务都会<code>write</code>，但是积累<code>N</code>个事务后才<code>fsync</code>。</li></ul><p>设置为0时如下图：</p><p><img src="https://qtspace.cn/contentimg/69.jpg"></p><p>从上图可知，<code>sync_bilog = 0</code>设置成<code>0</code>，只把日志写入<code>page cache</code>虽然性能得到了提高，但是事务提交了<code>fsync</code>的时候宕机了，可能造成<code>binlog</code>日志的丢失。</p><p>设置为2时如下图：</p><p><img src="https://qtspace.cn/contentimg/70.jpg"></p><p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p><p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p><h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎有了崩溃恢复的能力。</p><p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构数据的一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不一样。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>日志只有在提交事务的时候才会写入，所以它们写入的时机不一样。</p><p><img src="https://qtspace.cn/contentimg/71.jpg"></p><blockquote><p>思考一个问题，如果redo log和binlog两份日志之间的逻辑不一样，会出现什么问题呢？MySQL是怎么解决这个问题的呢？</p></blockquote><p>比如有这样一个场景，假设有这么一条语句<code>update T set c = 1 where id = 2</code>（c原值为0），假如执行过程中写完<code>redo log</code>日志后，在写入<code>binlog</code>的时候发生了异常，会出现什么情况呢？</p><p>如下图：</p><p><img src="https://qtspace.cn/contentimg/72.jpg"></p><p>由于<code>binlog</code>日志没写完就异常，这个时候<code>binlog</code>日志里面没有对应的修改记录，之后使用<code>binlog</code>同步的数据的时候就会少这一次的更新，这一行数据<code>c = 0</code>，而原库使用<code>redo log</code>日志恢复，这一行数据<code>c = 1 </code>，最终数据不一致。如下图：</p><p><img src="https://qtspace.cn/contentimg/73.jpg"></p><p>为了解决两份日志之间的逻辑不一致的问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p><p>将<code>redo log</code>日志的写入拆分成两个步骤<code>prepare</code>和<code>commit</code>，如下图：<br><img src="https://qtspace.cn/contentimg/74.jpg"></p><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也没关系，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>日志处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志（根据事务id对应），所以就会回滚事务。</p><p><img src="https://qtspace.cn/contentimg/75.jpg"></p><p>再想一个场景，<code>redo lgo</code>设置<code>commit</code>阶段发生异常，事务会不会回滚呢？</p><p><img src="https://qtspace.cn/contentimg/76.jpg"></p><p>并不会回滚事务，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是存在对应的事务<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，所以不会回滚事务。</p><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>想要保证事务的原子性，就需要在发生异常时，对已经执行的操作进行回滚，在<code>MySQL</code>中恢复机制是通过<code>undo log</code>（回滚日志）实现的，所有事务进行的修改都会先被记录到这个回滚日志，然后再执行其他相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子。并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code>的实现依赖：**隐藏字段、<code>Read View</code>、<code>undo log</code>**。在底层实现中，<code>InnoDB</code>通过数据行的<code>DB_TRX_ID</code>和<code>Read View</code>来判断数据的可见性，如不可见，则通过数据行<code>DB_ROLL_PTR</code>找到<code>undo log</code>中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事物里，用户只能看到该事务创建<code>Read View</code>之前已经提交的修改和该事务本身做的修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>MySQL InnoDB</code>引擎使用<code>redo log</code>日志保证事务的持久性，使用<code>undo log</code>日志保证事务的原子性。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>离不开<code>binlog</code>，需要依赖<code>binlog</code>来同步数据，保证数据的一致性。</p><blockquote><p>参考：<a href="https://javaguide.cn/database/mysql/mysql-logs.html">https://javaguide.cn/database/mysql/mysql-logs.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、MySQL日志&quot;&gt;&lt;a href=&quot;#一、MySQL日志&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="MySQL" scheme="https://qtspace.cn/categories/MySQL/"/>
    
    
    <category term="binog" scheme="https://qtspace.cn/tags/binog/"/>
    
    <category term="redo log" scheme="https://qtspace.cn/tags/redo-log/"/>
    
    <category term="undo log" scheme="https://qtspace.cn/tags/undo-log/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引详解</title>
    <link href="https://qtspace.cn/2022/04/16/mysql-index-principle/"/>
    <id>https://qtspace.cn/2022/04/16/mysql-index-principle/</id>
    <published>2022-04-15T16:00:00.000Z</published>
    <updated>2022-04-18T08:16:08.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、什么是索引？索引有什么作用？"><a href="#一、什么是索引？索引有什么作用？" class="headerlink" title="一、什么是索引？索引有什么作用？"></a>一、什么是索引？索引有什么作用？</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构。常用的索引数据结构有：B树、B+树、Hash表。</strong></p><p>索引的作用就相当于目录的作用。比如：我们在查字典的时候如果没有目录，我们就只能一页一页去查找字，速度很慢，如果有目录，我们只需要查找字所在的页数，然后直接翻到那一页就可以了。</p><h4 id="索引的优点缺点"><a href="#索引的优点缺点" class="headerlink" title="索引的优点缺点"></a>索引的优点缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>索引可以让我们更快的检索出我们需要查找的数据，这也是创建索引的最主要的原因。</li><li>可以通过创建唯一索引，保证数据库行数据的唯一性。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>创建索引和维护索引需要耗费更多的时间。当对表中的数据进行增删改时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。</li><li>索引需要使用物理文件储存，会消耗一定的空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗？</strong></p><p>大多数情况下，索引查询都是比全表扫描的速度要快的，但是如果数据库的数据量不大，那么使用索引不一定能带来很大的提升。</p><h3 id="二、索引的底层数据结构"><a href="#二、索引的底层数据结构" class="headerlink" title="二、索引的底层数据结构"></a>二、索引的底层数据结构</h3><p>常用的索引底层数据结构有三种：B树、B+树、Hash表。</p><h4 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h4><p>哈希表就是键值对（<code>key-value</code>）的集合，通过键（<code>key</code>）可以快速查找到对应的值（<code>value</code>），查询速度接近<code>O(1)</code>。</p><p>哈希表通过<strong>哈希算法</strong>（也叫散列算法）计算<code>key</code>对应的<code>index</code>，然后通过<code>index</code>就可以得到对应的<code>value</code>。哈希算法有一个<strong>Hash冲突</strong>的问题，也就是多个<code>key</code>最后得到的<code>index</code>相同，通常使用链地址法结果Hash冲突的问题，就是将哈希冲突的数据存放在链表中。比如<code>JDK1.8</code>之前你的<code>HashMap</code>就是通过链地址法来解决哈希冲突，<code>JDK1.8</code>以后<code>HashMap</code>为了减少链表过长搜索时间过长引入了红黑树。</p><p><img src="https://qtspace.cn/contentimg/50.jpg"></p><p>既然哈希表这么快，<strong>为什么MySQL没有使用其作为索引的数据结构呢？</strong></p><p>主要有以下两个原因：</p><ol><li><strong>Hash冲突问题</strong>：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</li><li><strong>Hash表不支持顺序查询和范围查询：</strong>这是Hash表最大的缺点，也是MySQL不将Hash表作为索引数据结构最重要的原因。</li></ol><h4 id="B树-amp-B-树"><a href="#B树-amp-B-树" class="headerlink" title="B树&amp;B+树"></a>B树&amp;B+树</h4><p>B树也称B-树，全称为<strong>多路平衡查找树</strong>，B+树是B树的一种变体。</p><h5 id="B树-amp-B-树之间的差异"><a href="#B树-amp-B-树之间的差异" class="headerlink" title="B树&amp;B+树之间的差异"></a>B树&amp;B+树之间的差异</h5><ul><li>B树的所有节点既存放键<code>key</code>也存放数据<code>data</code>，而B+树只有叶子节点存放<code>key</code>和<code>data</code>，非叶子节点只存放<code>key</code>。</li><li>B树的叶子节点都是独立的，而B+树的叶子节点都有一条引用链指向它相近的节点。</li><li>B树的检索过程是相当于对范围内的每个节点的关键词做二分查找法，可能还没到叶子节点检索就结束了，而B+树的检索效率就很稳定，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h5 id="为什么B-树比B-树更适合作为索引？"><a href="#为什么B-树比B-树更适合作为索引？" class="headerlink" title="为什么B+ 树比B 树更适合作为索引？"></a>为什么B+ 树比B 树更适合作为索引？</h5><ol><li><p>B+树的磁盘读写代价更低</p><p>B+树的<code>data</code>都存放在叶子节点，非叶子节点只存放<code>key</code>，而B树的分支节点既存放<code>data</code>也存放<code>key</code>，这将导致B+树的层高会小于B树，所以B+树平均的IO次数会小于B树。</p></li><li><p>B+树的查询效率更稳定</p><p>B树查询可能在非叶子节点就结束了，而B+树因为<code>data</code>只存放在叶子节点，所以查询必须从根节点到叶子节点，所以查询效率更稳定。</p></li><li><p>B+树更便于遍历</p><p>由于B+树的<code>data</code>都存放在叶子节点，非叶子节点只存放<code>key</code>，所以只需遍历叶子节点即可，而B树非叶子夜店也存放<code>data</code>，要找到具体的数据需要进行二分查找。</p></li><li><p>B+树更擅长范围查询</p><p>B+树叶子节点存放<code>data</code>，且<code>data</code>是按顺序排列的双向链表，所以范围查询更快。而B树范围只能二分查找。</p></li><li><p>B+树占用内存空间小</p><p>B+树非叶子节点不存放<code>data</code>比较小，在内存有限的情况下，相比于B树索引可以加载更多B+ 树索引。</p></li></ol><h3 id="三、索引类型"><a href="#三、索引类型" class="headerlink" title="三、索引类型"></a>三、索引类型</h3><h4 id="主键索引（Primary-Key）"><a href="#主键索引（Primary-Key）" class="headerlink" title="主键索引（Primary Key）"></a>主键索引（Primary Key）</h4><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有且只有一个主键，并且主键不能为<code>null</code>，不能重复。</p><p>在<code>MySQL</code>的<code>InnoDB</code>的表中，如果表没有设置主键时，<code>InnoDB</code>会自动先检查表中是否有唯一索引（<code>Unique Key</code>）且不存在为<code>null</code>的字段，如果有则选择该字段为默认的主键，如果没有<code>InnoDB</code>会自动创建一个<code>6Byte</code>的自增主键。</p><p>主键索引如下图：</p><p><img src="https://qtspace.cn/contentimg/51.jpg"></p><h4 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h4><p>二级索引又称为辅助索引，二级索引的叶子节点存储的数据是主键。当使用二级索引的时候，先通过二级索引查询到主键，然后通过主键获取数据。</p><p>当我们创建所以的时候需要选择索引类型，比如：唯一索引、普通索引、前缀索引、全文索引，这些都是属于二级索引。</p><ul><li>唯一索引（<code>Unique Key</code>）：唯一索引也是一种约束。唯一索引的属性列不允许出现重复的数据，但是允许数据为<code>Null</code>，一张表允许创建多个唯一索引。使用唯一索引的目的大部分是为了保证该属性列的唯一性，而不是为了查询效率。</li><li>普通索引（Index）：普通索引的唯一作用就是为了快速查找数据，一张表允许创建多个普通索引，并允许数据重复和为<code>null</code>。</li><li>前缀索引（Prefix）：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小。</li><li>全文索引（Full Text）：全文索引主要是为了检索大文本数据中的关键字信息，是目前搜索引擎数据库使用的一种技术。</li></ul><p>二级索引如下图：</p><p><img src="https://qtspace.cn/contentimg/52.jpg"></p><h3 id="四、聚簇索引和非聚簇索引"><a href="#四、聚簇索引和非聚簇索引" class="headerlink" title="四、聚簇索引和非聚簇索引"></a>四、聚簇索引和非聚簇索引</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引是索引结构和数据存放在一起的索引，主键索引属于聚簇索引。</p><p>在<code>MySQL</code>中，<code>InnoDB</code>引擎的表的<code>.idb</code>文件就包含了该表的索引和数据，该表的索引<code>B+树</code>非叶子节点存放索引，叶子节点存放索引和索引对应的数据。</p><h5 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h5><ul><li>聚簇索引的查询速度非常快，因为<code>B+树</code>本就是一颗多平衡二叉树，叶子节点存放索引和数据，非叶子节点存放索引，且叶子节点也是有序的，定位到索引就可以得到数据。</li></ul><h5 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h5><ul><li><strong>依赖有序的数据：</strong>因为<code>B+树</code>是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整数类型还好，否则类似字符串或者<code>UUID</code>这种又长又难比较的数据，插入或者查找的速度肯定慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据修改时，那么对应的索引也需要修改，而且聚簇索引的叶子节点还存放这数据，修改代价很大，所以对于主键索引来说，主键一般是不可以被修改的。</li></ul><h4 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h4><p>上面说到的二级索引（辅助索引）都是非聚簇索引，非聚簇索引叶子节点只存储主键值。首先通过二级索引找到主键值，再通过主键索引找到数据。</p><h5 id="非聚簇索引的优点"><a href="#非聚簇索引的优点" class="headerlink" title="非聚簇索引的优点"></a>非聚簇索引的优点</h5><ul><li><strong>更新代价小</strong>：因为非聚簇索引的叶子节点值存放索引不存放数据，所以更新代价小。</li></ul><h5 id="非聚簇索引的缺点"><a href="#非聚簇索引的缺点" class="headerlink" title="非聚簇索引的缺点"></a>非聚簇索引的缺点</h5><ul><li>跟聚簇索引一样也是依赖有序的数据。</li><li><strong>可能会二次查询（回表）</strong>：这应该是非聚簇索引最大的缺点，当通过索引查询到对应的主键时，可能还需要根据主键再到表中查询。</li></ul><p>聚簇索引和非聚簇索引如下图：</p><p><img src="https://qtspace.cn/contentimg/53.jpg"></p><h5 id="非聚簇索引一定要回表查询吗（覆盖索引）？"><a href="#非聚簇索引一定要回表查询吗（覆盖索引）？" class="headerlink" title="非聚簇索引一定要回表查询吗（覆盖索引）？"></a>非聚簇索引一定要回表查询吗（覆盖索引）？</h5><blockquote><p>举个栗子，用户准备使用SQL查询用户名，而用户名字刚好创建了索引，查询SQL如下：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>那么这个索引的key本身就是name，查询对应的name直接返回就行了，无需返回表查询。</p></blockquote><p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h3 id="五、覆盖索引"><a href="#五、覆盖索引" class="headerlink" title="五、覆盖索引"></a>五、覆盖索引</h3><p>如果一个索引覆盖所有需要查询的字段，我们就称之为<strong>覆盖索引</strong>。在<code>InnoDB</code>存储引擎中，如果不是主键索引，叶子节点存储的是主键，最终要是要回表，这样就会比较慢，覆盖索引就是可以把索引直接返回不需要做回表操作。</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p>覆盖索引如下图：</p><p><img src="https://qtspace.cn/contentimg/54.jpg"></p><h3 id="六、联合索引"><a href="#六、联合索引" class="headerlink" title="六、联合索引"></a>六、联合索引</h3><p><strong>联合索引</strong>就是使用表中的多个字段创建的索引，也叫<strong>组合索引</strong>或者<strong>复合索引。</strong></p><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，在使用联合索引时，<code>MySQL</code>会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如<code>&gt;</code>、<code>&lt;</code>、<code>between</code>和<code>已%开头的like查询</code>等条件才会停止匹配。</p><p>所以我们在使用联合索引时，可以将区分度高的字段放在最左边。</p><h3 id="七、索引下推"><a href="#七、索引下推" class="headerlink" title="七、索引下推"></a>七、索引下推</h3><p>索引下推是<code>MySQL5.6</code>版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h3 id="八、创建索引的注意事项"><a href="#八、创建索引的注意事项" class="headerlink" title="八、创建索引的注意事项"></a>八、创建索引的注意事项</h3><ol><li><p><strong>选择合适的字段创建索引</strong>：</p><ul><li><strong>不为<code>NULL</code>字段</strong>：索引字段的数据应该尽量不为<code>NULL</code>，因为对于数据为<code>NULL</code>的字段，数据库比较难优化。如果字段频繁被查询，但又避免不了为<code>NULL</code>，建议使用<code>0,1,ture,false</code>这样语义较为清晰的短值或者短字符作为替代。</li><li><strong>被频繁查询的字段：</strong>我们创建索引的字段应该是查询操作非常频繁的字段。</li><li><strong>被作为条件查询的字段：</strong>被作为<code>WHERE</code>条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段：</strong>索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段：</strong>经常用于连接的字段可能是一些外键列，对于外键并一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul></li><li><p><strong>被频繁更新的字段应该慎重建议索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p></li><li><p><strong>尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗<code>B+树</code>。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，但修改索引时，耗费的时间也是很多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p></li><li><p><strong>注意避免冗余索引。</strong></p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如<code>name,city </code>和<code>name </code>这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p></li><li><p><strong>考虑在字符串类型的字段上使用前缀索引代替普通索引</strong>。</p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引代替普通索引。</p></li></ol><h3 id="九、使用索引的一些建议"><a href="#九、使用索引的一些建议" class="headerlink" title="九、使用索引的一些建议"></a>九、使用索引的一些建议</h3><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引。</li><li>避免 <code>where</code> 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 <code>InnoDB</code> 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗<code> MySQL 5.7</code> 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</li><li>在使用<code>limit offset</code> 查询缓慢时，可以借助索引来提高性能。</li></ul><h3 id="十、MySQL-如何为表字段添加索引"><a href="#十、MySQL-如何为表字段添加索引" class="headerlink" title="十、MySQL 如何为表字段添加索引"></a>十、MySQL 如何为表字段添加索引</h3><ol><li><p>添加 <code>PRIMARY KEY</code>（主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY ( `<span class="keyword">column</span>` );</span><br></pre></td></tr></table></figure></li><li><p>添加<code> UNIQUE</code>(唯一索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> ( `<span class="keyword">column</span>` );</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>INDEX</code>(普通索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> INDEX index_name ( `<span class="keyword">column</span>` );</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>FULLTEXT</code>(全文索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`);</span><br></pre></td></tr></table></figure></li><li><p>添加多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> FULLTEXT ( `<span class="keyword">column</span>`)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>参考：<a href="https://javaguide.cn/database/mysql/mysql-index.html">https://javaguide.cn/database/mysql/mysql-index.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、什么是索引？索引有什么作用？&quot;&gt;&lt;a href=&quot;#一、什么是索引？索引有什么作用？&quot; class=&quot;</summary>
      
    
    
    
    <category term="MySQL" scheme="https://qtspace.cn/categories/MySQL/"/>
    
    
    <category term="索引" scheme="https://qtspace.cn/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis手撸（二）创建简单的映射器代理工厂</title>
    <link href="https://qtspace.cn/2022/04/11/hand-mybatis-2/"/>
    <id>https://qtspace.cn/2022/04/11/hand-mybatis-2/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-04-11T13:49:13.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>我们在使用Mybatis的时候，都会有这样子的一个疑问：“<strong>为什么Mybatis只需定义一个接口，不用写实现类就能使用XML中或者注解中的SQL语句完成对数据库的CRUD呢？</strong>”。看过Mybatis源码之后才知道原来Mybatis使用了<code>Mapper</code>接口代理类，把所有的数据库操作都交给了代理类处理。</p><h3 id="二、Binding模块"><a href="#二、Binding模块" class="headerlink" title="二、Binding模块"></a>二、Binding模块</h3><p>这个<code>Mapper</code>接口代理类在<strong>Binding模块</strong>，核心类是<code>org.apache.ibatis.binding.MapperProxy</code>。<code>Binding</code>模块核心类如下：</p><ul><li><code>org.apach.ibatis.binding.MapperRegistry</code>：<code>Mapper</code>接口注册类，管理<code>Mapper</code>接口类型和其代理创建工作的映射，我们在开发中创建的<code>Mapper</code>接口类都会注册到这里进行管理。</li><li><code>org.apach.ibatis.binding.MapperProxyFactory</code>：<code>Mapper</code>接口代理类创建工厂类。</li><li><code>org.apach.ibatis.binding.MapperProxy</code>：<code>Mapper</code>接口代理类，封装了<code>SqlSession</code>相关操作，这个我们后续会学习到，是一个<code>SQL</code>执行。</li><li><code>org.apach.ibatis.binding.MapperMethod</code>：封装<code>Mapper</code>接口对应的方法和<code>SQL</code>执行信息，这个就是我们发开中创建的<code>Mapper</code>接口类每个方法对应<code>XML</code>配置的<code>SQL</code>语句。</li></ul><p>流程图如下：</p><p><img src="https://qtspace.cn/contentimg/47.jpg"></p><h3 id="三、设计"><a href="#三、设计" class="headerlink" title="三、设计"></a>三、设计</h3><p>通常如果能找到大家所做事情的共性内容，具有统一的流程处理，那么它就是可以被凝聚和提炼的，封装成通用的组件或者服务，被所有人共用减少重复的无用功。</p><p>参考我们最开使用的<code>JDBC</code>的方法，从获取数据库连接、查询、封装结果集、返回结果集，这些步骤都是一个固定的流程，那么这个流程我们是可以封装成一个通用组件或者服务的。</p><p>当我们来设计一个<code>ORM</code>框架的过程中，首先要考虑怎么把用户定义的数据库操作接口、<code>XML</code>配置的<code>SQL</code>语句、数据库三者联系起来。其实最合适的操作就是会用代理的方法进行处理，因为代理可以封装一个复杂的流程为接口对象的实现类，设计如下图：</p><p><img src="https://qtspace.cn/contentimg/48.jpg"></p><ul><li>首先提供一个<code>Mappper</code>接口代理类<code>MapperPoxy</code>，通过代理类包装对数据的操作，目前我们本章节会先提供一个简单的包装，模拟对数据库的调用。</li><li>然后为<code>Mapper</code>接口代理类提供一个简单工厂类<code>MapperProxyFactory</code>调用<code>instance</code>方法为每个<code>Mapper</code>接口成为代理类。</li></ul><h3 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h3><p>在实现之前，先对代理知识进行了一个学习，我们使用到的是动态代理模式，我们通过一个小<code>demo</code>对动态代理模式进行学习，还有另外两种代理模式：静态代理、<code>Cglib</code>代理。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理具有以下特点：</p><ul><li><p>动态代理对象不需要实现接口，只有目标对象需要实现接口。</p></li><li><p>实现基于接口的动态代理需要利用<code>JDK</code>中的<code>API</code>，在<code>JVM</code>内存中动态的构建<code>Proxy</code>，是运行期生效。</p></li><li><p>需要使用<code>java.lang.reflect.Proxy</code>和其<code>newProxyInstance()</code>方法，这个方法要传入三个参数，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>ClassLoader loader</code>：指定当前目标对象使用的类加载，获取加载器的方法是<code>getClassLoader()</code>。</li><li><code>interfaces</code>：目标对象实现接口的类型，使用泛型方式确认类型。</li><li><code>InvocationHandler h</code>：事件处理，执行目标方法对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。</li></ul></li></ul><p>我们通过具体的实现对动态代理进行一个操作，类结构图如下：</p><p><img src="https://qtspace.cn/contentimg/49.jpg"></p><p>代码实现：</p><p><code>Mapper</code>接口代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxy</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6424540398559729838L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; sqlSession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperProxy</span><span class="params">(Map&lt;String, String&gt; sqlSession, Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">//Object中的方法，直接执行</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;类&quot;</span> + mapperInterface.getName() + <span class="string">&quot;被代理了, 执行了方法：&quot;</span> + method.getName() +</span><br><span class="line">                    <span class="string">&quot; ,sqlSession为：&quot;</span> + sqlSession;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Mapper</code>接口代理类创建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mapper 接口类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperProxyFactory</span> <span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(Map&lt;String, String&gt; sqlSession)</span> &#123;</span><br><span class="line">        <span class="type">MapperProxy</span> <span class="variable">mapperProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperProxy</span>(sqlSession, mapperInterface);</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IUserDao</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    String <span class="title function_">queryUserName</span><span class="params">(String uId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        MapperProxyFactory&lt;IUserDao&gt; factory = <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;IUserDao&gt;(IUserDao.class);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; sqlSession = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        sqlSession.put(<span class="string">&quot;cn.bugstack.mybatis.test.dao.IUserDao.queryUserName&quot;</span>, <span class="string">&quot;模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户姓名&quot;</span>);</span><br><span class="line">        sqlSession.put(<span class="string">&quot;cn.bugstack.mybatis.test.dao.IUserDao.queryUserAge&quot;</span>, <span class="string">&quot;模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户年龄&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> factory.newInstance(sqlSession);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> userDao.queryUserName(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类qtspace.cn.binding.IUserDao被代理了, 执行了方法：queryUserName ,sqlSession为：&#123;cn.bugstack.mybatis.test.dao.IUserDao.queryUserAge=模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户年龄, cn.bugstack.mybatis.test.dao.IUserDao.queryUserName=模拟执行 Mapper.xml 中 SQL 语句的操作：查询用户姓名&#125;</span><br></pre></td></tr></table></figure><p>可以从上面的测试结果看出<code>IUserDao</code>被代理了，在执行<code>MapperProxy#invoker()</code>方法的时候代理执行<code>IUserDao#queryUserName()</code>方法。</p><p>需要注意的是：<strong>动态代理的方式中，所有的方法都会通过<code>invoker()</code>方法执行，但是动态代理有一个问题就是它只能代理实现了某个接口的实现类，并且代理类只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有，该方法是不能被代理的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;</summary>
      
    
    
    
    <category term="Mybatis" scheme="https://qtspace.cn/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="https://qtspace.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池实现原理详解</title>
    <link href="https://qtspace.cn/2022/04/08/threadpool-principle/"/>
    <id>https://qtspace.cn/2022/04/08/threadpool-principle/</id>
    <published>2022-04-07T16:00:00.000Z</published>
    <updated>2022-04-10T14:02:28.605Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、为什么要使用线程池？"><a href="#一、为什么要使用线程池？" class="headerlink" title="一、为什么要使用线程池？"></a>一、为什么要使用线程池？</h3><p><strong>线程池</strong>提供了一种限制和管理资源（线程、任务）的方式。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等待创建线程就能立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无线的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="二、ThreadPoolExecutor类分析"><a href="#二、ThreadPoolExecutor类分析" class="headerlink" title="二、ThreadPoolExecutor类分析"></a>二、ThreadPoolExecutor类分析</h3><p><code>Java</code>线程池主要由<code>Executor</code>框架实现，<code>Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code>Executor</code> 框架让并发编程变得更加简单。</p><p>线程池实现类<code>ThreadPoolExecutor</code>是<code>Executor</code>框架最核心的类，我们就从这个类的学习线程池的实现原理。</p><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 控制变量-存放状态和线程数 32位, 高3位存放状态, 低29位存放线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务队列， 必须是阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 工作线程集合，存放线程池中所有的(活跃的)工作线程，只有在持有全局锁mainLock的前提下才能访问此集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全局锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// awaitTermination方法使用的等待条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录峰值线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录完成成功执行的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程工厂, 用于创建新的线程实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拒绝执行处理器, 对应不同的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空闲线程等待任务的时间周期， 单位是纳秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否允许核心线程超时, 如果为true则keepAliveTime对核心线程也生效</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程池容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>参数最多的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">       maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">       maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">       keepAliveTime &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span>(workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以根据这个构造方法自定义线程数、线程池容量（最大线程数）、空闲线程等待任务周期、任务队列、线程工厂、拒绝策略。</p><p>在《阿里巴巴Java开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池创建，不允许在应用中自行显示创建线程，这是因为<strong>使用线程池创建线程可以减少在创建和销毁线程上所消耗的时间以及系统资源的开销。</strong></p><p>《阿里巴巴Java开发手册》中还强制不能使用<code>Executors</code>去创建线程池，而是通过上面的<code>ThreadPoolExecutor</code>的构造方式创建，这样的处理方式可以让写的同学更加明确线程池的运行规则，避免资源耗尽的风险。</p><p>下面简单分析一下每个参数的含义和作用：</p><ul><li><code>corePoolSize</code>：核心线程数量。</li><li><code>maximumPoolSize</code>：最大线程数量，也就是线程池的容量。</li><li><code>keepAliveTime</code>：线程空闲等待时间，也和工作线程的生命周期有关。</li><li><code>unit</code>：线程空闲时间的单位，最终会转为成纳秒。</li><li><code>workQueue</code>：等待队列或者叫任务队列。</li><li><code>ThreadFactory</code>：创建线程的工厂，默认使用<code>Executors.defaultThreadFactory()</code>作为线程池工厂实例。</li><li><code>handler</code>：线程池的执行执行处理器，更多的时候成为拒绝策略，拒绝策略执行的时机是当阻塞队列已满、没有空闲的线程（包含核心线程和非核心线程）并且继续提交任务。提供了4种拒绝策略实现：<ul><li><code>AbortPolicy</code>：直接拒绝策略，也就是不会执行任务，直接抛出<code>RjectedExecutionExcetion</code>错误，默认的拒绝策略。</li><li><code>DiscardPolicy</code>：抛弃策略，也就是直接忽略提交的任务。</li><li><code>DiscardOldestPolicy</code>：抛弃最老任务策略，也就是通过<code>poll()</code>方法取出任务队列头的任务抛弃，然后执行当前提交的任务。</li><li><code>CallerRunsPolicy</code>：调用者执行策略，也就是当前调用<code>Executor#execute()</code>的线程直接调用任务<code>Runnable#run()</code>，<strong>一般不希望任务丢失会选用这种策略，但从实际角度来看，原来的异步调用意图会退化成同步调用。</strong></li></ul></li></ul><h4 id="状态控制"><a href="#状态控制" class="headerlink" title="状态控制"></a>状态控制</h4><p>状态控制主要围绕原子整数成员变量<code>crl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ctl值获取运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ctl值获取工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过运行状态和工作线程数计算ctl的值，或运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS操作线程数增加1</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS操作线程数减少1</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程数直接减少1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    ctl.addAndGet(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分析一下线程池的状态变量，工作线程数量位的长度是<code>COUNT_BITS</code>，它的值是<code>Integer.SIZE - 3</code>，也就是正整数29：</p><blockquote><p>我们知道，整数包装类型Integer实例的大小是4byte，一共是32位，也就是一共有32位用于存放0和1。</p><p>在ThreadPoolExecutor实现中，使用32位的整数包装类型存放工作线程数和线程状态，其中低29位用于存放工作线程数，而高3位用于存放线程池状态，所以线程池的状态最多只能有2^3种，工作线程上限数量为2^29 - 1，超过5亿，这个数量在短时间内不用考虑会超限。</p></blockquote><p>接着看工作线程上线数量掩码<code>COUNT_MASK</code>，它的值是(<code>1 &lt; COUNT_BITS - 1</code>)，也就是1左移29位，再减去1，如果补全32位，它的位示图如下：</p><p><img src="https://qtspace.cn/contentimg/42.jpg"></p><p>然后就是线程池的状态常量，比如<code>RUNNING</code>状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -1的补码为：111-11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 左移29位：  111-00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 10进制为：-536870912 </span></span><br><span class="line"><span class="comment">// 高3位111的值就是表示线程池正在处于运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RUNNING</span> <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>线程池状态的运行状态常量：</p><table><thead><tr><th align="center">状态名称</th><th align="center">位图</th><th align="center">十进制值</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>RUNNING</code></td><td align="center"><code>111-0000...</code></td><td align="center">-536870912</td><td>运行中状态，可以接受新的任务和执行任务队列中的任务。</td></tr><tr><td align="center"><code>SHUTDOWN</code></td><td align="center"><code>000-0000...</code></td><td align="center">0</td><td>关闭状态，不再接收新的任务，但是会执行任务队列中的任务。</td></tr><tr><td align="center"><code>STOP</code></td><td align="center"><code>001-0000...</code></td><td align="center">536870912</td><td>停止状态，不再接受新的任务，也不会执行任务队列中的任务，中断所有执行中的任务。</td></tr><tr><td align="center"><code>TIDYING</code></td><td align="center"><code>010-0000...</code></td><td align="center">1073741824</td><td>整理中状态，所有任务都已经执行完毕，工作线程数为0，过渡到此状态的工作线程会调用钩子方法<code>terminated()</code></td></tr><tr><td align="center"><code>TERMINATED</code></td><td align="center"><code>011-0000...</code></td><td align="center">1610612736</td><td>终止状态，钩子方法<code>terminated()</code>执行完毕。</td></tr></tbody></table><p>这里还有一个比较特殊的技巧，由于运行状态值存放在高3位，所以直接可以通过十进制来比较判断线程池的状态：</p><blockquote><p><code>RUNNING</code> &lt; <code>SHUTDOWN</code> &lt; <code>STOP</code> &lt; <code>TIDYING</code> &lt; <code>TERMINATED</code></p></blockquote><p>下面的3个方法就是使用这种技巧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl和状态常量比较，判断是否小于</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl和状态常量比较，判断是否小于或等于</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl和状态常量SHUTDOWN比较，判断是否处于RUNNING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程状态流转关系如下图：</p><p><img src="https://qtspace.cn/contentimg/43.jpg"></p><h4 id="execute方法源码分析"><a href="#execute方法源码分析" class="headerlink" title="execute方法源码分析"></a>execute方法源码分析</h4><p>线程异步执行任务的方法实现是<code>ThreadPoolExecutor#execute()</code>方法，我们从源码的实现来学习，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断任务对象非空</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerExcetion</span>();</span><br><span class="line">    <span class="comment">// 获取ctl值, 用于获取线程池状态、线程池线程数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 如果当前线程数小于核心线程数，则创建新的核心线程数并且执行传入的任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWoker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="comment">// 如果创建新的核心线程成功则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 这里说明创建新的核心线程失败，则更新ctl的临时变量c</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明创建核心线程失败，也就是当前工作的线程数大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 判断线程是否处于运行中状态，如果是运行状态尝试使用非阻塞方法向任务队列放入任务</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 这里向任务队列投放成功，对线程池的运行中状态做二次检查</span></span><br><span class="line">        <span class="comment">// 如果线程池二次检查状态是非运行中状态，则从任务队列移除当前的任务，调用拒绝策略处理</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning() &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 调用拒绝策略处理任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 走到这里说明有以下的前提：</span></span><br><span class="line">        <span class="comment">// 1、待执行的任务已经成功加入任务队列</span></span><br><span class="line">        <span class="comment">// 2、线程池状态可能是RUNNING</span></span><br><span class="line">        <span class="comment">// 3、传入的任务可能从任务队列中移除失败(移除失败的唯一可能就是任务已经被执行了)</span></span><br><span class="line">        <span class="comment">// 如果当前工作线程数量为0，则创建一个非核心线程并且传入的对象为null</span></span><br><span class="line">        <span class="comment">// 也就是创建非核心线程不会马上运行，而是等待获取任务队列的任务再执行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 创建一个非核心线程并且传入的任务对象为null</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里说明以下：</span></span><br><span class="line">    <span class="comment">// 1、线程池的工作线程总数已经大于等于核心线程数</span></span><br><span class="line">    <span class="comment">// 2、线程池可能不是RUNNING状态</span></span><br><span class="line">    <span class="comment">// 3、线程池可能是RUNNING状态同时任务队列已经满了</span></span><br><span class="line">    <span class="comment">// 如果任务队列投放任务失败，则会尝试创建非核心线程执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 如果创建非核心线程失败，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的流程如下：</p><ol><li>如果当前工作线程总数小于核心线程数<code>corePoolSize</code>，则直接创建核心线程去执行任务（任务实例会传入直接用于构造工作线程实例）。</li><li>如果当前工作线程总是大于等于核心线程数<code>corePoolSize</code>，判断线程状态是否是运行中状态，如果是运行中状态则会尝试用非阻塞方法（<code>offer()</code>）向任务队列投放任务，如果投放成功会二次检查线程池运行状态，如果线程池是非运行中状态或者从任务队列移除当前的任务失败，则会调用拒绝策略，如果当前工作线程数量为0，则创建一个非核心线程并且传入的任务对象为<code>null</code>。</li><li>如果任务队列投放任务失败了（任务队列满了），则会创建创建非核心线程传入任务实例执行。</li><li>如果非核心线程创建失败，则会调用拒绝策略。</li></ol><p><strong>这里有一个疑惑点</strong>：为什么要二次检查线程池的状态，当前工作线程数量为0，尝试创建一个非核心线程并且传入的任务对象为<code>null</code>？这个可以看<code>API</code>的解释：</p><blockquote><p>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程，因为所有存活的工作线程有可能在最后一次检查之后就终结了或者执行当前任务的时候线程池是否已经<code>shutdown</code>了，所以我们需要二次检车线程池的状态，必须时要把任务从任务队列中移除或者在没有可用的工作线程的前提的下创建一个工作线程。</p></blockquote><p><code>execute()</code>方法执行流程图如下：</p><p><img src="https://qtspace.cn/contentimg/44.jpg"></p><h4 id="addWorker方法源码分析"><a href="#addWorker方法源码分析" class="headerlink" title="addWorker方法源码分析"></a>addWorker方法源码分析</h4><p><code>addWorker()</code>方法用于添加工作线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">pirvate <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断边界情况表，当线程池的状态是shutdown状态下，不会再接受新的任务，</span></span><br><span class="line">        <span class="comment">// 在此前提下如果状态已经到stop状态、或者传入任务不为空、或者任务队列为空</span></span><br><span class="line">        <span class="comment">// 都不需要添加新的任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">           !(rs == SHUTDOWN &amp;&amp;</span><br><span class="line">             firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">             ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取工作线程总数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workCountOf(c);</span><br><span class="line">            <span class="comment">// 如果工作线程总数大于等于容量或者大于等于核心线程数/最大线程数,</span></span><br><span class="line">            <span class="comment">// 则不需要添加新的任务</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 成功通过cas添加新的线程数wc，则break到最外层的循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndOIncreamentWorkerCount(c))</span><br><span class="line">                breack retry;</span><br><span class="line">            <span class="comment">// 走到这里说明通过cas添加新的线程数wc失败，这个时候需要重新判断线程池的状态</span></span><br><span class="line">            <span class="comment">// 是否由RUNNABLE已经变成SHUTDOWN</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 如果线程池状态已经由RUNNING已经变为SHUTDOWN，则重新跳出到外层循环继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 如果线程池状态依然是RUNNING, CAS更新工作线程数wc失败说明有可能是并发更新导致的失败</span></span><br><span class="line">            <span class="comment">// 则在内层循环即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标记工作线程是否成功启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 标记工作线程是否创建成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 传入任务实例firstTask创建worker实例，Worker构造里面会通过线程工厂创建新的Thread对象</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="comment">// 获取worker的线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取全局锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 全局锁加锁，因为会改变一些指标值和非线程安全的集合</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果线程池状态不是RUNNING或者是SHUTDOWN同时传入的任务实例firstTask为null，</span></span><br><span class="line">                <span class="comment">// 则判断线程是否存活，不存活抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 把创建的工作线程实例添加到工作线程集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 获取工作线程数量</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="comment">//  尝试更新线程池峰值容量</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 标记工作线程添加成功，后面才会调用Thread#start()方法启动真实的线程实例</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unLock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果成功添加工作线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 调用Worker内部的线程实例t的Thread#start()方法启动真实的线程实例</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 线程启动失败，则需要从工作线程集合移除对应的Worker</span></span><br><span class="line">         <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">          addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加Worker失败</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock();</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 从工作线程移除</span></span><br><span class="line">            workers.remove();</span><br><span class="line">        <span class="comment">// 工作线程数-1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 基于状态尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWorker()</code>方法是用来添加执行任务，这个流程可以分为两部分来看，第一部分是用于记录线程数量，第二部分是在独占锁里创建执行线程并启动。流程如下：</p><ul><li>首先判断当前线程池的状态是否是<code>SHUTDOWN</code>、<code>STOP</code>、<code>TIDYING</code>、<code>TERMINATED</code>中的一个。并且当前状态为<code>SHUTDOWN</code>、且传入的任务为<code>NULL</code>、同时任务队列不为空。那么就返回<code>false</code>。</li><li>不满足上一点然后判断线程数是否超过核心线程数或者最大线程数（根据传入的<code>core</code>判断），如果超过则返回<code>false</code>。</li><li>然后通过<code>CAS</code>操作增加线程池数量，成功跳出循环体。</li><li>线程池数量记录成功之后，创建工作实例，使用独占锁创建工作线程并加入到工作线程集合，并记录添加状态，添加成功则启动工作线程，记录启动状态，如果最后启动失败则调用<code>addWorkerFailed()</code>方法移除线程等操作。</li></ul><p>流程图如下：</p><p><img src="https://qtspace.cn/contentimg/45.jpg"></p><h4 id="内部类Worker源码分析"><a href="#内部类Worker源码分析" class="headerlink" title="内部类Worker源码分析"></a>内部类Worker源码分析</h4><p>线程池中的每一个具体的工作线程被包装为内部类<code>Worker</code>实例，<code>Worker</code>继承与<code>AQS</code>，实现了<code>Runnable</code>接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronized</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存ThreadFactory创建的线程实例，如果创建失败为null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存传入的Runnable实例</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录线程完成的任务总数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唯一构造方法，传入任务实例firstTask, 可以为null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程中断，直到runWorker方法执行</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.firstTask = firseTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用外部的runWorker方法执行真正的任务</span></span><br><span class="line">        runWorker(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否持有独占锁，state = 0表示没有获取锁，state &gt; 0表示获取锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取独占锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试释放独占锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动后进行线程中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Worker</code>的构造函数里面的逻辑十分重要，通过<code>ThreadFactory</code>创建<code>Thread</code>实例同时引入<code>Worker</code>实例，因为<code>Worker</code>本身实现了<code>Runnable</code>，所以可以作为任务提交到线程中执行。只要<code>Worker</code>持有的线程实例<code>w</code>调用<code>Thread#start()</code>方法就能执行<code>Worker#run()</code>。简化一下逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addWorker()方法中构造</span></span><br><span class="line"><span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> createWorker();</span><br><span class="line"><span class="comment">// 通过线程池构造时候传入</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> getThreadFactory();</span><br><span class="line"><span class="comment">// Worker构造函数中</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> threadFactory.newThread(worker);</span><br><span class="line"><span class="comment">// addWorker()方法中启动</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><p><code>Worker</code>继承<code>AQS</code>，这里使用了<code>AQS</code>的独占锁模式，这里有个技巧是构造<code>Worker</code>的时候，把<code>AQS</code>资源状态通过<code>setState(-1)</code>设置成-1，这是因为<code>Wokrer</code>实例刚创建时<code>AQS</code>中<code>state</code>的默认值是0，此时线程尚未启动，不能在这个时候进行线程中断，见<code>Worker#interruptIfStarted()</code>方法。</p><h4 id="runWorker方法源码分析"><a href="#runWorker方法源码分析" class="headerlink" title="runWorker方法源码分析"></a>runWorker方法源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程，实际上和Wokrer持有的线程实例是相同的</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取worker中持有的初始化时传入的任务对象，这里存放临时变量task</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 设置Worker中持有的初始化时传入的任务对象为null</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 构造方式的是state设置成-1，这里解锁state设成为0，允许线程中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 记录线程是否因为用户异常终结</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化任务对象不为空或者从任务队列获取到的任务对象不为空</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池正在停止状态，线程需要终止</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务执行之前</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行之后</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 任务对象设为null</span></span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 完成工作数量+1</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常完成任务</span></span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 处理线程退出，completedAbruptly为true说明由于用户异常导致线程非正常退出</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runWorker</code>方法的核心流程如下：</p><ol><li><code>Worker</code>先执行解锁操作，允许线程中断。</li><li>通过<code>while</code>循环调用<code>getTask()</code>方法获取任务对象，首轮循环可能是外部传入的收个任务对象。</li><li>如果线程池状态变为<code>STOP</code>状态，则需要确保工作线程是中断状态并且进行中断处理，否则要保证工作线程不是中断状态。</li><li>执行任务实例<code>Runnable#run()</code>方法，任务执行之前和之后分别会调用<code>beforeExecute()</code>和<code>afterExecute()</code>。</li><li><code>while</code>循环跳出说明任务全部执行完毕，然后会调用<code>processWorkerExit()</code>方法处理工作线程退出后的工作。</li></ol><p>千言万语不如一图，流程图如下：</p><p><img src="https://qtspace.cn/contentimg/46.jpg"></p><h4 id="getTask方法源码解析"><a href="#getTask方法源码解析" class="headerlink" title="getTask方法源码解析"></a>getTask方法源码解析</h4><p><code>getTask()</code>方法是工作线程在<code>while</code>死循环中获取任务队列中的任务对象的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录上一次从队列中获取的时候是否超时</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timeOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 获取线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果线程池状态至少为SHUTDOWN，如果线程池状态STOP或者任务队列为空</span></span><br><span class="line">        <span class="comment">// 则工作线程数量wc减1，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty()))&#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取工作线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// timed临时变量用于线程超时控制，决定是否需要通过poll()的非阻塞方法从任务队列获取任务</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认为false，如果设置成true,则允许核心线程也能通过poll()方法从任务队列中拉取任务</span></span><br><span class="line">        <span class="comment">// 工作线程数大于核心线程数的时候，说明线程池中创建了额外的非核心线程，这些非核心线程一定是通过poll()方法从任务队列中拉取任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.工作线程数大于最大线程数或者timed &amp;&amp; timedOut 说明线程命中了超时控制并且上一轮循环通过poll()方法从任务队列获取任务为null</span></span><br><span class="line">        <span class="comment">// 并且工作线程总数大于1或者任务队列为空，则通过CAS把线程数减去1，同时返回null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果timed为true，通过poll()方法做超时拉取，keepAliveTime时间内没有等待到有效的任务，则返回null</span></span><br><span class="line">            <span class="comment">// 如果timed为false，通过take()做阻塞拉取，会阻塞到有下一个有效的任务时候再返回（一般不会是null）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ? </span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedCount  = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，有两处十分复杂的<code>if</code>逻辑，先来看第一处，对于第一处<code>if</code>可能导致工作线程数量减去1直接返回<code>null</code>的场景有：</p><ul><li>线程池状态为<code>SHUTDOWN</code>，一般是调用了<code>shutdown()</code>方法，并且任务队列为空。</li><li>线程池状态为<code>STOP</code>。</li></ul><p>对于第二处<code>if</code>逻辑有点复杂，先拆解一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作线程总数大于最大线程数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> wc &gt; maximumPoolSize;</span><br><span class="line"><span class="comment">// 允许线程超时同时上一轮通过poll()方法从任务队列中获取任务为null</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> timed &amp;&amp; timedOut;</span><br><span class="line"><span class="comment">// 作线程总数大于1</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> wc &gt; <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 任务队列为空</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> workQueue.isEmpty();</span><br><span class="line"><span class="keyword">if</span> (r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑大多数情况下是针对非核心线程的。在<code>execute()</code>方法中，线程总数大于核心线程并且小于最大线程数时，会调用<code>addWorker(task, false)</code>方法添加非核心线程，而这里的逻辑恰好是想法的操作，用于减少非核心线程数，使得工作县城总数总是接近于核心线程数。如果对于核心线程，上一轮循环获取对象为<code>null</code>，这一轮循环很容易满足<code>timed &amp;&amp; timedOut</code>为<code>true</code>，这个时候<code>getTask()</code>返回<code>null</code>导致<code>runWorker()</code>方法跳出循环，最后执行<code>processWorkerExit()</code>方法处理工作，而该非核心线程对应的<code>Worker</code>则变成“游离对象”，等待被JVM回收。当<code>allowCoreThreadTimeOut</code>设置为<code>true</code>的时候，这里分析的非核心线程的生命周期终结逻辑同时会适用于核心线程，那么可以总结出<code>keepAliveTime</code>的意义：</p><ul><li>当允许核心线程超时，也就是<code>allowCoreThreadTimeOut</code>设置为true的时候，此时<code>keepAliveTime</code>表示空闲的工作线程存活周期。</li><li>默认情况下不允许核心线程超时，此时<code>keepAliveTime</code>表示空闲的非核心线程存活周期。</li></ul><h3 id="三、手写一个线程池"><a href="#三、手写一个线程池" class="headerlink" title="三、手写一个线程池"></a>三、手写一个线程池</h3><p>通过上面对<code>ThreadPoolExecutor</code>的学习，我们可以手写一个简单的线程池，包含了线程的核心逻辑，包含了提交任务，添加任务，获取任务，执行任务核心逻辑。</p><p>这个手写线程池的逻辑也非常简单，只体现核心流程，包括：</p><ol><li>有n个一直执行的线程。</li><li>把线程提交给线程池运行。</li><li>如果线程池已满，则把线程放入队列中。</li><li>最后当有空闲时，则获取队列中线程进行运行。</li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTrader</span> <span class="keyword">implements</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolTrader</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (c &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addWorker(command)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!addWorker(command)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctl.get() &gt;= maximumPoolSize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        worker.thread.start();</span><br><span class="line">        ctl.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="built_in">this</span>.thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> firstTask;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;当前执行任务的线程：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="keyword">if</span> (ctl.get() &gt; maximumPoolSize) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ctl.decrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;workQueue.size：&quot;</span> + workQueue.size());</span><br><span class="line">                <span class="keyword">return</span> workQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error！ctl.count：&quot;</span> + ctl.get() + <span class="string">&quot; workQueue.size：&quot;</span> + workQueue.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTrader</span> <span class="variable">threadPoolTrader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTrader</span>(<span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPoolTrader.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;任务编号：&quot;</span> + finalI);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码测试如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">当前执行任务的线程：Thread-1</span><br><span class="line">当前执行任务的线程：Thread-0</span><br><span class="line">任务编号：1</span><br><span class="line">任务编号：0</span><br><span class="line">workQueue.size：8</span><br><span class="line">workQueue.size：8</span><br><span class="line">当前执行任务的线程：Thread-0</span><br><span class="line">当前执行任务的线程：Thread-1</span><br><span class="line">任务编号：3</span><br><span class="line">任务编号：2</span><br><span class="line">workQueue.size：6</span><br><span class="line">当前执行任务的线程：Thread-1</span><br><span class="line">workQueue.size：6</span><br><span class="line">当前执行任务的线程：Thread-0</span><br><span class="line">任务编号：5</span><br><span class="line">workQueue.size：4</span><br><span class="line">当前执行任务的线程：Thread-0</span><br><span class="line">任务编号：4</span><br><span class="line">workQueue.size：3</span><br><span class="line">当前执行任务的线程：Thread-1</span><br><span class="line">任务编号：6</span><br><span class="line">workQueue.size：2</span><br><span class="line">当前执行任务的线程：Thread-0</span><br><span class="line">任务编号：7</span><br><span class="line">workQueue.size：1</span><br><span class="line">当前执行任务的线程：Thread-1</span><br><span class="line">任务编号：8</span><br><span class="line">任务编号：9</span><br><span class="line">workQueue.size：0</span><br><span class="line">workQueue.size：0</span><br></pre></td></tr></table></figure><h3 id="四、创建线程池的四种方式"><a href="#四、创建线程池的四种方式" class="headerlink" title="四、创建线程池的四种方式"></a>四、创建线程池的四种方式</h3><p><a href="https://qtspace.cn/2022/03/02/java-create-threadpool/" target="_blank">Java 创建线程池的四种方式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、为什么要使用线程池？&quot;&gt;&lt;a href=&quot;#一、为什么要使用线程池？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    
    <category term="线程池" scheme="https://qtspace.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Thread状态流转、方法使用、原理分析</title>
    <link href="https://qtspace.cn/2022/04/04/thread-state-use-principle/"/>
    <id>https://qtspace.cn/2022/04/04/thread-state-use-principle/</id>
    <published>2022-04-03T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:35.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、Thread状态"><a href="#一、Thread状态" class="headerlink" title="一、Thread状态"></a>一、Thread状态</h3><p><code>Java</code>的线程状态描述在<code>Thread</code>类里面的枚举类<code>State</code>中，包路径为<code>java.lang.Thread.State</code>，总共包含以下六种状态：<code>NEW</code>、<code>RUNNABLE</code>、<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>TERMINATED</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 尚未启动的线程的线程状态</span></span><br><span class="line">    NEW,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可运行线程的线程状态，是可运行的线程</span></span><br><span class="line">    <span class="comment">// 这个状态在Java虚拟机中进行，但它可能等待来自操作系统的其他资源，比如处理器</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 线程阻塞等待监视器锁的线程状态</span></span><br><span class="line">    <span class="comment">// 处于阻塞状态的线程正在等待监视器锁</span></span><br><span class="line">    <span class="comment">// 例如synchronized锁</span></span><br><span class="line">    BLOCKED,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待线程的线程状态</span></span><br><span class="line">    <span class="comment">// 线程调用以下方法会处于等待状态：Object.wait()不超时、Thread.join()不超时、LockSupport.park()</span></span><br><span class="line">    <span class="comment">// 一个处于等待状态的线程正在等待另一个线程执行特定动作，例如：</span></span><br><span class="line">    <span class="comment">// 一个线程调用了Object.wait()方法在一个对象上正在等待另一个线程调用Object.nofify()或者</span></span><br><span class="line">    <span class="comment">// Object.nofifyAll()方法开启那个对象</span></span><br><span class="line">    <span class="comment">// 一个调用了Thread.join()方法的线程正在等待指定线程终止</span></span><br><span class="line">    WAITING,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 具有指定等待时间的等待线程的线程状态，调用一下方法会处于这个状态：</span></span><br><span class="line">    <span class="comment">// Object.wait() 超时、Thread.join()超时</span></span><br><span class="line">    <span class="comment">// LockSupport.parkNanos()、LockSupport.parkUntil()</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已终止线程的线程状态</span></span><br><span class="line">    <span class="comment">// 线程已执行完毕或者发生异常终止</span></span><br><span class="line">    TERMINATED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的六种状态相当于描述了一个线程的生命周期，这些状态之间是可以流转的，那么线程的状态是如何流转的呢，我们看下图：</p><p><img src="https://qtspace.cn/contentimg/41.jpg"></p><ul><li><p><code>NEW</code>：未启动状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 这个时候只是new了一个线程，并没有调用start()方法</span></span><br><span class="line">    <span class="comment">// 输出 NEW</span></span><br><span class="line">    System.out.println(t.getState().name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>RUNNABLE</code>：可运行状态，处于可运行状态的线程正在<code>Java</code>虚拟机中运行，但也可能是正在等待来自操作系统资源，比如CPU。在<code>RUNNABLE</code>状态中包含了<code>RUNNING</code>、<code>READY</code>两个状态，这两个状态是可以互相流转的。当线程调用<code>start()</code>方法后，线程就处于<code>READY</code>状态，等待操作系统分配<code>CPU</code>时间片，分配后进入<code>RUNNING</code>状态。当调用<code>yield()</code>方法后，只是谦让的允许当前线程让出<code>CPU</code>，但是不一定让，由操作系统决定，如果让了当前线程就会进入<code>READY</code>状态，等待系统分配<code>CPU</code>时间片再次进入<code>RUNNING</code>状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="comment">// 调用start()方法</span></span><br><span class="line">    <span class="comment">// 输出RUNNABLE</span></span><br><span class="line">    System.out.println(t.getState().name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>BLOCKED</code>：阻塞状态。当发生线程锁竞争状态下，没有获取到锁的线程会被挂起进入阻塞状态，比如<code>synchronized</code>锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">// main线程先获取锁， t线程start的时候进入阻塞状态</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 输出BLOCKED</span></span><br><span class="line">        System.out.println(t.getState().name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>WIITING</code>：等待状态，可被唤醒的等待状态，此时线程不会执行也不会被调度，：可被唤醒的等待状态，此时线程不会被执行也不会被系统调度，此状态可以通过 synchronized 获得锁，调用 wait 方法进入等待状态，最后通过<code>Object.notify()</code>、<code>Object.nofifyAll()</code>唤醒。下列方法可以让线程进入<code>WAITING</code>状态：<code>Object.wait()</code>、<code>Thread.join()</code>、<code>LockSupport.park()</code>，调用以下方法可以唤醒登台的线程进入<code>RUNNABLE</code>状态：<code>Object.notify()</code>、<code>Object.nofifyAll()</code>、<code>LockSupport.unpark(Thread)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 输出WAITING</span></span><br><span class="line">        System.out.println(t.getState().name());</span><br><span class="line">        lock.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TIMED_WAITING</code>：具有等待时间的等待状态，此时线程不会执行也不会被调度，直到等待时间到期后才会被执行。下列方法可以让线程进入<code>TIMED_WAITING</code>状态：<code>Thread.sleep(long)</code>、<code>Object.wait(long)</code>、<code>Thread.join(long)</code>、<code>LockSupport.parkNanos()</code>、<code>LockSupport.parkUntil()</code>。除了等待时间到期会被执行外，还可以调用以下方法：<code>Object.notify()</code>、<code>Object.nofifyAll()</code>、<code>LockSupport.unpark(Thread)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 输出TIMED_WAITING</span></span><br><span class="line">    System.out.println(t.getState().name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TERMINATED</code>：已终止状态，线程已完成执行或者发生了异常终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="comment">// 输出 TERMINATED</span></span><br><span class="line">    System.out.println(t.getState().name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、创建Thread方式"><a href="#二、创建Thread方式" class="headerlink" title="二、创建Thread方式"></a>二、创建Thread方式</h3><p>创建线程的方式有三种，分别是：继承<code>Thread</code>类、实现<code>Runnable</code>接口、实现<code>Callable</code>接口和使用<code>Future</code>。</p><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Callable接口和使用Future"><a href="#实现Callable接口和使用Future" class="headerlink" title="实现Callable接口和使用Future"></a>实现Callable接口和使用Future</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(threadDemo);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(future);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、Thread方法使用"><a href="#三、Thread方法使用" class="headerlink" title="三、Thread方法使用"></a>三、Thread方法使用</h3><p><code>Thread</code>类常用的方法有以下：</p><ul><li><code>start()</code>：启动当前线程。</li><li><code>run()</code>：线程启动的时候执行的方法。</li><li><code>currentThread()</code>：静态方法，返回执行当前代码的线程。</li><li><code>getName()</code>：获取当前线程的名字。</li><li><code>setName(String name)</code>：设置当前线程的名字</li><li><code>yield()</code>：释放当前CPU的执行权（但也有可能下一刻的执行权又回到了当前线程，主控权还是在CPU手上）。</li><li><code>join()</code>：当线程a调用线程b的<code>join()</code>方法，此时线程a进入阻塞状态，直到线程b完全执行完之后，线程a结束阻塞状态。</li><li><code>stop</code>：当执行此方法时，强制结束当前线程（<strong>已停用</strong>）。</li><li><code>sleep()</code>：让当前线程“睡眠”指定的millitime<strong>毫秒</strong>。在指定的millitime毫秒时间内，当前进程是阻塞状态。</li><li><code>getPriority()</code>：获取线程优先级。</li><li><code>isAlive()</code>：判断当前线程是否存活（线程执行完之前都是存活的）。</li><li><code>setDeamon()</code>：设置守护线程。</li><li><code>isDaemon()</code>：是否是守护线程。</li><li><code>isInterrupted()</code>：线程是否中断。</li></ul><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>守护线程又称后台线程，默认创建出来的线程都是前台线程，可以通过<code>setDeamon(true)</code>设定为后台线程。</p><p>后台线程和前台线程主要区分在结束时机：当一个进程中的所有前台线程都执行完毕，无论进程中的后台线程是否执行完毕，都要强制中断。</p><p>看以下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Rose:啊啊啊啊啊AAAAAaaaaa......&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;效果：噗通......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Jack:You jump,I jump&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jack线程设置为后台线程, 一定要在start()方法之前调用</span></span><br><span class="line">    jack.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    rose.start();;</span><br><span class="line">    jack.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while(true);//有进程没结束，后台线程不会结束。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Jack:You jump,I jump</span><br><span class="line">Rose:Let me go die!</span><br><span class="line">Rose:啊啊啊啊啊AAAAAaaaaa......</span><br><span class="line">效果：噗通......</span><br></pre></td></tr></table></figure><p>从输出可以看出前台线程执行完毕之后，后台线程就立即停止了，如果把<code>while(true)</code>去掉注释，那么后台线程会一直执行。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p><code>sleep()</code>方法可以使当前方法的线程阻塞指定毫秒，超时后，该线程方法会自动回到<code>RUNNABLE</code>状态等待再次分配时间片执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序开始了&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里会使main线程阻塞5秒，在此过程中</span></span><br><span class="line"><span class="comment"> * 若其他线程调用了main线程的interrupt方法</span></span><br><span class="line"><span class="comment"> * 试图中断main线程时，sleep方法会抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序结束了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p><code>join()</code>方法会阻塞调用当前方法的线程，并在<code>join()</code>方法所属对象线程上等待，直到该线程执行完毕才会解除阻塞继续执行。</p><p>举个栗子：a线程调用b线程的<code>join()</code>方法，那么a线程就会进入阻塞状态，直到b线程执行完毕才会解除阻塞继续往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下载图片线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">download</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;download：开始下载照片&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;下载进度:&quot;</span>+i+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;download：图片下载完毕&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示图片线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">show</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：开始显示图片&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 只有图片下载完毕之后才能显示图片</span></span><br><span class="line">                <span class="comment">// 调用下载图片线程的join()方法阻塞显示图片线程直到图片下载完毕</span></span><br><span class="line">                download.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;show：图片显示完毕&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        download.start();</span><br><span class="line">        show.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show：开始显示图片</span><br><span class="line">download：开始下载照片</span><br><span class="line">下载进度:1<span class="comment">%</span></span><br><span class="line">下载进度：...</span><br><span class="line">下载进度:100<span class="comment">%</span></span><br><span class="line">download：图片下载完毕</span><br><span class="line">show：图片显示完毕</span><br></pre></td></tr></table></figure><h4 id="wait-amp-nofify"><a href="#wait-amp-nofify" class="headerlink" title="wait &amp; nofify"></a>wait &amp; nofify</h4><p><code>wait()</code>和<code>notify()</code>方法是在<code>Object</code>类定义的，用来协调线程同步使用，相比<code>join()</code>同步的及时性更强，因为<code>join()</code>方法必须等待另外一个线程的所有工作都结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> isFinish;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 下载图片线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">download</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;download：开始下载照片&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;down图片进度:&quot;</span>+i+<span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;download：图片下载完毕&quot;</span>);</span><br><span class="line">        isFinish = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 图片下载完毕就可以通知显示图片线程显示图片, 没必要等下载附件执行完毕</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            obj.notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始下载附件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;down：开始下载附件...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;down附件进度：&quot;</span> + i + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;down：附件下载完毕!&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图片线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">show</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show：开始显示图片&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// obj.wait()方法会导致show线程进入阻塞状态直到obj调用notify()方法</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                obj.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isFinish) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;图片不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;show：图片显示完毕&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    download.start();</span><br><span class="line">    show.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">show：开始显示图片</span><br><span class="line">download：开始下载照片</span><br><span class="line">down图片进度:1<span class="comment">%</span></span><br><span class="line">down图片进度:...</span><br><span class="line">down图片进度:100<span class="comment">%</span></span><br><span class="line">download：图片下载完毕</span><br><span class="line">down：开始下载附件...</span><br><span class="line">show：图片显示完毕</span><br><span class="line">down附件进度：1<span class="comment">%</span></span><br><span class="line">down附件进度：...</span><br><span class="line">down附件进度：100<span class="comment">%</span></span><br><span class="line">down：附件下载完毕!</span><br></pre></td></tr></table></figure><p>从上面输出我们看出当下载线程图片下载完毕之后，显示图片线程就执行了，不需要等待附件下载完毕再执行。</p><p><code>Oject</code>还有一个<code>notifyAll()</code>方法，当该方法被调用时，等待队列中的所有对象都被会唤醒。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p><code>yield()</code>方法会使线程让出<code>CPU</code>，但不是暂停执行，线程还会继续进行<code>CPU</code>的争夺，但是也不是一定就会让出，这个由操作系统决定。如果一个线程不那么重要，或者对应任务的优先级非常低，或者不希望它占用过多的资源，那么就可以使用<code>yield()</code>方法给予其它线程更多的执行机会。</p><h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><ul><li>被<code>wait()</code>方法阻塞的线程可以通过<code>notify()</code>或者<code>notifyAll()</code>方法唤醒，而执行<code>sleep(0</code>方法的线程只能一直休眠到指定时间，不可被唤醒。</li><li>当被<code>wait()</code>方法阻塞的线程被唤醒的时候，会释放目标对象的锁，而<code>sleep()</code>方法指定的睡眠时候到的时候不会释放任何资源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、Thread状态&quot;&gt;&lt;a href=&quot;#一、Thread状态&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="线程" scheme="https://qtspace.cn/categories/Java/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Thread" scheme="https://qtspace.cn/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis手撸（一）Mybatis简介和整体架构</title>
    <link href="https://qtspace.cn/2022/04/02/hand-mybatis-1/"/>
    <id>https://qtspace.cn/2022/04/02/hand-mybatis-1/</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:28.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、Mybatis简介"><a href="#一、Mybatis简介" class="headerlink" title="一、Mybatis简介"></a>一、Mybatis简介</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html">MyBatis 官方文档</a></p><p><code>Mybatis</code>是一款旨在帮助开发人员屏蔽底层重复性的<code>JDBC</code>代码的持久层框架，支持通过配置文件或者注解将<code>ResultSet</code>映射成<code>Java</code>对象。相对于其它<code>ORM</code>框架，<code>Mybatis</code>更为轻量级，支持定制化<code>SQL</code>和动态<code>SQL</code>，方便优化查询性能，同时包含了良好的缓存机制。</p><h3 id="二、Mybatis整体架构"><a href="#二、Mybatis整体架构" class="headerlink" title="二、Mybatis整体架构"></a>二、Mybatis整体架构</h3><p><code>Mybatis</code>整体架构如下图：</p><p><img src="https://qtspace.cn/contentimg/39.jpg"></p><h4 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a>接口层</h4><ul><li><code>SqlSession</code>接口层定义了暴露给应用程序调用的<code>API</code>，接口层在收到请求时会调用<strong>核心处理层</strong>的相关模块完成具体的数据库操作。</li></ul><h4 id="核心处理层"><a href="#核心处理层" class="headerlink" title="核心处理层"></a>核心处理层</h4><ul><li>配置解析：<code>Mybatis</code>初始化时会加载配置文件、映射文件和<code>Mapper</code>接口的注解信息，解析完毕后会已对象的形式保存到<code>Configuration</code>对象中。</li><li><code>SQL</code>解析与<code>scripting</code> 模块：<code>Mybatis</code>支持通过配置实现动态的<code>SQL</code>，即根据不同参数生成<code>SQL</code>。</li><li><code>SQL</code>执行与结果集映射：<code>Executor</code>负责维护缓存和事务管理，并将数据库操作委托给<code>StatementHandler</code>,<code>ParmaterHandler</code>负责完成<code>SQL</code>语句的实参绑定并通过<code>Statement</code>对象执行<code>SQL</code>，最后通过<code>ResultSet</code>返回结果，交由<code>ResultSetHandler</code>处理映射成<code>Java</code>对象。</li><li>插件：支持开发者通过插件接口对<code>Mybatis</code>进行扩展。</li></ul><h4 id="基础支持层"><a href="#基础支持层" class="headerlink" title="基础支持层"></a>基础支持层</h4><ul><li>数据源模块：提供数据源实现并能集成第三方数据源模块。</li><li>事务管理模块：可以和<code>Spring</code>集成开发，对事物进行管理。</li><li>缓存模块：提供一级缓存和二级缓存，将部分请求拦截在缓存层，分担数据库压力，提高性能。</li><li><code>Binding</code>模块：在调用<code>SqlSession</code>相应方法执行数据库操作时，需要指定映射文件中的<code>SQL</code>节点，<code>Mybatis</code>通过<code>Binding</code>模块将自定义<code>Mapper</code>接口和映射文件关联，避免拼写等错误导致在运行时才被发现。</li><li>反射模块：提供封装的反射<code>API</code>，方便上层调用。</li><li>类型转换：为简化配置文件提供别名机制，并且实现了<code>Java</code>类型和<code>JDBC</code>类型的转换。</li><li>日志模块：能够集成多种第三方日志框架。</li><li>资源加载模块：对类加载器进行封装，提供类加载文件和其他资源文件的功能。</li><li>解析器模块：对<code>Xpath</code>进行封装，为<code>Mabatis</code>初始化时解析配置文件以及映射文件提供支持，对处理动态<code>SQL</code>语句中的占位符提供支持。</li></ul><h3 id="三、Mybatis执行流程"><a href="#三、Mybatis执行流程" class="headerlink" title="三、Mybatis执行流程"></a>三、Mybatis执行流程</h3><p>Mybatis执行流程如下图：</p><p><img src="https://qtspace.cn/contentimg/40.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、Mybatis简介&quot;&gt;&lt;a href=&quot;#一、Mybatis简介&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Mybatis" scheme="https://qtspace.cn/categories/Mybatis/"/>
    
    
    <category term="Mybatis" scheme="https://qtspace.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal底层实现原理详解</title>
    <link href="https://qtspace.cn/2022/04/01/threadlocal-principle/"/>
    <id>https://qtspace.cn/2022/04/01/threadlocal-principle/</id>
    <published>2022-03-31T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:38.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、ThreadLocal简介"><a href="#一、ThreadLocal简介" class="headerlink" title="一、ThreadLocal简介"></a>一、ThreadLocal简介</h3><p><code>ThreadLocal</code>顾名思义可以根据字面意思理解成线程本地变量。也就是说如果定义了一个<code>ThreadLocal</code>，每个线程都可以在这个<code>ThreadLocal</code>中读写，这个读写是线程隔离的，线程之前不会有影响。</p><p>每个<code>Thread</code>都维护自己的一个<code>ThreadLocalMap </code>，所以是线程隔离的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>通过这个<code>ThreadLocalMap</code>实现数据的读写，既然是<code>Map</code>肯定有<code>key</code>和<code>value</code>，但是这个<code>ThreadLocalMap</code>的<code>key</code>可以简单的看成是<code>ThreadLocal</code>，实际是并不是<code>ThreadLocal</code>的本身，而是它的一个<strong>弱引用</strong>。</p><h3 id="二、ThreadLocal学习大纲"><a href="#二、ThreadLocal学习大纲" class="headerlink" title="二、ThreadLocal学习大纲"></a>二、ThreadLocal学习大纲</h3><p>学习大纲思维导图如下图：</p><p><img src="https://qtspace.cn/contentimg/23.jpg"></p><h3 id="三、ThreadLocal方法和成员变量"><a href="#三、ThreadLocal方法和成员变量" class="headerlink" title="三、ThreadLocal方法和成员变量"></a>三、ThreadLocal方法和成员变量</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>ThreadLocal</code>的<code>API</code>很少就包含了4个，分别是<code>get()</code>、<code>set()</code>、<code>remove()</code>、<code>withInitial()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ThreadLocal&lt;S&gt; <span class="title function_">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>get()</code>：获取当前线程对应的<code>ThreadLocalMap</code>存储的值，<code>key</code>为当前<code>TheadLocal</code>（实际为<code>TheadLocal</code>的弱引用），也就是获取当前线程本地变量的值。</li><li><code>set(T value)</code>：给当前线程对应的<code>ThreadLocalMap</code>的设置值，也就是给当前线程本地变量设置值。</li><li><code>remove()</code>：清除前线程对应的<code>ThreadLocalMap</code>存储的<code>TheadLocal</code>，也就是清除当前线程本地变量的值。</li><li><code>withInitial()</code>：用于创建一个线程局部变量，变量的初始化值通过调用Supplier的get方法来确定</li></ul><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用nextHashCode()方法获取下一个hashCode值，用于计算ThreadLocalMap.tables数组下标</span></span><br><span class="line"><span class="comment">// key.threadLocalHashCode &amp; (len - 1)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类，用于计算hashCode值</span></span><br><span class="line"><span class="keyword">private</span> staitc <span class="type">AmoicInteger</span> <span class="variable">nextHashCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AmoicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash增量值，斐波那契数也叫黄金分割数，可以让hash值分布非常均匀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个hashCode值方法，只用原子类操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、ThreadLocalMap"><a href="#四、ThreadLocalMap" class="headerlink" title="四、ThreadLocalMap"></a>四、ThreadLocalMap</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的一个静态内部类，在上面有说到每个线程都维护着一个<code>ThreadLocalMap</code>，这个&#96;&#96;ThreadLocalMap&#96; 就是用来储存数据的。</p><p><code>ThreadLocalMap</code>内部维护着一个<code>Entry</code>节点，这个节点继承了<code>WeakReference</code>类，泛型为<code>ThreadLocal</code>表示是弱引用，节点内部定义了一个为<code>Object</code>的<code>value</code>，这个<code>value</code>就是我们存放的值，<code>Entry</code>类的构造方法只有一个，传入<code>key</code>和<code>value</code>，这个<code>key</code>就是<code>ThreadLocal</code>，实际为<code>ThreadLocal</code>的弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreacLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line">    </span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v)&#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread、ThreadLocalMap、ThreadLocal结构关系"><a href="#Thread、ThreadLocalMap、ThreadLocal结构关系" class="headerlink" title="Thread、ThreadLocalMap、ThreadLocal结构关系"></a>Thread、ThreadLocalMap、ThreadLocal结构关系</h4><p>每个<code>Thread</code>都有一个<code>ThreadLocalMap</code>变量，<code>ThreadLocalMap</code>内部定义了<code>Entry</code>节点类，这个节点继承了<code>WeakReference</code>类泛型为<code>ThreacLocal</code>类，节点类的构造方法<code>ThreadLocal&lt;?&gt; k, Object v</code>，所以可以得到下面的结构关系图：</p><p><img src="https://qtspace.cn/contentimg/24.jpg"></p><h4 id="GC之后key是否为null？"><a href="#GC之后key是否为null？" class="headerlink" title="GC之后key是否为null？"></a>GC之后key是否为null？</h4><p>思考一个问题，既然<code>ThreadLocalMap</code>的<code>key</code>是弱引用，<code>GC</code>之后<code>key</code>是否为<code>null</code>？在搞清楚这个问题之前，我们需要先搞清楚<code>Java</code>的四种<strong>引用类型</strong>：</p><ul><li>强引用：<code>new</code>出来的对象就是强引用，只要强引用存在，垃圾回收器就永远不会回收被引用的对象，哪怕内存不足的时候。</li><li>软引用：使用<code>SoftReference</code>修饰的对象被称为软引用，在内存要溢出的时候软引用指向的对象会被回收。</li><li>弱引用：使用<code>WeakReference</code>修饰的对象被称为弱引用，只要发生垃圾回收，被弱引用指向的对象就会被回收。</li><li>虚引用：虚引用是最弱的引用，用<code>PhantomReference</code>进行定。唯一的作用就是用来队列接受对象即将死亡的通知。</li></ul><p>这个问题的答案是不为null，可以看下面的图：</p><p><img src="https://qtspace.cn/contentimg/25.jpg"></p><p>通过上图我们知道<code>ThreadLocal</code>的强引用是仍然存在的，所以不会被回收，不为<code>null</code></p><h4 id="ThreadLocalMap成员变量"><a href="#ThreadLocalMap成员变量" class="headerlink" title="ThreadLocalMap成员变量"></a>ThreadLocalMap成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化容量 必须为2的幂，位运算取代模运算提升计算效率，可以试hash值发生碰撞的概率更小，尽可能的使</span></span><br><span class="line"><span class="comment">// 元素在哈希表中均匀的散列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITTAL_CAPACIRY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry表</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entry表存放的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阙值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br></pre></td></tr></table></figure><h3 id="五、ThreadLocal-set-方法源码详解"><a href="#五、ThreadLocal-set-方法源码详解" class="headerlink" title="五、ThreadLocal.set()方法源码详解"></a>五、ThreadLocal.set()方法源码详解</h3><p><code>set()</code>方法用于给本地线程变量设值，我们先来看看<code>set()</code>方法的源码，从源码来一步一步解析实现原理，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pubic <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Threac.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前线程的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 如果map不为null， 调用ThreadLocalMap.set()方法设置值</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// map为null，调用createMap()方法初始化创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回线程的ThreadLocalMap.threadLocals</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用ThreadLocalMap构造方法创建ThreadLocalMap</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap构造方法，传入firstKey, firstValue</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化Entry表的容量 = 16</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 获取ThreadLocal的hashCode值与运算得到数组下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firsetKey.threadLocalHashCode &amp; (INITAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 通过下标Entry表赋值</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// Entry表存储元素数量初始化为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置Entry表扩容阙值 默认为 len * 2 / 3</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><code>ThreadLocal.set()</code>方法还是很简单的，核心方法在<code>ThreadLocalMap.set()</code>方法，<code>ThreadLocal.set()</code>方法流程如下：</p><ol><li>获取当前线程的<code>ThreadLocalMap map</code> 。</li><li>如果<code>map</code>不为<code>null</code>则调用<code>map.set()</code>方法设置值。</li><li>如果<code>map</code>为<code>null</code>则调用<code>createMap</code>方法创建。</li><li><code>createMap()</code>方法通过<code>ThreadLocalMap</code>的构造方法创建，构造方法主要做了初始化<code>Entry[] table</code>容量16，通过<code>ThreadLocal</code>的<code>threadLocalHashCode</code>调用<code>nextHashCode()</code>方法获取<code>hashCode</code>值计算出下标，<code>table</code>数组通过下标赋值，初始化存储的元素数量，初始化数组扩容阙值。</li></ol><p><img src="https://qtspace.cn/contentimg/26.jpg"></p><p><code>ThreadLocalMap</code>在构造方法里处理的时候用到了我们学习大纲里说到的<code>hash</code>算法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadLocalHashCode</span> <span class="operator">=</span> nextHashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最关键的就是<code>threadLocalHashCode</code>值的计算，<code>ThreadLocal</code>中有一个属性为<code>HASH_INCREMENT = 0x61c88647</code>，没创建一个<code>ThreadLocal</code>就会调用一次<code>nextHashCode()</code>方法，这个<code>HASH_INCREMENT</code>值就会增长<code>0x61c88647</code>，这个值很特殊，是斐波那契数也叫黄金分割数，这个值可以让<code>hash</code>分布非常均匀。</p><p>可以下一个小demo测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">HASH_INCREMENT</span> <span class="operator">=</span> <span class="number">0x61c88647</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        hashCode = i * HASH_INCREMENT + HASH_INCREMENT;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> hashCode &amp; (<span class="number">16</span> - <span class="number">1</span>);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;在桶中的位置：&quot;</span> + bucket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面测试输出如下：可以看出数据在算列数组中分布的很均匀。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0在桶中的位置：7</span><br><span class="line">1在桶中的位置：14</span><br><span class="line">2在桶中的位置：5</span><br><span class="line">3在桶中的位置：12</span><br><span class="line">4在桶中的位置：3</span><br><span class="line">5在桶中的位置：10</span><br><span class="line">6在桶中的位置：1</span><br><span class="line">7在桶中的位置：8</span><br><span class="line">8在桶中的位置：15</span><br><span class="line">9在桶中的位置：6</span><br><span class="line">10在桶中的位置：13</span><br><span class="line">11在桶中的位置：4</span><br><span class="line">12在桶中的位置：11</span><br><span class="line">13在桶中的位置：2</span><br><span class="line">14在桶中的位置：9</span><br><span class="line">15在桶中的位置：0</span><br></pre></td></tr></table></figure><h4 id="ThreadLocalMap-set-方法源码详解"><a href="#ThreadLocalMap-set-方法源码详解" class="headerlink" title="ThreadLocalMap.set()方法源码详解"></a>ThreadLocalMap.set()方法源码详解</h4><p><code>ThreadLocalMap.set()</code>方法分为好几种情况，主要有以下四种情况，针对不同的情况我们通过画图来说明。</p><blockquote><p>说明： 下面所有图中，绿色块<code>Entry</code>代表正常数据，灰色代表<code>Entry</code>的<code>key</code>值为<code>null</code>，已被<code>GC</code>回收，白色代表<code>Entry</code>为<code>null</code>。</p></blockquote><p><strong>第一种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>为<code>null</code>：</p><p><img src="https://qtspace.cn/contentimg/27.jpg"></p><p>这种情况直接将该数据放入该槽位即可。</p><p><strong>第二种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>不为<code>null</code>，但是<code>key</code>相同：</p><p><img src="https://qtspace.cn/contentimg/28.jpg"></p><p>这种情况直接该槽位的<code>value</code>值。</p><p><strong>第三种情况：</strong>通过<code>hash</code>计算得到的下标，该下标对应的<code>Entry</code>不为<code>null</code>，且<code>key</code>不相同，这种时候会遍历数组，线性往后查找，查找<code>Entry</code>为<code>null</code>的槽位，且在找到<code>Entry</code>为<code>null</code>之前没有遇到<code>key</code>过期的<code>Entry</code>，就该数据放入该槽位中，如果遍历过程中，遇到了<code>key</code>相等的槽位，直接更新<code>value</code>即可：</p><p><img src="https://qtspace.cn/contentimg/29.jpg"></p><p>注意：每次循环查找都会判断<code>key</code>是否相等，如果相等则更新<code>value</code>直接返回。</p><p><strong>第四种情况：</strong>基于第三种情况，如果在找到<code>Entry</code>为<code>null</code>之前遇到了<code>key</code>过期的<code>Entry</code>，如下图：</p><p><img src="https://qtspace.cn/contentimg/30.jpg"></p><p>如上图散列数组下标为7位置对应的<code>Entry</code>数据<code>key</code>为<code>null</code>，说明此数据<code>key</code>值已经被垃圾回收掉了，此时会执行<code>replaceStaleEntry()</code>方法，该方法含义是<strong>替换过期数据的逻辑</strong>，以<code>index=7</code>为起点开始向前遍历，进行探测式数据清理工作。</p><p>初始化探测式清理过期数据扫描的开始位置：<code>slotToExpunge = stateSlot = 7</code>。</p><p>以当前<code>stateSlot </code>开始向前迭代找到，找到其他过期的数据，然后更新过期数据起始扫描下标的<code>slotToExpunge </code>，直到找到了<code>Entry</code>为<code>null</code>的槽位则结束。</p><p>如果找到过期数据，继续向前迭代，直到遇到<code>Entry=null</code>的槽位则停止迭代，如下图所示，<code>slotToExpunge</code>被更新为0：</p><p><img src="https://qtspace.cn/contentimg/31.jpg"></p><p>上图以当前节点<code>index = 7</code>向前迭代，检测是否有过期的<code>Entry</code>数据，如果有则更新<code>slotToExpunge</code>的值，遇到<code>Entry</code>为<code>null</code>则结束探测，以上图为例<code>slotToExpunge</code>被更新为0。</p><p>上面向前迭代的操作是为了更新探测清理过期数据的起始位置<code>soltToExpunge</code>的值，这个值是用来判断当前过期槽位<code>staleSlot</code>之前是否还有过期元素。</p><p>接着开始<code>staleSolt</code>位置<code>index = 7</code>向后迭代，<strong>如果找到了相等<code>key</code>的<code>Entry</code>的数据</strong>则更新<code>value</code>值，如下图：</p><p><img src="https://qtspace.cn/contentimg/32.jpg"></p><p>从当前节点<code>staleSolt</code>位置开始向后寻找<code>key</code>相等的<code>Entry</code>位置，如果找到了<code>key</code>相等的<code>Entry</code>，则会交换<code>staleSlot</code>元素的位置，且更新<code>value</code>值，然后进行过期<code>Entry</code>的清理工作，如下图：</p><p><img src="https://qtspace.cn/contentimg/33.jpg"></p><p>如果没有找到<strong>相等<code>key</code>的<code>Entry</code>的数据</strong>，如下图：</p><p><img src="https://qtspace.cn/contentimg/34.jpg"></p><p>从当前节点<code>staleSlot</code>向后查找<code>key</code>值相等的<code>Entry</code>，如果没有找到，则会继续往后查找直到找到<code>Entry</code>为<code>null</code>停止，然后创建新的<code>Entry</code>，替换<code>stableSlot</code>的位置。</p><p>替换完成之后也是进行过期元素的清理工作，清理工作的方法主要有两个<code>expungeStaleEntry</code>和<code>cleanSomeSlots</code>，具体详情后面会讲到。</p><p>上面已经图解了<code>set()</code>方法实现的原理，接下来我们结合源码再来看看，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Entry表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 获取当前要放入元素的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; </span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)])&#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果查找到key相等的entry，则更新value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            v.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果查找到为key为null的entry，说明key过期，被GC回收</span></span><br><span class="line">        <span class="comment">// 这个时候要初始化探测式清理的起始位置</span></span><br><span class="line">        <span class="comment">// 替换过期元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStateEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环查找过程中，没有找到key相等的entry，且没有key过期的entry</span></span><br><span class="line">    <span class="comment">// 则新建一个entry放入entry表中</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存放元素数量+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 调用启发式清理， 且元素数量大于扩容阙值</span></span><br><span class="line">    <span class="comment">// 则调用rehash方法，该方法会进行key过期的entry清理工作，清理完成之后再判断是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码流程主要如下：</p><ol><li>首先获取<code>Entry</code>表，<code>Entry</code>表长度，通过<code>hashCode</code>计算下标，然后<code>for</code>循环<code>Entry</code>表。</li><li>如果循环查找过程中找到了<code>key</code>相等的<code>Entry</code>则更新<code>value</code>对应我们上面说的<strong>第二种情况</strong>。</li><li>如果循环查找过程找到了<code>key</code>为<code>null</code>的<code>Entry</code>，说明<code>key</code>过期了，替换过期元素，需要初始化探测式清理的其实位置，调用<code>replaceStaleEntry()</code>方法，这个方法我们下面再说，这个对应我们上面说的<strong>第四种情况。</strong></li><li><code>for</code>循环查找完毕，说明在查找过程中该下标对应的<code>Entry</code>为<code>null</code>，则在新建一个<code>Entry</code>放入该槽位，然后调用<strong>启发式清理</strong>工作。</li><li>如果<strong>启发式清理</strong>未清理任务数据，且<code>size</code>超过扩容阙值(2&#x2F;3)，则调用<code>rehash()</code>方法，该方法会先进行一次探测式清理，清理过期元素，清理完毕之后如果<code>size &gt;= threshold - threshold / 4 </code>，则会进行扩容操作。</li></ol><p>接下来看核心方法<code>replaceStaleEntry()</code>，该方法在查找过程中遇到<code>key = null</code>数据的时候会执行，该方法提供了替换过期数据的功能，可以对应上面说<strong>第四种情况</strong>来看，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取Entry表</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取Entry表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义探测式清理起始位置 slotToExpunge = staleSlot</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从staleSlot开始向前迭代查找是否有key=null的entry</span></span><br><span class="line">    <span class="comment">// 如果有则更新slotToExpunge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// staleSlot开始向后循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查找到了key相等entry</span></span><br><span class="line">        <span class="comment">// 则替换staleSlot和i的位置，且更新value的值</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 替换staleSlot和i的位置</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            <span class="comment">// 更新value值</span></span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果slotToExpunge == staleSlot，说明向前循环的没有查找到key过期的entry</span></span><br><span class="line">            <span class="comment">// 更新slotToExpunge值</span></span><br><span class="line">            <span class="comment">// 则会调用启动式过期清理，先会进行一遍过期元素探测操作</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到了key为null 且向前循环的没有查找到key过期的entry</span></span><br><span class="line">        <span class="comment">// 则更新slotToExpunge</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明没有找到k == key的数据，且碰到Entry为null的数据</span></span><br><span class="line">    <span class="comment">// 则将数据放入该槽位</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slotToExpunge != staleSlot 说明从staleSlot开始向前迭代查找有key=null的entry</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">// 启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理</span></span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码主要流程如下：</p><ol><li>首先获取<code>Entry</code>表，<code>Entry</code>表长度，定义探测式清理起始位置 <code>slotToExpunge = staleSlot</code>。</li><li>从staleSlot开始向前迭代查找是否有<code>key=null</code>的<code>entry</code>，如果有则更新<code>slotToExpunge</code>。</li><li><code>staleSlot</code>开始向后循环，如果查找到了<code>key</code>相等<code>entry</code>，则替换<code>staleSlot</code>和<code>i</code>的位置，且更新<code>value</code>的值，然后判断<code>slotToExpunge == staleSlot</code>，说明向前循环的没有查找到<code>key</code>过期的<code>entry</code>， 然后更新<code>slotToExpunge</code>值，则会调用启动式过期清理，先会进行一遍过期元素探测操作，如果发现了有过期的数据就会先进行探测式清理。</li><li>如果找到了<code>key</code>为<code>null </code>且向前循环的没有查找到<code>key</code>过期的<code>entry</code>，则更新<code>slotToExpunge</code>。</li><li>循环结束，方法没有退出，说明没有找到<code>k == key</code>的数据，且碰到<code>Entry=null</code>的数据，则将数据放入该槽位。</li><li>最后判断<code>slotToExpunge != staleSlot</code>，说明从<code>staleSlot</code>开始向前迭代查找有<code>key=null</code>的<code>entry</code>，则调用启动式清理，在启动式清理之前，先会进行一次过期元素探测，如果发现了有过期的数据就会先进行探测式清理。</li></ol><p><code>ThreadLocalMap.set()</code>方法到这里已经解析完毕，我们接下来看看<code>ThreadLocalMap</code>过期 key 的启发式清理流程。</p><h4 id="ThreadLocalMap过期-key-的启发式清理流程"><a href="#ThreadLocalMap过期-key-的启发式清理流程" class="headerlink" title="ThreadLocalMap过期 key 的启发式清理流程"></a>ThreadLocalMap过期 key 的启发式清理流程</h4><p>上面我们提到的<code>ThreadLocalMap</code>两种过期<code>key</code>数据清理方式：<strong>探测式清理</strong>和<strong>启发式清理</strong>。</p><h5 id="探测式清理"><a href="#探测式清理" class="headerlink" title="探测式清理"></a>探测式清理</h5><p>探测式清理方法<code>expungeStaleEntry</code>，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的<code>Entry</code>设置为<code>null</code>，遍历过程如果遇到未过期的数据则会将此数据<code>rehash</code>后重新在<code>table</code>数组中定位，如果定位的位置已经有了元素，则会将未过期的数据放在最靠近此位置的<code>Entry = null</code>的桶中，使<code>rehash</code>后的<code>Entry</code>数据距离正确的桶位置更近一点。这种优化会提高整个散列表查询性能。</p><p>如下图所示：</p><p><img src="https://qtspace.cn/contentimg/35.jpg"></p><p>探测式清理迭代的过程中遇到了空的槽位，则终止探测，这样子一轮探测式清理就工作完成，我们看看具体的源码实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// staleSlot探测式清理起始位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将起始位置置空</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 元素数量减1</span></span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新迭代散列，直到发现空槽</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"><span class="comment">// 如果key过期，则清空元素，数量减1</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果key没有过期，则重新计算hash，重新获取下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果当前下标存在值，则寻找离冲突key所在entry最近的空槽</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// i位置槽置空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 寻找离冲突key所在entry最近的空槽，放入该槽</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启发式清理"><a href="#启发式清理" class="headerlink" title="启发式清理"></a>启发式清理</h5><p>启发式清理被作者定义为：<strong>Heuristically scan some cells looking for stale entries</strong></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len); <span class="comment">// 从下一个位置开始</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="comment">// 遍历到key==null的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len; <span class="comment">// 重置n</span></span><br><span class="line">            removed = <span class="literal">true</span>; <span class="comment">// 标志有清理元素</span></span><br><span class="line">            i = expungeStaleEntry(i); <span class="comment">// 清理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>); <span class="comment">// log(n) 限制--对数次</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>i</code>的下一个位置判断元素是否需要清除，如果遇到<code>key==null</code>的元素则会重置<code>n</code>，需要清除且更新<code>i</code>的值，判断且清除完毕之后，<code>n = n &gt;&gt;&gt; 1</code>直到<code>n = 0</code>则退出清理。</p><h4 id="ThreadLocalMap-get-方法详解"><a href="#ThreadLocalMap-get-方法详解" class="headerlink" title="ThreadLocalMap.get()方法详解"></a>ThreadLocalMap.get()方法详解</h4><p>上面已经说完了<code>set()</code>方法的源码，接下来我们看看<code>get()</code>方法的操作原理，主要包含两种情况，一种是<code>hash</code>计算出下标，该下标对应的<code>Entry.key</code>和我们传入的<code>key</code>相等的情况，另外一种就是不相等的情况。</p><p><strong>相等情况：</strong>相等情况处理很简单，直接返回<code>value</code>，如下图：</p><p><img src="https://qtspace.cn/contentimg/36.jpg"></p><p>上图中比如<code>get(ThreadLocal1)</code>计算下标为4，且4存在<code>Entry</code>，且<code>key</code>相等，则直接返回<code>value = 11</code>。</p><p><strong>不相等情况</strong>：不相等情况，先看图：</p><p>以<code>get(ThreadLocal2)</code>为例计算下标为4，且4存在<code>Entry</code>，但<code>key</code>相等，这个时候则为往后迭代寻找<code>key</code>相等的元素，如果寻找过程中发现了有<code>key = null</code>的元素则回进行探测式清理操作。如下图：</p><p><img src="https://qtspace.cn/contentimg/37.jpg"></p><p>迭代到<code>index=5</code>的数据时，此时<code>Entry.key=null</code>，触发一次探测式数据回收操作，执行<code>expungeStaleEntry()</code>方法，执行完后，<code>index 5,8</code>的数据都会被回收，而<code>index 6,7</code>的数据都会前移，此时继续往后迭代，到<code>index = 6</code>的时候即找到了<code>key</code>值相等的<code>Entry</code>数据，如下图：</p><p><img src="https://qtspace.cn/contentimg/38.jpg"></p><p><code>ThreadLocalMap.get()</code>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到的话，则调用setInitialValue()方法设置null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">// key相等直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// key不相等调用getEntryAfterMiss()方法</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代往后查找key相等的entry</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 遇到key=null的entry，先进行探测式清理工作</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="type">else</span></span><br><span class="line">            <span class="variable">i</span> <span class="operator">=</span> nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadLocalMap的扩容机制"><a href="#ThreadLocalMap的扩容机制" class="headerlink" title="ThreadLocalMap的扩容机制"></a>ThreadLocalMap的扩容机制</h4><p>在<code>ThreadLocalMap.set()</code>方法最后，如果执行完启发式清理工作之后，未清理任何数据，且当前散列数组中元素已经超过扩容阙值<code>len*2/3</code>，则执行<code>rehash()</code>逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    rehash();</span><br></pre></td></tr></table></figure><p><code>rehash()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先进行探测式清理工作</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//探测式清理完毕之后 如果size &gt;= threshold - threshold / 4</span></span><br><span class="line">    <span class="comment">// 也就是size &gt;= threshold * 3/4，也就是 size &gt;= len * 1/2，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">expungeStaleEntries</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rehash()</code>方法源码流程如下：</p><ol><li>首先进行探测式清理工作</li><li>如果探测式清理工作完毕之后，如果<code>size &gt;= threshold - threshold / 4</code>， 也就是<code>size &gt;= threshold * 3/4</code>，也就是 <code>size &gt;= len * 1/2</code>，则调用<code>resize()</code>扩容。</li></ol><p>扩容方法<code>resize()</code>方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法执行之后<code>tab</code>的大小为原先的两倍<code>oldLen * 2</code>，然后变量老的散列表，重新计算<code>hash</code>位置，然后放到新的散列表中，如果出现<code>hash</code>冲突则往后寻找最近的<code>entry</code>为<code>null</code>的槽位放入，扩容完成之后，重新计算扩容阙值。</p><h3 id="六、ThreadLocal-get-方法源码详解"><a href="#六、ThreadLocal-get-方法源码详解" class="headerlink" title="六、ThreadLocal.get()方法源码详解"></a>六、ThreadLocal.get()方法源码详解</h3><p><code>ThreadLcoal.get()</code>方法源码详解已经在<code>ThreadLocalMap.get()</code>方法源码解析中完成。</p><h3 id="七、ThreadLocal-remove-方法源码详解"><a href="#七、ThreadLocal-remove-方法源码详解" class="headerlink" title="七、ThreadLocal.remove()方法源码详解"></a>七、ThreadLocal.remove()方法源码详解</h3><p><code>ThreadLocal.remove()</code>方法流程比较简单，我们结合源码来说明，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从hash获取的下标开始，寻找key相等的entry元素清除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal.remove()</code>核心是调用<code>ThreadLocalMap.remove()</code>方法，流程如下：</p><ol><li>通过<code>hash</code>计算下标。</li><li>从散列表该下标开始往后查<code>key</code>相等的元素，如果找到则做清除操作，引用置为<code>null</code>，<code>GC</code>的时候<code>key</code>就会置为<code>null</code>，然后执行探测式清理处理。</li></ol><h3 id="八、InheritableThreadLocal"><a href="#八、InheritableThreadLocal" class="headerlink" title="八、InheritableThreadLocal"></a>八、InheritableThreadLocal</h3><p>我们在使用<code>ThreadLocal</code>的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。</p><p>为了解决这个问题，<code>JDK</code>中还有一个<code>InheritableThreadLocal</code>类，我们来看个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;String&gt; ThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>&lt;&gt;();</span><br><span class="line">    ThreadLocal.set(<span class="string">&quot;父类数据:threadLocal&quot;</span>);</span><br><span class="line">    inheritableThreadLocal.set(<span class="string">&quot;父类数据:inheritableThreadLocal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程获取父类ThreadLocal数据：&quot;</span> + ThreadLocal.get());</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程获取父类inheritableThreadLocal数据：&quot;</span> + inheritableThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程获取父类ThreadLocal数据：null</span><br><span class="line">子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal</span><br></pre></td></tr></table></figure><p>实现原理是子线程通过父线程中调用<code>new Thread()</code>方法创建子线程，<code>Thread#init</code>方法在<code>Thread</code>的构造方法中被调用，<code>init()</code>方法中拷贝父线程数据源到子线程中，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                      <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                      <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但<code>InheritableThreadLocal</code>仍然有缺陷，一般我们做异步化处理都是使用的线程池，而<code>InheritableThreadLocal</code>是在<code>new Thread</code>中的<code>init()</code>方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。</p><p>当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个<code>TransmittableThreadLocal</code>组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。</p><blockquote><p>参考：<a href="https://javaguide.cn/java/concurrent/threadlocal.html">https://javaguide.cn/java/concurrent/threadlocal.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、ThreadLocal简介&quot;&gt;&lt;a href=&quot;#一、ThreadLocal简介&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    
    <category term="ThreadLocal" scheme="https://qtspace.cn/tags/ThreadLocal/"/>
    
    <category term="ThreadLocalMap" scheme="https://qtspace.cn/tags/ThreadLocalMap/"/>
    
  </entry>
  
  <entry>
    <title>Java锁(三)：Semaphore共享锁详解</title>
    <link href="https://qtspace.cn/2022/03/29/java-lock-semaphore/"/>
    <id>https://qtspace.cn/2022/03/29/java-lock-semaphore/</id>
    <published>2022-03-28T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:07.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、基于AQS实现的锁"><a href="#一、基于AQS实现的锁" class="headerlink" title="一、基于AQS实现的锁"></a>一、基于AQS实现的锁</h3><p>AQS（AbstractQueuedSynchronizer） 是Java并发包JUC中非常重要的一个类，大部分锁都是基于AQS实现的，主要实现的类如下：</p><ul><li><p><code>ReentrantLock</code>：可重入锁，独占锁，实现了公平锁和非公平锁，这个是上篇内容介绍的类，也是最常用类，通常会和<code>synchronized</code>作比较。</p></li><li><p><code>ReentrantReadWriteLock</code>：读写锁，可共享也可独占锁，读是共享锁，写是独占锁，也实现了公平锁和非公平锁。</p></li><li><p><code>Semaphore</code>：信号锁，共享锁，也实现了公平锁和非公平锁，主要同于控制流量，比如：数据库连接池给你分配10个链接，来一个分配一个，如果10个都分配完了且没有释放那就等待释放。</p></li><li><p><code>CountDownLatch</code>：闭锁，共享锁，也实现了公平锁和非公平锁，Latch门闩的意思，比如：说四个人一个漂流艇，坐满了就推下水。</p></li><li></li></ul><h3 id="二、Semaphore"><a href="#二、Semaphore" class="headerlink" title="二、Semaphore"></a>二、Semaphore</h3><h4 id="Semaphore是什么"><a href="#Semaphore是什么" class="headerlink" title="Semaphore是什么"></a>Semaphore是什么</h4><p>上面已经介绍了<code>Semaphore</code>，基于AQS实现的信号锁，是共享锁，实现了公平锁和非公平锁。可以用来控制同时访问特定资源的线程数，通过协调各个线程以保证合理的使用资源。</p><h4 id="Semaphore使用场景"><a href="#Semaphore使用场景" class="headerlink" title="Semaphore使用场景"></a>Semaphore使用场景</h4><p>通常用于资源有明确访问数量限制的场景，常用于限流。</p><p>比如：数据库连接池，同时进行连接的线程数量有限制，连接不能超过一定的数量，当连接达到了限制的数量后，后面的线程只能排队等待前面的线程释放了数据库链接才能获取数据库链接。</p><p>比如：停车场场景，车位数量有限，同时只能听一定数量的车，当停满了之后外面的车只能等里面的车出来才能进去停车。</p><h4 id="Semaphore的常用方法"><a href="#Semaphore的常用方法" class="headerlink" title="Semaphore的常用方法"></a>Semaphore的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从信号锁获取获取一个锁，在获取到锁之前一直处理阻塞状态，除非线程被中断</span></span><br><span class="line">acquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从信号锁获取获取指定数量锁，在获取到锁之前一直处理阻塞状态，除非线程被中断</span></span><br><span class="line">acquire(<span class="type">int</span> permits);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从信号锁获取一个锁，在获取到锁之前线程一直处于阻塞状态（忽略中断）</span></span><br><span class="line">acquireUninterruptibly();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从信号锁获取锁，返回获取成功或者失败，不会阻塞线程</span></span><br><span class="line">tryAcquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试从信好锁获取锁，指定获取时间，在指定时间内没有获取到则超时返回，不会阻塞线程</span></span><br><span class="line">tryAcquire(<span class="type">long</span> timeount, TimeUnit unit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">release();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等待队列中是否还有等待线程</span></span><br><span class="line">hadQueuedThreads();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取等待队列里阻塞线程的数量</span></span><br><span class="line">getQueuedLength();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空锁，返回清空锁的数量</span></span><br><span class="line">drainPermits();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可用的锁的数量</span></span><br><span class="line">availabelPermits();</span><br></pre></td></tr></table></figure><h4 id="Semaphore实现原理"><a href="#Semaphore实现原理" class="headerlink" title="Semaphore实现原理"></a>Semaphore实现原理</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>Semaphore提供了两个构造方法，默认构造方法创建指定锁数量的非公平信号锁，另外一个构造方法多了一个指定是公平锁还是非公平锁的参数，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建指定数量锁的非公平信号锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建指定数量锁的公平/非公平信号锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(permits) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取锁过程"><a href="#获取锁过程" class="headerlink" title="获取锁过程"></a>获取锁过程</h5><h6 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h6><p><code>acquire()</code>是获取锁方法，调用了内部类同步器<code>Sync</code>继承了<code>AQS</code>实际调用<code>AQS</code>的<code>acquireSharedInterruptibly()</code>核心，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedExcetion &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加JDK中，与锁相关的方法，<code>Interruptibly</code>表示可中断，也就是可中断锁。可中断锁的意思是<strong>线程在等待获取锁的过程中是可以被中断的</strong>，换言之，<strong>线程在等待锁的过程中可以响应中断。</strong></p><h6 id="acquireSharedInterruptiby"><a href="#acquireSharedInterruptiby" class="headerlink" title="acquireSharedInterruptiby"></a>acquireSharedInterruptiby</h6><p><code>acquireSharedInterruptibly</code>方法是获取可中断锁，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">// 检测线程的中断状态，如果已经被中断了，就响应中断，该方法会清除线程中的中断标识</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 尝试获取锁，arg为锁的数量</span></span><br><span class="line">    <span class="comment">// 当锁被获取完了之后，则为当前线程创建一个节点加入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireSharedInterruptibly</code>方法首先会判断当前线程的中断状态如果是中断状态则响应中断，抛异常，然后调用<code>tryAcquireShared()</code>方法获取锁，如果锁被获取完了就为当前线程创建一个节点加入等待队列。</p><h6 id="tryAcquireShared"><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h6><p><code>tryAcquireShared()</code>是<code>AQS</code>定义的一个模版方法，具体由子类实现，<code>Semaphore</code>也实现了公平锁和非公平锁，两种锁大同小异，我们具体来看一下公平锁的具体实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 判断是否有排在自己前面的线程，如果有直接返回-1，进入阻塞状态</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取同步状态的值(当前可用锁数量)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 剩余锁数量， 可用的-申请的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 如果剩余的锁小于0, 或者设置成功就返回，如果设置失败继续循环设置</span></span><br><span class="line">        <span class="comment">// 如果剩余锁数量小于0，返回负数，表示获取锁失败</span></span><br><span class="line">        <span class="comment">// 如果剩余锁数量大于0，且设置状态成功，表示获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared()</code>通过<strong>自旋+CAS</strong>的方式获取锁和保证线程安全。</p><h6 id="doAcquireSharedInterruptibly"><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h6><p><code>doAcquireSharedInterruptibly()</code>方法在公平锁的时候如果当前线程前面有等待线程或者锁被获取完了之后，当前线程需要进入等待状态时会被调用，用于为当前线程创建节点并加入等待队列，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 为当前线程创建共享模式节点加入队列结尾</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 操作失败标记</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前一节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 如果前一节点是头节点, 则尝试获取锁</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果获取成功，设置头节点和共享模式传播</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>;</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果前一节点不是头节点或者没有获取到锁</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire方法判断当前线程是否需要被阻塞</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并检测线程是否被中断，如果被中断抛错</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 自旋异常退出 取消线程获取锁</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="获取锁过程总结"><a href="#获取锁过程总结" class="headerlink" title="获取锁过程总结"></a>获取锁过程总结</h6><ol><li>首先调用<code>Semaphore.acquire()</code>方法获取令牌，该方法调用内置同步器<code>Sync.acquireSharedInterruptibly()</code>方法，该同步器继承<code>AQS</code>实际调用的是<code>AQS</code>的<code>acquireSharedInterruptibly()</code>方法。</li><li><code>acquireSharedInterruptibly()</code>方法首先判断当前线程是否被中断，如果中断了就抛<code>InterruptedException</code>异常，如果没有被中单，就调用<code>tryAcquireShared()</code>方法尝试获取锁。</li><li><code>tryAcquireShared()</code>方法<code>AQS</code>只是定了一个模版方法由子类实现，<code>Semaphore.Sync</code>同步器提供了两种实现，分别是<code>FairSync</code>（公平锁）和<code>NonfairSync</code>（非公平锁），这两种锁实现差不多，公平锁就是多一个<code>hasQueuedPredecessor()</code>方法判断是否有排在自己前面的线程，如果有则返回-1。</li><li><code>tryAcquireShared()</code>方法通过自旋或许锁，先获取当前可用锁，减去需要获取的锁获取到剩余锁，如果剩余锁小于0直接返回，表示获取失败，否则通过CAS去获取锁，成功获取返回成功，失败获取返回失败。</li><li><code>tryAcquireShared()</code>如果获取锁失败，就要调用<code>doAcquireSharedInterruptibly()</code>方法用于为当前线程创建节点加入等待队列，该方法首先创建共享模式的节点加入队列，然后自旋，判断当前节点是不是头节点，如果是头节点也尝试获取锁，获取成功的话设置头节点并成功返回，如果获取失败则会调用<code>shouldParkAfterFailedAcquire()</code>判断当前线程是否需要等待，如果需要等待然后调用<code>parkAndCheckInterrupt()</code>方法阻塞线程并判断线程是否中断，如果中断则抛错，如果没有中断就阻塞再通过自旋获取锁。如果自旋异常退出，则调用<code>cancelAcquire()</code>方法取消线程获取锁。</li></ol><h5 id="释放锁过程"><a href="#释放锁过程" class="headerlink" title="释放锁过程"></a>释放锁过程</h5><h6 id="release"><a href="#release" class="headerlink" title="release"></a>release</h6><p><code>Semaphore.relese()</code>方法用于释放锁，释放一个锁，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 释放一个共享锁</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release()</code>方法调用<code>Semaphore.Sync</code>同步器的<code>releaseShared()</code>方法，该同步器继承与<code>AQS</code>实际调用的是<code>AQS.releaseShared()</code>方法。</p><h6 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h6><p><code>releaseShared()</code>方法释放指定数量的共享锁，释放成功之后会唤醒等待队列中的一个线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功，唤醒等待队列中的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="tryReleaseShared"><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h6><p><code>tryReleaseShared()</code>方法是<code>AQS</code>定义的模版方法由子类实现，调用了<code>Semaphore.tryReleaseShared()</code>，该方法通过自旋+CAS释放锁，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// 获取当前可用的锁数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 可用的+释放的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过CAS修改状态值释放锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h6><p><code>doReleaseShared()</code>方法用于释放锁成功之后唤醒等待队列中的线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将队列头节点赋值与节点h</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 如果节点不为null，且不等于尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// 得到h节点的状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果节点状态是Node.SIGNAL，就要唤醒节点h下一节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 设置节点h的状态为取消状态，如果失败就循环再试一次</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;    </span><br><span class="line">                <span class="comment">// 唤醒节点h下一节点线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果节点h状态为0，就设置ws的状态为PROPAGATE，说明下次循环的时候节点h应该无条件被传播</span></span><br><span class="line">            <span class="comment">// 在shouldParkAfterFailedAcquire方法中使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列中头节点发生变化就继续循环</span></span><br><span class="line">        <span class="comment">// 如果没有发生变化就跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="释放锁过程总结"><a href="#释放锁过程总结" class="headerlink" title="释放锁过程总结"></a>释放锁过程总结</h6><ol><li>首先调用<code>Semaphore.release()</code>方法释放锁，该方法调用同步器<code>Sync</code>的<code>releasShared()</code>方法，因为同步器继承与<code>AQS</code>所以实际调用的是<code>AQS.releaseShared()</code>方法。</li><li><code>AQS.releaseShared()</code>方法首先调用<code>tryReleaseShared()</code>方法尝试释放锁，该方法是<code>AQS</code>定义的模版方法，通过子类实现，调用的是<code>Semaphore.tryReleaseShared()</code>方法。</li><li><code>Semaphore.tryReleaseShared()</code>方法通过自旋+CAS释放锁，先获取当前的锁数量加上释放的锁数量，会判断超过判断，然后通过CAS修改锁的数量达到释放锁的目的。<code>tryReleaseShared()</code>释放锁成功之后，会调用<code>AQS.doReleaseShared()</code>唤醒等待队列中的线程。</li><li><code>AQS.doReleaseShared()</code>用于释放锁成功之后唤醒等待队列中的线程，也是通过自旋+CAS实现，首先获取头节点h，先判断节点h不为null且不是尾节点，得到节点h的状态，如果状态是<code>Node.SIGNAL</code>说明这个节点已经要被唤醒应该唤醒下一节点，通过CAS操作设置节点h状态为取消，然后调用<code>unparkSuccessor()</code>方法唤醒下一节点。如果节点h的状态为0，就设置状态为<code>PROPAGATE</code>说明下一次应该被无条件传播。如果队列中头节点发生变化就继续循环，没有发生变化就终止循环。</li></ol><h3 id="三、使用Semaphor实现停车场提示牌功能"><a href="#三、使用Semaphor实现停车场提示牌功能" class="headerlink" title="三、使用Semaphor实现停车场提示牌功能"></a>三、使用Semaphor实现停车场提示牌功能</h3><p>每个停车场入口都有一个提示牌，上面显示着停车场剩余的车位是多少，当剩余车位为0时，则不允许车辆进入停车场，直到停车场有车离开停车场，这是提示牌显示新的剩余车位数。</p><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><ol><li>停车场容纳量为10。</li><li>当一辆车进入停车场后，显示牌的剩余车位数响应的减1.</li><li>每有一辆车驶出停车场后，显示牌的剩余车位数响应的加1。</li><li>停车场剩余车位不足时，车辆只能在外面等待。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停车场同时容纳10辆车</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟15辆车同时停车</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;=====&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;车辆来到停车场&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (semaphore.availablePermits() == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 没有车位了</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;车位不足，请耐心等待，&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;车辆正在等待&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 获取车位停车</span></span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;成功进入停车场&quot;</span>);</span><br><span class="line">                        <span class="comment">//模拟车辆在停车场停留的时间</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="comment">//驶出停车场</span></span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;驶出停车场&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">=====Thread-0车辆来到停车场</span><br><span class="line">=====Thread-3车辆来到停车场</span><br><span class="line">Thread-3成功进入停车场</span><br><span class="line">=====Thread-1车辆来到停车场</span><br><span class="line">=====Thread-2车辆来到停车场</span><br><span class="line">Thread-1成功进入停车场</span><br><span class="line">=====Thread-5车辆来到停车场</span><br><span class="line">=====Thread-4车辆来到停车场</span><br><span class="line">Thread-0成功进入停车场</span><br><span class="line">=====Thread-7车辆来到停车场</span><br><span class="line">Thread-4成功进入停车场</span><br><span class="line">Thread-7成功进入停车场</span><br><span class="line">Thread-5成功进入停车场</span><br><span class="line">=====Thread-6车辆来到停车场</span><br><span class="line">Thread-2成功进入停车场</span><br><span class="line">Thread-6成功进入停车场</span><br><span class="line">=====Thread-8车辆来到停车场</span><br><span class="line">Thread-8成功进入停车场</span><br><span class="line">=====Thread-10车辆来到停车场</span><br><span class="line">Thread-10成功进入停车场</span><br><span class="line">=====Thread-9车辆来到停车场</span><br><span class="line">=====Thread-14车辆来到停车场</span><br><span class="line">车位不足，请耐心等待，Thread-14车辆正在等待</span><br><span class="line">=====Thread-12车辆来到停车场</span><br><span class="line">车位不足，请耐心等待，Thread-12车辆正在等待</span><br><span class="line">=====Thread-11车辆来到停车场</span><br><span class="line">车位不足，请耐心等待，Thread-11车辆正在等待</span><br><span class="line">=====Thread-13车辆来到停车场</span><br><span class="line">车位不足，请耐心等待，Thread-9车辆正在等待</span><br><span class="line">车位不足，请耐心等待，Thread-13车辆正在等待</span><br><span class="line">Thread-14成功进入停车场</span><br><span class="line">Thread-10驶出停车场</span><br><span class="line">Thread-2驶出停车场</span><br><span class="line">Thread-6驶出停车场</span><br><span class="line">Thread-11成功进入停车场</span><br><span class="line">Thread-7驶出停车场</span><br><span class="line">Thread-3驶出停车场</span><br><span class="line">Thread-9成功进入停车场</span><br><span class="line">Thread-13成功进入停车场</span><br><span class="line">Thread-1驶出停车场</span><br><span class="line">Thread-0驶出停车场</span><br><span class="line">Thread-4驶出停车场</span><br><span class="line">Thread-5驶出停车场</span><br><span class="line">Thread-8驶出停车场</span><br><span class="line">Thread-12成功进入停车场</span><br><span class="line">Thread-13驶出停车场</span><br><span class="line">Thread-9驶出停车场</span><br><span class="line">Thread-12驶出停车场</span><br><span class="line">Thread-14驶出停车场</span><br><span class="line">Thread-11驶出停车场</span><br></pre></td></tr></table></figure><p>从上面输出可以看出，当10个车位被停满了之后，再进来的5辆车进入等待状态直到有车驶出停车场，然后再停车，达到了我们预期的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、基于AQS实现的锁&quot;&gt;&lt;a href=&quot;#一、基于AQS实现的锁&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="JUC" scheme="https://qtspace.cn/categories/Java/JUC/"/>
    
    <category term="AQS" scheme="https://qtspace.cn/categories/Java/JUC/AQS/"/>
    
    
    <category term="AbstractQueuedSynchronizer" scheme="https://qtspace.cn/tags/AbstractQueuedSynchronizer/"/>
    
    <category term="Semaphore" scheme="https://qtspace.cn/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java锁(二)：AbstractQueuedSynchronizer、ReentrantLock详解</title>
    <link href="https://qtspace.cn/2022/03/27/java-lock-aqs-reentrantlock/"/>
    <id>https://qtspace.cn/2022/03/27/java-lock-aqs-reentrantlock/</id>
    <published>2022-03-26T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:03.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、AbstractQueuedSynchronizer简介"><a href="#一、AbstractQueuedSynchronizer简介" class="headerlink" title="一、AbstractQueuedSynchronizer简介"></a>一、AbstractQueuedSynchronizer简介</h3><p>AQS（AbstractQueuedSynchronizer）是并发容器JUC（java.util.concurrent）下locks包内的一个抽象类，是一个同步器，是用来构建锁或者其他同步组件的基础框架，内部维护了一个成员变量<code>state</code>表示同步状态，<code>state=0</code>表示线程未获取到锁，<code>state &gt; 0</code>表示获取到锁，<code>state &gt; 1</code>表示重入锁的数量，被 <code>volatile</code>修饰保证了可见性，通过CAS操作对其修改，内置维护了<code>FIFO</code>队列实现对未获取到锁的线程进行排队工作。</p><p><img src="https://qtspace.cn/contentimg/20.jpg"></p><h3 id="二、AbstractQueuedSynchronizer源码解析"><a href="#二、AbstractQueuedSynchronizer源码解析" class="headerlink" title="二、AbstractQueuedSynchronizer源码解析"></a>二、AbstractQueuedSynchronizer源码解析</h3><h4 id="核心成员变量"><a href="#核心成员变量" class="headerlink" title="核心成员变量"></a>核心成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁队列的头节点, 只能通过setHead方法修改</span></span><br><span class="line"><span class="comment">     * 如果head存在保证waitStatus状态不为CANCELLED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待获取锁队列的尾节点, 只能通过enq方法添加新的等待节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示锁的状态</span></span><br><span class="line"><span class="comment">     * state = 0 表示未锁定</span></span><br><span class="line"><span class="comment">     * state &gt; 0 表示已锁定</span></span><br><span class="line"><span class="comment">     * state &gt; 1 表示可重入锁, 获取锁的次数</span></span><br><span class="line"><span class="comment">     * volatile修饰保证了可见性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer主要有三个核心成员变量<code>state</code>、<code>head</code>、<code>tail</code></p><ul><li><code>state</code>：表示锁的状态， 等于0表示未锁定，大于0表示已锁定，大于1表示可重入锁，重入锁的次数。被<code>volatile</code>修饰保证了可见性。</li><li><code>head</code>：等待队列的头节点，除了初始化只能通过<code>setHead()</code>方法设置值，如果<code>head</code>存着能保证<code>waitStatus</code>状态不为<code>CANELLED</code>。</li><li><code>tail</code>：等待队列尾节点，只能通过<code>equ</code>添加新的等待节点。</li></ul><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p><code>AbstractQueuedSynchronizer</code>内部维护着<code>FIFO</code>队列，也就是<code>CLH</code>队列，这个队列的每一个元素都是一个<code>Node</code>，所以我们接下来要了解其他其内部类<code>Node</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点正在共享模式下等待的标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点正在独占模式下等待的标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus变量的可选值, 取消状态, 被取消的节点不参与锁竞争, 状态也不会被改变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus变量的可选值, 下一节点处于等待状态, 如果当前节点释放锁或者被取消, 会通知下一节点去运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus变量的可选值, 表示节点处于condition队列中, 正在等待被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus变量的可选值, 下一次acquireShared应该无条件传播</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点的等待状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上一节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取同步状态(锁)的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个condition队列的等待节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是共享模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">nextWaiter</span> <span class="operator">=</span>= SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取前一节点, 前一节点为null会抛异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法用于初始化头部或者共享模式标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于addWaiter方法, 设置下一个condition队列的等待节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于addConditionWaiter方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node (Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><p>JUC里面的工具类基本都是基础AQS实现的，比<code>ReentrantLock</code> 、<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>等，有的只支持独占锁，如<code>ReentrantLock#lock()</code>，有的支持共享锁，如<code>Semaphore</code>，从前文的Node类的定义也能看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点正在共享模式下等待的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点正在独占模式下等待的标记</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>AQS实现了两套加锁解锁的方式，那就是<strong>独占锁</strong>和<strong>共享锁</strong>。我们就从AQS最常用的类<code>ReentrantLock</code>来学习AQS的核心方法。</p><h3 id="三、ReentrantLock"><a href="#三、ReentrantLock" class="headerlink" title="三、ReentrantLock"></a>三、ReentrantLock</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>ReentrantLock</code>是基础AQS实现的一个可重入且独占式锁。内置了一个<code>Sync</code>同步器类实现了AQS，且支持公平锁和非公平锁，其实现类分别是<code>FairSync</code>和<code>NonfairSync</code>。</p><p><code>ReentrantLock</code>所有操作都是通过核心内部类<code>Sync</code>操作，由子类<code>FairSync</code>和<code>NonfairSync</code>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><h4 id="ReentrantLock加锁过程"><a href="#ReentrantLock加锁过程" class="headerlink" title="ReentrantLock加锁过程"></a>ReentrantLock加锁过程</h4><h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><p><code>lock()</code>就是加锁，该方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FairSync</code>和<code>NonfairSync</code>具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FairSync实现</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NofairSync实现 setExclusiveOwnerThread是父类AQS</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到非公平锁多了一个<code>compareAndSetState()</code>操作，通过CAS尝试修改锁状态<code>state</code>的值，如果修改成功设置当前线程以独占的方式获取了锁，修改失败执行的逻辑和公平锁一样。</p><p>公平锁和非公平锁获取独占锁的核心逻辑都是<code>acquire()</code>方法，接下来就看看这个方法。</p><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><p><code>acquire</code>该方法是父类<code>AbstractQueuedSynchronizer</code>定义的方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要调用<code>tryAcquire</code>方法尝试获取锁，成功返回true表示获取到了锁，如果失败就将线程封装成节点插入队尾。</p><h5 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h5><p><code>tryAcquire</code>方法在类<code>AbstractQueuedSynchronizer</code>没有直接实现，采用<strong>模版方法</strong>的设计模式交给子类实现，先看公平锁<code>FairSync</code>的实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取当前锁状态 state=0表示未锁定, state&gt;0表示已锁定</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 线程没有获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 没有比当前线程等待更久的线程了, 通过CAS的方式修改state</span></span><br><span class="line">            <span class="comment">// 如果成功则设置当前线程获取独占式锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 获取独占锁的线程就是当前线程, 表示重入</span></span><br><span class="line">        <span class="comment">// 重入锁的实现</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改state记录获取锁的次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码可以看出该方法就是独占的方式获取锁，获取成功后返回true，重入锁的逻辑也是在这里实现，主要通过修改state的值来记录获取锁的次数。</p><p>非公平锁的实现大同小异就是少了<code>!hasQueuedPredecessors()</code>的判断，因为是非公平锁嘛，所以不需要判断阻塞时间了。</p><p><code>acquire()</code>方法除了调用<code>tryAcquire()</code>方法外还调用了<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，这里有两个方法，我们先看<code>addWaiter()</code>方法。</p><h5 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h5><p>该方法相当于把当前线程封装成一个节点Node，并加入队列，这个方法我们在上面有写过，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment"> * 为当前线程和给定模式创建并设置尾节点</span></span><br><span class="line"><span class="comment"> * Node.EXCLUSIVE: 独占模式</span></span><br><span class="line"><span class="comment"> * Node.SHARED: 共享模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 为当前线程创建节点</span></span><br><span class="line">    <span class="type">Npde</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 获取尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 如果队列已经创建, 尝试快速添加尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快速添加失败, 则调用enq</span></span><br><span class="line">    enq(node);</span><br><span class="line">    retur node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h5><p>enq方法是将节点加入队列队尾，必要时要进行初始化，通过自旋+CAS的方式保证线程安全和插入成功。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts node into queue, initializing if necessary. See picture above</span></span><br><span class="line"><span class="comment">* 将节点插入队列，必要时进行初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// 获取尾节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 尾节点为null表示队列没有初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置头节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>())) &#123;</span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列已经初始化, 设置新添加节点的前一节点是队列的尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 设置尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">// 设置队列的尾节点的下一节点是新添加的节点, 新添加的节点就插入尾节点了</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出该方法就是往队列插入尾节点，通过自旋+CAS的方式，需要注意的是该方法返回的Node节点不是新插入的节点，而是新插入节点的前一节点。</p><p><code>enq()</code>方法中调用的<code>compareAndSetHead()</code>、<code>compareAndSetTail()</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过CAS设置head值, 只在enq方法调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetHead</span><span class="params">(Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.companreAndSwapObject(<span class="built_in">this</span>, headOffset, <span class="literal">null</span>, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过CAS函数设置tail值，仅仅在enq方法中调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="built_in">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h5><p><code>acquireQueued()</code>方法作用就是获取锁，如果没有获取到锁就让当前线程阻塞等待，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 想要获取锁的acquire方法，都会通过这个方法获取锁</span></span><br><span class="line"><span class="comment"> * 循环通过tryAcquire方法不断去获取锁，如果没有获取成功</span></span><br><span class="line"><span class="comment"> * 就有可能调用parkAndCheckInterrupt方法，让当前线程阻塞</span></span><br><span class="line"><span class="comment"> * 结果返回true，表示在线程等待的过程中，线程被中断了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 操作是否成功</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 表示线程在等待过程中是否被中断了</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前一节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 获取前一节点是头节点, 并且尝试获取锁成功</span></span><br><span class="line">            <span class="comment">// 那么当前线程不就需要阻塞状态, 继续执行</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置成头节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 不需要调用cancelAcquire方法</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点不是头节点或者没有获取到锁</span></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire方法用于判断当前线程是否需要被阻塞</span></span><br><span class="line">            <span class="comment">// 当p节点的状态是Node.SIGNAL时就会调用parkAndCheckInterrupt方法阻塞线程</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt方法用于阻塞线程并且检测线程是否被中断</span></span><br><span class="line">            <span class="comment">// 被阻塞的线程有两种被唤醒的方法：</span></span><br><span class="line">            <span class="comment">// 1. 在unparkSuccessor(Node node)方法，会唤醒被阻塞的node线程，返回false</span></span><br><span class="line">            <span class="comment">// 2. 当前线程被调用了interrupt方法，线程被唤醒，返回true</span></span><br><span class="line">            <span class="comment">// 在这里只是简单地将interrupted = true，没有跳出for的死循环，继续尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">               parkAndCheckInterrupt()) &#123;</span><br><span class="line">               interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// failed为true，表示发生异常非正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (failed) </span><br><span class="line">            <span class="comment">// 将当前节点状态设置成CANCELLED, 表示当前节点已经被取消, 不需要唤醒了</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireQueued</code>方法主要流程如下：</p><ol><li>通过<code>for(;;)</code>死循环自旋，直到node（当前）节点获取到锁。</li><li>获取当前节点的前一个节点p。</li><li>如果节点p是头节点，然后调用<code>tryAcquire()</code>尝试获取锁，如果获取成功就将node节点设置成头节点然后返回。</li><li>如果节点p不是投节点或者获取锁失败，调用<code>shouldParkAfterFaildAcquired()</code>方法来决定是否要阻塞当前线程。</li><li>如果要阻塞当前线程，调用<code>parkAndCheckInterrupt()</code>方法阻塞当前线程。</li><li>如果当前线程发生异常，非正常退出，调用<code>cancelAcquire()</code>方法将当前节点的状态设置成取消。</li></ol><h5 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h5><p><code>shouldParkAfterFailedAcquire()</code>用于判断当前线程是否需要阻塞，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根绝前一个节点pred的状态来判断当前线程是否需要被阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取前一节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SINGAL) &#123;</span><br><span class="line">        <span class="comment">// 如果前一节点pred的状态是Node.SINGAL, 说明当前线程需要被阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前一节点状态是Node.CANCELLED(大于0就是CANCELLED)</span></span><br><span class="line">        <span class="comment">// 表示前一节点所在线程已经被唤醒了, 要从队列中移除CANCELLED的节点</span></span><br><span class="line">        <span class="comment">// 所以从pred节点一直向前查找直到找到不是CANCELLED状态的节点, 并把该节点赋值给node的prev</span></span><br><span class="line">        <span class="comment">// 表示node节点的前一节点已经改变</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span>(pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此时前一节点pred的状态只能是0或者PROPAGATE, 不可能是CONDITION状态</span></span><br><span class="line">        <span class="comment">// CONDITION(这个是特殊状态，只在condition列表中节点中存在，CLH队列中不存在这个状态的节点)</span></span><br><span class="line">        <span class="comment">// 将前一个节点pred的状态设置成Node.SIGNAL, 这样子下一次循环时,就是直接阻塞当前线程</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是根绝前一个节点状态来判断当前线程是否需要被阻塞，前一节点的状态也是在这个方法中修改的，通过<code>compareAndSetWaitStatus()</code>方法。</p><p><code>shouldParkAfterFailedAcquire()</code>方法主要流程如下：</p><ol><li>如果前一节点状态是<code>Node.SIGNAL</code>，则直接返回<code>true</code>当前线程进入阻塞状态。</li><li>如果前一节点状态是<code>Node.CANCELLED</code>（大于0就是CANCELLED），表示前一个节点已经被唤醒了，要从队列中移动CANCELLED状态的节点，所以送pred节点一直向前查询不是CANCELLED状态的节点，并将该节点赋值成当前节点的前一节点，表示当前节点的前一节点发生变化，在<code>acquireQueued()</code>方法中进行下一次循环。</li><li>不是前面两种状态，只能是<code>0或者PROPAGATE</code>状态，修改前一节点的状态为<code>Node.SIGNAL</code>，下一次循环时阻塞当前线程。</li></ol><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h5><p>该方法用于阻塞当前线程并检测线程是否被中断，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞当前线程，线程被唤醒后返回当前线程中断状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 阻塞当前线程</span></span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 检测当前线程是否被中断（该方法会清除中断标识位）</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="cancelAcquire"><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h5><p><code>cancelAcquire()</code>方法在<code>acquireQueued()</code>方法异常的时候调用，用于将当前节点的状态设置成CANCELLED，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将node节点的状态设置成CANCELLED，表示node节点所在线程已取消，不需要唤醒了。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果node为null，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将获取锁节点的线程置空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过那些已取消的节点，在队列中找到在node节点前面的第一次状态不是已取消的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录pred原来的下一个节点，用于CAS函数更新时使用</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    <span class="comment">// 将node节点状态设置为已取消Node.CANCELLED;</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node节点是队列尾节点，那么就将pred节点设置为新的队列尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 并且设置pred节点的下一个节点next为null</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="加锁过程总结"><a href="#加锁过程总结" class="headerlink" title="加锁过程总结"></a>加锁过程总结</h5><p><a href="https://qtspace.cn/contentimg/21.png"></a></p><ol><li>首先调用<code>lock()</code>方法，这个方法有两个子类<code>FairSync</code>和<code>NofairSync</code>实现，表示公平锁和非公平锁，两个类的不同就是<code>NofairSync</code>会直接调用<code>compareAndSetStaus()</code>方法修改加锁状态，如果成功当前线程获取到锁。</li><li>然后调用父类<code>AbstractQueuedSynchronized</code>的<code>acquire()</code>方法获取锁。</li><li><code>acquire()</code>方法调用<code>tryAcquire()</code>方法尝试获取锁，<code>tryAcquire()</code>由子类<code>FairSync</code>和<code>NofairSync</code>实现分别调用<code>fairTryAcquire()</code>和<code>nonfairTryAcquire()</code>方法尝试获取锁。这两个方法里面实现了重入锁的逻辑，如果当前锁状态是未获取到锁，则调用CAS设置锁状态，如果是获取到锁状态则会判断获取锁的线程是否是当前线程，如果是则是重入锁的逻辑记录当前线程获取锁的次数。</li><li>如果<code>tryAcquire()</code>方法调用获取锁失败，则会调用<code>acquireQueued()</code>方法再获取锁或者进入阻塞状态，<code>acquireQueued()</code>方法首先调用了<code>addWaiter()</code>方法用于将当前线程封装成一个节点加入队列队尾，然后再调用<code>acquireQueued()</code>方法获取锁或者进入阻塞状态，<code>acquireQueued()</code>方法会通过自旋的方式根绝当前节点状态判断是否进入阻塞状态。当别的线程释放锁的时候，可能唤醒这个线程，再调用<code>tryAcquire()</code>方法获取锁。</li><li>如果发生异常，将当前节点状态设置成CANCELLED。</li></ol><h4 id="ReentrantLock释放锁过程"><a href="#ReentrantLock释放锁过程" class="headerlink" title="ReentrantLock释放锁过程"></a>ReentrantLock释放锁过程</h4><h5 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h5><p>调用<code>unlock()</code>方法释放锁，然后调用<code>release()</code>方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p><code>release</code>是<code>AbstactQueuedSynchronized</code>定义的方法用于释放锁，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在独占锁模式下, 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用tryRelease方法尝试释放锁, 由子类实现</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">//尝试释放锁成功 获取头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 如果头节点不为null且状态不为取消状态, 调用unparkSuccessor唤醒被阻塞的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release()</code>释放锁流程如下：</p><ol><li>调用<code>tryRelease()</code>方法尝试释放锁，返回true表示释放锁成功，返回false表示还持有锁资源。</li><li>如果释放锁成功了，且头节点不为null，就要唤醒被阻塞的线程，调用<code>unparkSuccessor()</code>方法唤醒一个等待的线程。</li></ol><h5 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h5><p><code>tryRelease</code>尝试释放锁方法是有子类实现的，下面是<code>ReentrantLock</code>中<code>Sync</code>的<code>tryRelease()</code>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// c表示新的锁状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程不是获取独占锁的线程抛错</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 是否可以释放锁</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果新的锁状态=0表示可以释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 获取独占锁的线程置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁状态设置成未锁定</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryRelease()</code>尝试释放锁流程如下：</p><ol><li>首先获取新的锁状态</li><li>判断当前线程是否是获取独占锁的线程，如果不是抛异常。</li><li>如果新的锁状态是未锁定状态，获取独占锁的线程置为null，新的锁状态置为未锁定。</li></ol><h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><p><code>unparkSuccessor()</code>方法用于唤醒node节点下一节点非取消状态的节点所在线程，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒node节点下一节点非取消状态的节点所在线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取node节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态小于0, 就将状态置为0, 表示这个node节点已经完成了</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取节点下一节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 如果下一节点为null, 或者下一节点状态为取消状态, 就要寻找下一个非取消状态的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 先将s设置成null, s不是非取消状态的节点</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t!= node; t = t.prev)</span><br><span class="line">            <span class="comment">//因为是从后向前遍历，所以不断覆盖找到的值，这样才能得到node节点后下一个非取消状态的节点</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">        <span class="comment">// 如果s不为null，表示存在非取消状态的节点,那么调用LockSupport.unpark方法唤醒这个节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unparkSuccessor()</code>方法唤醒node节点的下一个非取消状态的节点所在线程流程如下：</p><ol><li>先将node节点的状态设置为0。</li><li>寻找下一个状态不为取消的节点s。</li><li>如果节点s不为null，调用<code>LockSupport.unpark()</code>方法唤醒s所在线程。</li></ol><h5 id="释放锁过程总结"><a href="#释放锁过程总结" class="headerlink" title="释放锁过程总结"></a>释放锁过程总结</h5><ol><li>先调用<code>tryRelease()</code>方法尝试释放当前持有的锁资源。</li><li>如果成功释放了锁资源，则调用<code>unparkSuccessor()</code>方法去唤醒一个等待锁的线程。</li></ol><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><p><a href="https://qtspace.cn/contentimg/22.png"></a></p><p>到这里<code>ReentrantLock</code>加锁释放锁的过程已经学习完毕，<code>ReentrantLock</code>是基于AQS实现的<strong>独占式锁</strong>，内部维护了一个<code>FIFO队列</code>实现未获取到锁的线程进行排队工作， <code>ReentrantLock</code>内部有<code>FairSync</code>（公平锁）和<code>NonfairSync</code>（非公平锁）两种实现，通过调用<code>lock()</code>方法加锁，调用<code>unlock()</code>方法解锁。</p><h4 id="五、自己实现一个可重入的独占锁"><a href="#五、自己实现一个可重入的独占锁" class="headerlink" title="五、自己实现一个可重入的独占锁"></a>五、自己实现一个可重入的独占锁</h4><p>通过继承<code>AbstractQueuedSynchronizer </code>类重写<code>tryAcquire()</code>和<code>tryRelease()</code>方法实现自定义的可重入独占锁。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLock</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取当前锁状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// 如果锁状态为0, 表示当前锁是空闲的</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用CAS原子操作设置锁状态</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 如果设置成功, 将当前线程设置为获取独占锁的线程</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断当前线程是不是获取独占锁的线程, 因为可能重入锁</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重入锁实现逻辑, 记录获取锁的次数</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)&#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AQSTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">newThread</span><span class="params">(SyncLock syncLock, String name, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() +</span><br><span class="line">                        <span class="string">&quot;开始运行, 准备获取锁。&quot;</span>);</span><br><span class="line">                syncLock.acquire(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;, 在run方法获取了锁。&quot;</span>);</span><br><span class="line">                    lockAgain();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(time);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 在run方法中释放了锁。&quot;</span>);</span><br><span class="line">                    syncLock.release(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lockAgain</span><span class="params">()</span> &#123;</span><br><span class="line">                syncLock.acquire(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;, 在lockAgain方法获取了锁。&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; 在lockAgain方法中释放了锁。&quot;</span>);</span><br><span class="line">                    syncLock.release(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, name).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncLock</span> <span class="variable">syncLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncLock</span>();</span><br><span class="line">        newThread(syncLock, <span class="string">&quot;t1111&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        newThread(syncLock, <span class="string">&quot;t2222&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        newThread(syncLock, <span class="string">&quot;t3333&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        newThread(syncLock, <span class="string">&quot;t4444&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码测试结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">线程t1111开始运行, 准备获取锁。</span><br><span class="line">线程t2222开始运行, 准备获取锁。</span><br><span class="line">线程t1111, 在run方法获取了锁。</span><br><span class="line">线程t1111, 在lockAgain方法获取了锁。</span><br><span class="line">线程t4444开始运行, 准备获取锁。</span><br><span class="line">线程t3333开始运行, 准备获取锁。</span><br><span class="line">线程t1111 在lockAgain方法中释放了锁。</span><br><span class="line">线程t1111 在run方法中释放了锁。</span><br><span class="line">线程t2222, 在run方法获取了锁。</span><br><span class="line">线程t2222, 在lockAgain方法获取了锁。</span><br><span class="line">线程t2222 在lockAgain方法中释放了锁。</span><br><span class="line">线程t2222 在run方法中释放了锁。</span><br><span class="line">线程t4444, 在run方法获取了锁。</span><br><span class="line">线程t4444, 在lockAgain方法获取了锁。</span><br><span class="line">线程t4444 在lockAgain方法中释放了锁。</span><br><span class="line">线程t4444 在run方法中释放了锁。</span><br><span class="line">线程t3333, 在run方法获取了锁。</span><br><span class="line">线程t3333, 在lockAgain方法获取了锁。</span><br><span class="line">线程t3333 在lockAgain方法中释放了锁。</span><br><span class="line">线程t3333 在run方法中释放了锁。</span><br></pre></td></tr></table></figure><h4 id="六、ReentrentLock和synchronized的比较"><a href="#六、ReentrentLock和synchronized的比较" class="headerlink" title="六、ReentrentLock和synchronized的比较"></a>六、ReentrentLock和synchronized的比较</h4><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><ul><li>都是加锁方式同步</li><li>都是重入锁。</li><li>都是通过阻塞的方式实现同步。</li></ul><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul><li>原始构成：<code>synchronized</code>是java语言的关键字，是原生语法层面的互斥，由JVM实现，而<code>ReentrentLock</code>是JDK1.5之后提供的API层面的互斥锁。</li><li>实现：<code>synchronized</code>是通过JVM实现加锁解锁，而<code>ReentrentLock</code>是API层面的加锁解锁，需要手动解锁。</li><li>代码编写：<code>synchronized</code>不需要手动释放锁，修饰方法或者代码块，而<code>ReentrentLock</code>必须手动释放锁，如果没有释放锁可能造成死锁现象。需要<code>lock()</code>和<code>unlock()</code>方法配合<code>try/finally</code>语句块完成。</li><li>灵活性：<code>synchronized</code>只能用于修饰方法或者代码块，灵活性低，而<code>ReentrentLock</code>是方法调用可以跨方法，灵活性高。</li><li>是否等待可中断：<code>synchronized</code>不可中断，除非抛出异常，而<code>ReentrentLock</code>是可以中断的，如果持有锁的线程长期不释放锁，正在等待的线程可以选择放弃等待，通过设置超时时间方法。</li><li>是否公平锁：<code>synchronized</code>是不公平锁，而<code>ReentrentLock</code>是可公平锁也可不公平锁。</li><li>实现原理：<code>synchronized</code>是通过编译，会在同步代码块前后分别生成<code>monitorenter</code>和<code>monitorexit</code>两个指令实现同步，在执行<code>monitorenter</code>的指令时会尝试获取锁，获取锁成功会通过计数器+1，执行完毕之后会执行<code>monitorexit</code>执行计数器-1，当计数器为0时释放锁，如果获取锁失败就会进入阻塞状态，而<code>ReentrentLock</code>是通过<code>CAS + CLH队列</code>实现，通过<code>CAS</code>原子性操作实现对锁状态<code>state</code>的修改，通过<code>CLH队列</code>实现对未获取到锁的线程进行排队工作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、AbstractQueuedSynchronizer简介&quot;&gt;&lt;a href=&quot;#一、AbstractQ</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="JUC" scheme="https://qtspace.cn/categories/Java/JUC/"/>
    
    <category term="AQS" scheme="https://qtspace.cn/categories/Java/JUC/AQS/"/>
    
    
    <category term="AbstractQueuedSynchronizer" scheme="https://qtspace.cn/tags/AbstractQueuedSynchronizer/"/>
    
    <category term="ReentrantLock" scheme="https://qtspace.cn/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>Java锁(一)：volatile、synchronized详解</title>
    <link href="https://qtspace.cn/2022/03/26/java-lock-volatile-synchronized/"/>
    <id>https://qtspace.cn/2022/03/26/java-lock-volatile-synchronized/</id>
    <published>2022-03-25T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:11.833Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、锁的基础知识"><a href="#一、锁的基础知识" class="headerlink" title="一、锁的基础知识"></a>一、锁的基础知识</h3><h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><p>锁从客观上分为悲观锁和乐观锁。</p><ul><li>乐观锁：乐观锁是一种乐观思想，认为写少读多，遇到并发写的可能性比较低，读数据的时候认为别人不会修改，所以读的时候不会上锁，但是在写的时候会判断一下在此期间有没有别人去更新这个数据，采取的是先读取当前版本号，然后加锁操作，写完的时候读取最新版本号做记录的版本号做比较一样则成功，如果失败则重复读-比较-写的操作。Java中的乐观锁基本都是通过<code>CAS</code>操作实现的，<code>java.util.concurrent.atomic</code>包下的原子变量。<code>CAS(compare and swap)比较交换</code>是一种更新的原子操作，比较当前值和传入值是否一样，一样则更新，否则则失败。</li><li>悲观锁：悲观锁就是悲观思想，认为写多且遇到并发性的可能性高，每次拿数据的时候都认为别人为修改，所以每次读写的时候都会上锁，这样别人想读写数据的时候都会block(阻塞)知道拿到锁。Java中悲观锁就是<code>syschronized</code>，<code>AQS</code>框架下的锁则是先尝试<code>CAS</code>乐观锁获取锁，如果获取不到，才会转为悲观锁，如<code>ReentrantLock</code>。</li></ul><h4 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h4><p>在Java中主要有两种锁加锁机制：</p><ul><li><code>syschronized</code>关键字修饰</li><li><code>java.util.concurrent.Lock</code>，Lock是一个接口，有很多实现类比如<code>ReentrantLock</code>。</li></ul><h3 id="二、volatile"><a href="#二、volatile" class="headerlink" title="二、volatile"></a>二、volatile</h3><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span>  <span class="type">VT</span> <span class="variable">vt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VT</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(vt);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123; &#125;</span><br><span class="line">                vt.sign = <span class="literal">true</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;vt.sign = true 通知 while (!sign) 结束！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread01.start();</span><br><span class="line">        thread02.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VT</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!sign) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你坏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是两个线程同时操作一个变量，程序希望当<code>sign</code>在线程Thread01被操作<code>vt.sign = true</code>时，线程Thread02输出<code>你坏</code>。</p><p>实际上这段代码永远不会输出<code>你坏</code>，而是一直处于死循环。这是为什么呢？接下来我们一步步讲解验证。</p><p>我们把<code>sign</code>关键字加上<code>volatile</code>关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>这个时候会输出<code>你坏</code>。</p><p><code>volatile</code>关键字是Java虚拟机提供的最轻量级锁的同步机制，作为一个修饰符出现，同来修饰变量，不含括局部变量，用来保证对所有线程可见性。</p><p>无<code>volatile</code>关键字修饰时内存变化</p><p><img src="https://qtspace.cn/contentimg/16.jpg"></p><p>当没有<code>volatile</code>关键字修饰的时候，Thread01对变量进行操作，Thead02并不会拿到最新值。</p><p>有<code>volatile</code>关键字时内存变化</p><p><img src="https://qtspace.cn/contentimg/17.jpg"></p><p>当有<code>volatile</code>关键字修饰的时候，Thread01对变量进行操作时，会把变量的变化强制刷新到主内存，Thread02获取值时，会把自己内存的sign值过期掉，从主内存读取最新的。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><code>volatile</code>关键字底层是通过<strong>lock指令</strong>实现可见性的，lock指令相当于一个内存屏障，保证以下三点：</p><ul><li>将本处理器的缓存写入主内存。</li><li>重排序时不会把后面的指令重新排序到内存屏障之前。</li><li>如果是写入操作会导致其他内存器中对应的内存无效。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>volatile</code>关键字会控制被修饰的变量在内存操作的时候会主动把值刷新到主内存，JMM会先将线程对应的CPU内存设置过期，从内存读取最新值。</li><li><code>volatile</code>关键字是通过内存屏障防止指令重排，<code>volatile</code>的内存屏障在读写的时候在前后各添加一个<code>Store</code>屏障来保证重新排序时不会把内存屏障后面的时候指令排序到内存屏障之前。</li><li><code>volatile</code>不能解决原子性，如果需要解决原子性需要<code>synchronized</code>或者<code>lock</code>。</li></ul><h3 id="三、synchronized"><a href="#三、synchronized" class="headerlink" title="三、synchronized"></a>三、synchronized</h3><h4 id="知识大纲"><a href="#知识大纲" class="headerlink" title="知识大纲"></a>知识大纲</h4><p><img src="https://qtspace.cn/contentimg/18.jpg"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><code>synchronized</code>关键字主要有以下三种使用方式：</p><ul><li><p><strong>修饰实例方法</strong>，作用于当前实例加锁，进入同步代码前要获取<strong>当前实例</strong>的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        getI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        executorService.execute(synchronizedTest);</span><br><span class="line">        executorService.execute(synchronizedTest);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000000</span><br><span class="line">1556623</span><br><span class="line">2000000</span><br><span class="line">2000000</span><br></pre></td></tr></table></figure><p>上述代码中，创建两个线程同时操作同一个共享资源<code>i</code>，且<code>increase()</code>、<code>get()</code>方法加了<code>synchronized</code>关键字，表示当前线程的锁是实例对象，因为传入线程都是<code>synchronizedTest</code>对象实例是同一个，所以最终结果肯定能输出<code>2000000</code>，如果我们换种方式，传入不同对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">    <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">    executorService.execute(synchronizedTest01);</span><br><span class="line">    executorService.execute(synchronizedTest02);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1002588</span><br><span class="line">1641267</span><br><span class="line">1848269</span><br></pre></td></tr></table></figure><p>最终肯定不是期望的<code>200000</code>，因为<code>synchronized</code>修饰方法锁的是当前实例，传入不同对象实例线程是无法保证安全的。</p></li><li><p><strong>修饰静态方法</strong>，作用于当前类对象加锁，进入同步方法前要获取<strong>当前类对象</strong>的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">        getI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        <span class="type">SynchronizedTest</span> <span class="variable">synchronizedTest02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">        executorService.execute(synchronizedTest01);</span><br><span class="line">        executorService.execute(synchronizedTest02);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1000000</span></span><br><span class="line"><span class="number">1649530</span></span><br><span class="line"><span class="number">2000000</span></span><br><span class="line"><span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>上述代码和第一段代码差不多，只不过<code>increase()</code>、<code>get()</code>方法是静态方法，且也加上了<code>synchronized</code>表示锁的是当前类对象，虽然我们传入不同的对象，但是最终结果是会输出<code>200000</code>的。</p></li><li><p>修饰<strong>语代码块</strong>，指定加锁对象，给对象加锁，进入同步方法前要获取<strong>给定对象</strong>的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest02</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SynchronizedTest02</span> <span class="variable">synchronizedTest02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest02</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 传入对象锁当前实例对象</span></span><br><span class="line">        <span class="comment">// 如果是 synchronized (SynchronizedTest02.class) 锁当前类对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (synchronizedTest02)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000000</span>;j++)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(synchronizedTest02);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(synchronizedTest02);</span><br><span class="line">        thread01.start();</span><br><span class="line">        thread02.start();</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用锁修饰代码块，传入的是对象表示锁的是当前实例对象，如果传入是类表示锁的是类对象。</p></li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>原子性表示一个操作不可中断，要么成功要么失败。</p><p><code>synchroniezd</code>能实现方法同步，同一时间段内只有一个线程能拿到锁，进入到代码执行，从而达到原子性。</p><p>底层通过执行<code>mointorenter</code>指令，判断是否有<code>ACC_SYNCHRONIZED</code>同步标识，有表示获取<code>monitor</code>锁，此时计数器+1，方法执行完毕，执行<code>mointorexit</code>指定，此时计数器-1，归0释放锁。</p><h5 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h5><p>可见性表示一个线程修改了一个共享变量的值，其它线程都能够知道这个修改。<code>CPU缓存优化</code>、<code>指令重排</code>等都可能导致共享变量修不能立刻被其他线程察觉。</p><p><code>synchroniezd</code>通过操作系统内核互斥锁实现可见性，线程释放锁前必须把共享变量的最新值刷新到主内存中，线程获取锁之前会将工作内存中共享值清空，从主内存中获取最新的值。</p><h5 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h5><p>程序在执行时，有可能会进行指令重排，CPU执行指令顺序不一定和程序的顺序一致。指定重排保证<code>串行语义一致</code>（即重排后CPU执行的执行和程序真正执行顺序一致）。<code>synchronized</code>能保证CPU执行指令顺序和程序的顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例对象</span></span><br><span class="line"><span class="comment">     * volatile + 双重检测机制 -&gt; 禁止重排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   instance = new LazySingleton();</span></span><br><span class="line"><span class="comment">     *   1. 分配对象内存空间</span></span><br><span class="line"><span class="comment">     *   2. 初始化对象</span></span><br><span class="line"><span class="comment">     *   3. 设置instance指向刚分配的内存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   JVM和CPU优化, 发生了指令重排, 1-3-2, 线程A执行完3, 线程B执行第一个判断, 直接返回, 这个时候是 * 有问题的。</span></span><br><span class="line"><span class="comment">     *   通过volatile关键字禁止重排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>的有序性是保证线程有序的执行，不是防止指令重排序。上面代码如果不加<code>volatile</code>关键字可能导致的结果，就是第一个线程在初始化的时候，设置instance执行分配的内存时，这个时候第二个线程进来了，有指令重排，在第一个判断的时候直接返回，就出错了这个时候instance可能还没初始化成功。</p><h5 id="重入性"><a href="#重入性" class="headerlink" title="重入性"></a>重入性</h5><p><code>synchronized</code>是可重入锁，允许一个线程二次请求自己持有对象锁的临界资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest03</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedTest03</span> <span class="variable">synchronizedTest03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest03</span>();</span><br><span class="line">        synchronizedTest03.doA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法：SynchronizedTest03.doA() ThreadId:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        doB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法：SynchronizedTest03.doB() ThreadId:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="built_in">super</span>.doA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">doA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法：A.doA() ThreadId:&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码正常输入如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">子类方法：SynchronizedTest03.doA() ThreadId:1</span><br><span class="line">子类方法：SynchronizedTest03.doB() ThreadId:1</span><br><span class="line">父类方法：A.doA() ThreadId:1</span><br></pre></td></tr></table></figure><p>最后正常的输出了结果，并没有发生死锁，说明<code>synchronized</code>是可重入锁。</p><p><code>synchronized</code>锁对象的时候有个计数器，记录线程获取锁的次数，在执行完对应的代码后计数器就会-1，知道计数器清0释放锁。</p><h4 id="类型和升级"><a href="#类型和升级" class="headerlink" title="类型和升级"></a>类型和升级</h4><p>在介绍锁的类型之前先说一下什么是<code>markword</code>，<code>markword</code>是java对象数据结构中的一部分，<code>markword</code>数据在长度为32位和64位虚拟机（未开启压缩指针）中分别是32bit和64bit，它的最后两位bit是锁状态标志位，用来标记当前对象的状态，如下表示：</p><table><thead><tr><th align="center">状态</th><th align="center">标志位</th><th align="center">储存内容</th></tr></thead><tbody><tr><td align="center">无锁（未开启偏向锁）</td><td align="center">01</td><td align="center">对象哈希码、对象分代年龄</td></tr><tr><td align="center">偏向锁（开启偏向锁）</td><td align="center">01</td><td align="center">偏向线程id、偏向时间戳、对象分代年龄</td></tr><tr><td align="center">轻量级锁</td><td align="center">00</td><td align="center">指向轻量级锁指针</td></tr><tr><td align="center">重量级锁</td><td align="center">10</td><td align="center">指向重量级锁指针</td></tr><tr><td align="center">GC标记</td><td align="center">11</td><td align="center">空</td></tr></tbody></table><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁会偏向于第一个访问锁的线程，如果在运行过程中只有一个线程访问不存在多个线程争用的情况下，则线程是不需要触发同步的，这个时候就会给线程加一个偏向锁。如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁升级至轻量级锁。</p><p><code>UseBiasedLocking</code> 是一个偏向锁检查， 1.6 之后是默认开启的， 1.5 中是关闭的，需要手动开启参数是 <code>XX: UseBiasedLocking=false</code>。</p><p>偏向锁获取过程：</p><ol><li>访问markword中偏向锁表示是否为1，锁标志位01，确认为偏向锁状态。</li><li>判断markword中线程id是否指向当前线程id，如果是则执行步骤5，如果不是则执行步骤3</li><li>如果markword中线程id未指向当前线程id，则通过CAS操作竞争锁。如果竞争成功，则指向当前线程id，执行步骤5，如果竞争失败，则执行步骤4。</li><li>如果CAS竞争锁失败表示有竞争，当到达全局安全点（safepoint）时获得偏向锁的线程会被挂起，偏向锁升级为轻量级锁并撤销偏向锁（撤销偏向锁是会导致stop the word，除GC所需的线程外，所有的线程都进入等待状态，直到GC任务完成），然后被阻塞在安全点的线程会继续执行同步代码。</li><li>执行同步代码。</li></ol><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>当锁是偏向锁的时候，在运行过程中发现有其他线程抢占锁，偏向锁就会升级成轻量级锁，其他线程会通过自旋的形式获取锁，不会阻塞，提高性能，缺点是循环会消耗CPU。</p><p>轻量级锁加锁过程：</p><ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁状态标志位为01状态，是否为偏向锁为0），虚拟机首先将在当前线程的帧栈中建立一个名为索记录（Lock Record）的空间，用于储存锁对象目前的markword的拷贝，官方称之为 <code>Displaced Mark Word</code>。</li><li>拷贝对象的markword到锁记录中。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的markword更新指向锁记录的指针，并将锁记录里的owner指向对象的markword，如果更新成功则执行步骤4，否则执行步骤5。</li><li>更新成功表示这个线程就获取到了锁的对象，并且对象的markword锁标志位设置成00，表示此对象处于轻量级锁 状态。</li><li>如果更新失败了，说明虚拟机首先会检查对象的markword是否指向当前线程的栈帧，如果是说明当前线程已经获取到了这个对象的锁。如果不是则说明多个线程竞争锁，轻量级锁就会升级成重量级锁，锁标志的状态值变为10，markword中储存的就是指向重量级锁的指针，后面等待锁的线程会进入阻塞状态。</li></ol><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>当偏向锁升级成轻量级锁时，其他线程会通过自旋的方式获取锁，不会阻塞，如果自旋n次都失败了，这个时候轻量级锁就会升级成重量级锁。</p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p><img src="https://qtspace.cn/contentimg/19.jpg"></p><p>synchronized的执行过程：</p><ol><li>检查markword里面存储的是不是当前线程的id，如果是则表示当前线程处于偏向锁。</li><li>如果不是，则尝试使用CAS将当前线程的id替换markword，如果成功则表示当前线程获取锁，偏向标志位置为1。</li><li>如果CAS失败则说明发生竞争，撤销偏向锁，进而升级成轻量级锁，锁标志置为00。</li><li>当前线程使用CAS将对象的markword替换成锁记录指针，如果成功，则当前线程获取锁。</li><li>如果替换失败，表示其他线程竞争锁，当前线程遍尝试使用自选锁的方式来获取锁。</li><li>如果自旋成功获取锁则依处于轻量级锁。</li><li>如果自旋失败，则升级成重量级锁，锁标志置为10。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、锁的基础知识&quot;&gt;&lt;a href=&quot;#一、锁的基础知识&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    
    <category term="volatile" scheme="https://qtspace.cn/tags/volatile/"/>
    
    <category term="synchronized" scheme="https://qtspace.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>JVM-GC垃圾回收</title>
    <link href="https://qtspace.cn/2022/03/22/jvm-gc/"/>
    <id>https://qtspace.cn/2022/03/22/jvm-gc/</id>
    <published>2022-03-21T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:25.311Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><p>学习JVM垃圾回收机制主要学习以下几点：<strong>哪些内存需要回收（判断对象可以回收）、什么时候回收(GC什么时候执行)、怎么回收（垃圾回收算法、垃圾回收器）、垃圾回收过程</strong>。</p><h3 id="JVM-GC回收哪些区域内的垃圾？"><a href="#JVM-GC回收哪些区域内的垃圾？" class="headerlink" title="JVM GC回收哪些区域内的垃圾？"></a>JVM GC回收哪些区域内的垃圾？</h3><p>JVM GC只回收<strong>堆区和方法区</strong>内的对象，不回收虚拟机栈内的数据，栈内数据在超出作用域后会被JVM自动释放掉。</p><p>因为JVM GC回收堆区的对象，所以先了解学习一下堆内存的结构图：</p><p>堆内存分为<strong>年轻代（Young Generation）</strong>、<strong>老年代（Old Generation）</strong>，年轻代和老年代所占空间比例默认是<strong>1:2</strong>。年轻代又分为<strong>Eden</strong>和<strong>Survivor</strong>区，<strong>Survivor</strong>区由<strong>FormSpace</strong>和<strong>ToSpace</strong>组成。Eden区占大容量，Survivor两个区占小容量，默认比例是<strong>8:1:1</strong>。From和To主要是为了解决内存碎片化。</p><h3 id="JVM-GC怎么判断对象可以回收？"><a href="#JVM-GC怎么判断对象可以回收？" class="headerlink" title="JVM GC怎么判断对象可以回收？"></a>JVM GC怎么判断对象可以回收？</h3><ul><li>对象没有引用。</li><li>作用域发生未捕获异常。</li><li>程序在作用域正常执行完毕。</li><li>程序执行了<code>System.exit()</code>。</li><li>程序发生意外终止（被杀进程等）。</li></ul><p>判断对象是否可以回收涉及到垃圾回收算法，后面我们会详情说明。</p><p>有些时候我们可以把相关的对象设置成null来试图显示的清除缓存，但是并不是设置null就一定被标记成可以回收，比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="type">ReferenceCountingGC</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(); </span><br><span class="line">    <span class="type">ReferenceCountingGC</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(); </span><br><span class="line">    objA.instance = objB; </span><br><span class="line">    objB.instance = objA; </span><br><span class="line">    objA = <span class="literal">null</span>; </span><br><span class="line">    objB = <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 假设在这行发生GC， objA和objB是否能被回收？ </span></span><br><span class="line">    System.gc(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<code>objA</code>和<code>objB</code>设置null不会被标记成可以回收因为<code>objA</code>和<code>objB</code>循环依赖引用关系，但是<code>System.gc();</code>会执行<code>Full GC</code>回收。</p><p>将对象设置null至少没有什么坏处，但是<code>System.gc();</code>便不可取了，因为使用<code>System.gc();</code>的时候并不是马上执行GC操作，而是会等待一段时间，甚至不会执行，如果被执行会触发<code>Full GC</code>是非常影响性能的。</p><h3 id="JVM-GC什么时候执行？"><a href="#JVM-GC什么时候执行？" class="headerlink" title="JVM GC什么时候执行？"></a>JVM GC什么时候执行？</h3><p>Eden区空间不够储存对象的时候会执行<code>Minro GC</code>。升到老年代的对象大于老年代剩余的空间时执行<code>Full GC</code>,或者小于的时候被<code>HandlePromotionFailure</code>参数强制<code>Full GC</code>。JVM GC调优主要是减少<code>Full GC</code>的触发次数，可以通过设置参数<code>NewRatio</code>控制年轻代和老年代所占内存比例，通过设置参数<code>MaxTenuringThreshold</code>改变对象进入老年代的阙值。<code>Full GC</code>非常损耗性能，执行时间大概是<code>Minro GC</code>的10倍。</p><h3 id="JVM-GC按代的垃圾回收机制"><a href="#JVM-GC按代的垃圾回收机制" class="headerlink" title="JVM GC按代的垃圾回收机制"></a>JVM GC按代的垃圾回收机制</h3><p><strong>年轻代：</strong>绝大多数新创建的对象都是被分配在年轻代（对象很大的话可能被分配在老年代），年轻代触发GC对象被回收的过程称之为<code>Minor GC</code>。</p><p><strong>老年代：</strong>对象在年轻代周期存活了下来，会被拷贝到老年代，老年代触发GC对象被回收的过程称之为<code>Full GC</code>。</p><p><strong>持久代：</strong>也被叫做方法区，用于保存类加载信息、常量、静态变量等，方法区不是用于储存老年代存活下来的对象，这个区域也可能发生GC，方法发生GC的过程被称为<code>Major GC</code>，方法区发生GC的条件非常苛刻，必须满足以下三个条件才会回收：</p><ul><li>所有实例被回收。</li><li>加载该类的ClassLoader被回收。</li><li>Class对象无法通过任务途径访问（包含反射）。</li></ul><h3 id="老年代如何解决引用年轻代对象问题？"><a href="#老年代如何解决引用年轻代对象问题？" class="headerlink" title="老年代如何解决引用年轻代对象问题？"></a>老年代如何解决引用年轻代对象问题？</h3><p>老年代中存在一个<code>card table</code>，大小为512字节，用于存放所有老年代对象执行年轻代对象的引用，当针对年轻代执行GC的时候，只需查询一下<code>card table</code>来决定是否回收，而不同查询整个老年代。</p><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><ol><li>绝大数刚刚新建的对象都会储存在年轻代的Eden区。</li><li>当Eden区空间不足时就会执行GC，在执行第一次GC之后存活的对象就会移动到Survivor的From区。</li><li>此后每次Eden区执行GC，存活的对象都会被存放在From区。</li><li>当From区空间饱和时，在存活的对象就会被移动到to区，然后清空from区。</li><li>在以上步骤重复N次（N&#x3D;MaxTenuringThreshold 年龄阙值默认15）依然存活的对象就会移到老年代，如果这个时候老年代没有空间了就会触发<code>Full GC</code>，如果触发 Full GC之后空间还是不足就会抛出OOM异常。</li></ol><h3 id="JVM-GC核心参数"><a href="#JVM-GC核心参数" class="headerlink" title="JVM GC核心参数"></a>JVM GC核心参数</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio </span><br><span class="line">–XX:SurvivorRatio </span><br><span class="line">–XX:NewSize </span><br><span class="line">–XX:MaxNewSize</span><br></pre></td></tr></table></figure><p><code>-XX:NewRatio</code>表示年轻代和老年代相对的比例，比如<code>-XX:NewRatio=2</code>表示老年代是年轻代的2被，老年代占堆的2&#x2F;3，年轻代占1&#x2F;3。</p><p><code>-XX:SurvivorRatio</code>表示年轻代里面Eden区和Survivor区相比比例，比如<code>-XX:SurvivorRatio=8</code>表示<code>Eden:From:To = 8:1:1</code>。SurvivorRatio不能设置过大也不能设置过小，一般默认值即可。</p><p><code>-XX:NewSize</code>表示年轻代的初始化大小。</p><p><code>-XX:MaxNewSize</code>表示年轻代最大大小。</p><h3 id="JVM-GC算法"><a href="#JVM-GC算法" class="headerlink" title="JVM GC算法"></a>JVM GC算法</h3><h4 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h4><p>程序把所有引用关系看作一棵树，从一个根节点GC ROOT开始寻找对应的引用节点，找到这个节点后继续寻找这个节点的引用节点，当所有节点寻找完毕之后，没有被引用的节点就是无用的节点。</p><p><img src="https://qtspace.cn/contentimg/12.jpg"></p><p>上图红色就是无用的节点，可以被回收。</p><p>目前Java中可以作为GC ROOT的对象有：</p><ul><li>虚拟机栈、本地方法栈中引用的对象，对象分别是本地变量表、Native对象。</li><li>方法区中静态变量、常量引用的对象。</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><img src="https://qtspace.cn/contentimg/13.jpg"></p><p>标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕之后再扫描整个空间中未被标记的对象进行回收。</p><p>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行回收，在存活的对象比较多的情况下极为高效，但是由于标记-清除算法直接回收不存活的对象，没有对还存活的对象进行整理，所以会导致内存碎片化。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><img src="https://qtspace.cn/contentimg/14.jpg"></p><p>复制算法将内存空间划分为两个区间，所有对象都只会分配在其中一个活动区间，而另外一个区间则是空闲的。</p><p>复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕之后，会将活动区间一次性回收，<strong>此时原本的空闲区间变成了活动区间</strong>，下次GC的时候又重复此操作。复制算法在存活对象比较少的时候极为高效。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p><img src="https://qtspace.cn/contentimg/15.jpg"></p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记、回收，但是在回收不存活对象占用的空间后，会将所有存活的对象往左移动，并更新对应的指针，解决了内存碎片的问题。</p><p>JVM为了优化内存的回收，使用分代回收的方式，年轻代内存回收采用复制算法，老年代回收大多采用标记-整理算法。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="年轻代回收器"><a href="#年轻代回收器" class="headerlink" title="年轻代回收器"></a>年轻代回收器</h4><p><strong>Serial：</strong></p><ul><li>算法：复制算法</li><li>说明：简单高效的单核机器，Client模式下默认的年轻代收集器。</li></ul><p><strong>ParNew</strong></p><ul><li>算法：复制算法</li><li>说明：Serial的多线程版本，运行在Server模式下的JVM首选的新生代收集器。</li></ul><p><strong>Parallel Scavenge</strong></p><ul><li>算法：复制算法</li><li>说明：又被称为吞吐量优先收集器，和ParNew 收集器类似，目标在于达到可控制吞吐量。</li></ul><h4 id="老年代回收器"><a href="#老年代回收器" class="headerlink" title="老年代回收器"></a>老年代回收器</h4><p><strong>Serial Old</strong></p><ul><li>算法：标记-整理算法</li><li>说明：性能一般，单线程版本，在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，作为CMS收集器的后备预案。</li></ul><p><strong>Parallel Old</strong></p><ul><li>算法：标记-整理算法</li><li>说明：GC多线程并行，为了替代 Serial Old 与 Parallel Scavenge 配合使用。</li></ul><p><strong>CMS</strong></p><ul><li>算法：标记-清除算法</li><li>说明：对CPU资源敏感，停顿时间长。会产生内存碎片，可以通过参数开启碎片的合并整理。 基本已被 G1 取代。</li></ul><h4 id="年轻代、老年代共用回收器"><a href="#年轻代、老年代共用回收器" class="headerlink" title="年轻代、老年代共用回收器"></a>年轻代、老年代共用回收器</h4><p><strong>G1</strong></p><ul><li>算法：标记-整理算法</li><li>说明：新的垃圾回收器，既可以回收新生代也可以回收老年代，适用于多核大内存机器、GC多线程并行执行，停顿低、高回收率。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习JVM垃圾回收机制主要学习以下几点：&lt;strong&gt;哪些内存需要回收（判断对象可以回收）、什么时候回收(GC什么</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="JVM" scheme="https://qtspace.cn/categories/Java/JVM/"/>
    
    
    <category term="GC垃圾回收机制" scheme="https://qtspace.cn/tags/GC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>六大设计模式原则-依赖倒置原则</title>
    <link href="https://qtspace.cn/2022/03/20/design-mode-di/"/>
    <id>https://qtspace.cn/2022/03/20/design-mode-di/</id>
    <published>2022-03-19T16:00:00.000Z</published>
    <updated>2022-04-08T11:40:40.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、依赖倒置原则定义"><a href="#一、依赖倒置原则定义" class="headerlink" title="一、依赖倒置原则定义"></a>一、依赖倒置原则定义</h3><p>依赖倒置原则：<strong>抽象不应该依赖于实现，实现应该依赖于抽象，也就是说我们应该面对抽象(接口)编程，而不应该面对实现编程。</strong></p><h3 id="二、依赖倒置原则描述"><a href="#二、依赖倒置原则描述" class="headerlink" title="二、依赖倒置原则描述"></a>二、依赖倒置原则描述</h3><p>依赖倒置原则要求我们在程序代码中传递参数或在关联关系时，尽量引用高层次类抽象类(接口类)，而不应该引用具体的实现类，即使用抽象类或者接口进行变量类型声明、参数类型声明、方法返回结果声明。</p><p>在引用抽象层之后，系统将得到很好的灵活性，抽象类无需改变，只需新增新的实现类即可，也满足了开闭原则。</p><h3 id="三、依赖倒置原则示例场景"><a href="#三、依赖倒置原则示例场景" class="headerlink" title="三、依赖倒置原则示例场景"></a>三、依赖倒置原则示例场景</h3><p>现有一个抽奖策略的设计，在不使用设计模式时，设计了一个<code>DrawControl</code>抽奖控制类，这个类里面包含了<code>doDrawRandom()</code>、<code>doDrawWeight()</code>两种抽奖策略，这种设计在实际开发起来速度是非常快的，但是后续不好维护，如果后续要新增其他的抽奖策略该类就要新增方法不利于维护也不满足开闭原则。</p><p><img src="https://qtspace.cn/contentimg/10.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;BetUser&gt; <span class="title function_">doDrawRandom</span> <span class="params">(List&lt;BetUset&gt; list, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机抽取指定数量的用户，作为中奖用户</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> List&lt;BetUser&gt; <span class="title function_">doDrawWeight</span> <span class="params">(List&lt;BetUset&gt; list, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 权重排名获取指定数量的用户，作为中奖用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现进行重构满足依赖倒置原则，定义一个<code>IDraw</code>抽奖接口，包含<code>prize()</code>方法，新增两个抽奖的实现类<code>DrawRandom</code>(随机抽取指定数量的用户，作为中奖用户)、<code>DrawWeightRank</code>(权重排名获取指定数量的用户，作为中奖用户),<code>DrawControl</code>抽奖控制类只定义一个<code>doDraw()</code>方法，具体的抽象策略使用参数传入，而且参数传入高层的接口类，不参与具体的实现类。这样子就满足了灵活性，后续业务如果要新增抽奖策略新增新的实现类即可，<code>DrawControl</code>类可以不用改变，满足了依赖倒置原则，同时也满足了开闭原则。</p><p><img src="https://qtspace.cn/contentimg/11.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDraw</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;BetUser&gt; <span class="title function_">prize</span><span class="params">(List&lt;BetUser&gt; list, <span class="type">int</span> count)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawRandom</span> <span class="keyword">implements</span> <span class="title class_">IDraw</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BetUser&gt; <span class="title function_">prize</span><span class="params">(List&lt;BetUser&gt; list, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机抽取指定数量的用户，作为中奖用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawWeightRank</span> <span class="keyword">implements</span> <span class="title class_">IDraw</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;BetUser&gt; <span class="title function_">prize</span><span class="params">(List&lt;BetUser&gt; list, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 权重排名获取指定数量的用户，作为中奖用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawControl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以用注入的方式</span></span><br><span class="line">    <span class="keyword">private</span> IDraw draw;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;BetUser&gt; <span class="title function_">doDraw</span><span class="params">(IDraw draw, List&lt;BetUser&gt; betUserList, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> draw.prize(betUserList, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、依赖倒置原则定义&quot;&gt;&lt;a href=&quot;#一、依赖倒置原则定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="设计模式" scheme="https://qtspace.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="依赖倒置原则" scheme="https://qtspace.cn/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JVM-类加载详解</title>
    <link href="https://qtspace.cn/2022/03/19/jvm-class-loader/"/>
    <id>https://qtspace.cn/2022/03/19/jvm-class-loader/</id>
    <published>2022-03-18T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:18.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、JVM类加载过程"><a href="#一、JVM类加载过程" class="headerlink" title="一、JVM类加载过程"></a>一、JVM类加载过程</h3><p>JVM类加载过程如下图：</p><p><img src="https://qtspace.cn/contentimg/8.jpg"></p><p><img src="https://qtspace.cn/contentimg/9.jpg"></p><p>JVM类加载过程分为：<mark class="hl-label blue">加载</mark> 、<mark class="hl-label blue">链接</mark> 、<mark class="hl-label blue">初始化</mark> 、<mark class="hl-label blue">使用</mark> 、<mark class="hl-label blue">卸载</mark> 这五个阶段，其中链接阶段又包括：<mark class="hl-label green">验证</mark> 、<mark class="hl-label green">准备</mark> 、<mark class="hl-label green">解析</mark> 。</p><ul><li><mark class="hl-label blue">加载</mark> ：通过类的完全限定名，查找此类的二进制字节码文件，通过该字节码文件创建Class对象。</li><li><mark class="hl-label blue">链接</mark> ：包含<mark class="hl-label green">验证</mark> 、<mark class="hl-label green">准备</mark> 、<mark class="hl-label green">解析</mark> 三个阶段：<ul><li><mark class="hl-label green">验证</mark> ：确保Class文件复合虚拟机规定的Class文件格式，包含文件格式验证、元数据验证、字节码验证、引用符号验证。</li><li><mark class="hl-label green">准备</mark> ：为类的静态变量分配内存并设置初始化值，注：这里不包含`final`修饰的静态变量，因为`final`修饰的静态变量是在编译期分配。</li><li><mark class="hl-label green">解析</mark> ：将常量池的间接引用转换为直接引用，解析包含字段解析、接口解析、方法解析。</li></ul></li><li><mark class="hl-label blue">初始化</mark> ：初始化静态变量和静态块，先初始化父类，再初始化当前类，只有对类主动时才会初始化。</li><li><mark class="hl-label blue">使用</mark> ：程序代码执行时使用，new出对象程序中使用。</li><li><mark class="hl-label blue">卸载</mark> ：程序代码退出、异常、结束等，执行垃圾回收。</li></ul><h3 id="二、类加载时机"><a href="#二、类加载时机" class="headerlink" title="二、类加载时机"></a>二、类加载时机</h3><ul><li>创建类的实例，也就是<code>new</code>一个对象。</li><li>访问类的静态方法或者静态变量（包含静态变量赋值）。</li><li>使用<code>Class.forName()</code>反射类。</li><li>子类初始化的时候。</li><li>JVM启动时标明的启动类。</li></ul><h3 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h3><p>类加载器包括启动类加载器、扩展类加载器、系统类加载器、自定义类加载器四种加载器。</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）：负责加载Java类的核心类，是用原生代码实现。下面代码可以获得启动类加载器所加载的Java核心类库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span>(URL url : urLs)&#123;</span><br><span class="line">    System.out.println(url.toExternalForm());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/resources.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/rt.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/sunrsasign.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/jsse.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/jce.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/charsets.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/lib/jfr.jar</span></span><br><span class="line">file:/D:/Develop<span class="comment">%20Tools/Java/jdk-8u231/jre/classes</span></span><br></pre></td></tr></table></figure></li><li><p>扩展类加载器（Extensions ClassLoader）：负责加载JRE的扩展目录<code>lib/ext</code>或者由<code>java.ext.dirs</code>系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为Null。</p></li><li><p>系统类加载器（System Class Loader）：负责在JVM启动时加载来自Java命令的<code>-classpath</code>选项、<code>java.class.path</code>系统属性。可以通过<code>ClassLoader.getSystemClassLoader()</code>方法获取当前系统类加载器，一般情况是自定义类加载器的父加载器。由Java语言实现，父类加载器为扩展类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">System.out.println(ClassLoader.getSystemClassLoader().getParent());</span><br></pre></td></tr></table></figure><p>上面代码输出为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher<span class="built_in">$</span>AppClassLoader@18b4aac2</span><br><span class="line">sun.misc.Launcher<span class="built_in">$</span>ExtClassLoader@4eb7f003</span><br></pre></td></tr></table></figure></li><li><p>自定义类加载器（Custom ClassLoader）：用户可以通过继承<code>ClassLoader</code>类实现自定义类加载器。由Java语言实现，自定义类加载器的父类是系统类加载器。</p></li></ul><h3 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h3><p>JVM的类加载机制主要有全盘负责、双亲委派、缓存机制三种加载机制。</p><ul><li>全盘负责：当一个类加载器加载某个Class时，该Class所依赖和引用其他Class也会由该类加载器负责加载，除非指定了使用其他类加载器加载。</li><li>双亲委派：先让父类加载器加载该Class，只有在父类加载器无法加载该类时才尝试使用自己的类加载器加载。通俗的讲就是在某个特定的类加载器接到加载类请求时，先寄托给父加载器加载，依次递归，如果父加载器可以加载时则成功返回，如果不可以加载就自己去加载。</li><li>缓存机制：缓存机制会确保所有加载过的Class都被会缓存，当程序中需要某个Class时，类加载器先从缓存区中搜索该Class，只有缓存区中不存在该Class对象时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存区。这就是为什么我们修改Class文件之后，必须重启JVM才会生效的原因。</li></ul><p>其中双亲委派机制优势：</p><ul><li>父类加载器成功加载则返回，子类加载器不会再加载，防止了重复加载。</li><li>防止核心API库被随意篡改。比如有一个要加载<code>java.lang.Integer</code>类的请求，通过双亲委派进制加载传递到启动类加载器，在在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载传递的过来的<code>java.lang.Integer</code>，而直接返回已加载过的<code>Integer.class</code>，可以防止核心API被随意篡改。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、JVM类加载过程&quot;&gt;&lt;a href=&quot;#一、JVM类加载过程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="JVM" scheme="https://qtspace.cn/categories/Java/JVM/"/>
    
    
    <category term="类加载" scheme="https://qtspace.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>六大设计模式原则-接口隔离原则</title>
    <link href="https://qtspace.cn/2022/03/17/deisgn-model-isp/"/>
    <id>https://qtspace.cn/2022/03/17/deisgn-model-isp/</id>
    <published>2022-03-16T16:00:00.000Z</published>
    <updated>2022-04-08T11:40:32.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、接口隔离原则定义"><a href="#一、接口隔离原则定义" class="headerlink" title="一、接口隔离原则定义"></a>一、接口隔离原则定义</h3><p>接口隔离原则定义如下：</p><p><strong>接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</strong>。</p><h3 id="二、接口隔离原则描述"><a href="#二、接口隔离原则描述" class="headerlink" title="二、接口隔离原则描述"></a>二、接口隔离原则描述</h3><p>根绝接口隔离原则，当一个接口太大时，我们需要将它分割成一些细小的接口，使用该接口的客户端只需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事情，干该干的事请</strong>。这里的”接口”往往有两种不同的定义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是某种语言上具体的”接口”定义，比如Java语言的<code>interface</code>。对于这两种不同的含义，接口隔离原则表达以及含义所以不同：</p><ul><li>当把”接口“理解成一个类型所具有的方法特性的集合时，就是一种逻辑上的概念，接口的划分将直接带来类的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定一个接口，此时这个原则可以叫做<strong>角色隔离原则</strong>。</li><li>如果把”接口”理解成狭义的特定语言接口，那么接口隔离原则表达的意思就是<strong>接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的接口，而不要提供大的总接口</strong>。在面向对象编程语言中，实现一个接口类就要实现该接口定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要把大接口中的方法根据其职责不同放到不同的小接口中，确保每个接口使用起来都很方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或者业务逻辑类）所需的方法即可，这种机制也称为“<strong>定制服务</strong>”，即为不同的客户端提供宽窄不同的接口。</li></ul><h3 id="三、接口隔离原则栗子"><a href="#三、接口隔离原则栗子" class="headerlink" title="三、接口隔离原则栗子"></a>三、接口隔离原则栗子</h3><h4 id="不满足接口隔离原则"><a href="#不满足接口隔离原则" class="headerlink" title="不满足接口隔离原则"></a>不满足接口隔离原则</h4><p>现有一个接口<code>CustomerDataDisplay</code>，包含了<code>dataRead()</code>、<code>transformToXml()</code>、<code>createChart()</code>、<code>displayChart()</code>、<code>createReport()</code>、<code>displayReport()</code>方法，方法说明如下：</p><ul><li><code>dataRead()</code>：数据读取。</li><li><code>transformToXml()</code>：数据转成xml格式。</li><li><code>createChart()</code>：创建图表。</li><li><code>displayChart()</code>：显示图表。</li><li><code>createReport()</code>：创建报表。</li><li><code>displayReport()</code>：显示报表。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerDataDisplay</span> &#123;</span><br><span class="line">    List&lt;CustomerData&gt; <span class="title function_">dataRead</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transformToXml</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createChart</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayChart</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createReport</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayReport</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先有一个图表类<code>ChartClass</code>实现了<code>CustomerDataDisplay</code>接口，该类就要实现接口的全部方法，正常来说<code>ChartClass</code>只需要<code>createChart()</code>、<code>displayChart()</code>方法即可，因为<code>CustomerDataDisplay</code>接口方法太多了，承担了太多职责，颗粒度太大了<code>ChartClass</code>类不得不空实现其他方法，违背了接口隔离原则。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChartClass</span> <span class="keyword">implements</span> <span class="title class_">CustomerDataDisplay</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;CustomerData&gt; <span class="title function_">dataRead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transformToXml</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createChart</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 创建图表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayChart</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 显示图表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createReport</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    publicvoid <span class="title function_">displayReport</span><span class="params">()</span>&#123;</span><br><span class="line">         <span class="comment">// 空实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重构满足接口隔离原则"><a href="#重构满足接口隔离原则" class="headerlink" title="重构满足接口隔离原则"></a>重构满足接口隔离原则</h4><p>我们可以根据业务职业将<code>CustomerDataDisplay</code>接口分为<code>DataHandler</code>、<code>XMLTransformer</code>、<code>ChartHandler</code>、<code>ReportHandler</code>四个接口，这四个接口职责分别是：</p><ul><li><code>DataHandler</code>：数据业务处理接口。</li><li><code>XMLTransformer</code>：XML转换接口。</li><li><code>ChartHandler</code>：图表业务处理接口。</li><li><code>ReportHandler</code>：报表业务处理接口。</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataHandler</span> &#123;</span><br><span class="line">    List&lt;CustomerData&gt; <span class="title function_">dataRead</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">XMLTransformer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transformToXml</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChartHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createChart</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayChart</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReportHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createReport</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">displayReport</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后每个接口都承担自己的职责，灵活性很高，使用起来很方便，每个接口中都只包含和自己业务相关的方法，不会存在和自己无关的方法，达到了高内聚、松耦合的效果。</p><p><strong>在使用接口隔离原则时我们要控制接口的颗粒度，颗粒度不能太大，也不能太小。如果太小就会造成接口泛滥，不利于维护；接口入如果太大就会违背接口隔离原则，灵活性较差，使用起来不方便</strong>。一般来说接口中仅包含某业务模块的方法即可，不应该有其他业务模块的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、接口隔离原则定义&quot;&gt;&lt;a href=&quot;#一、接口隔离原则定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="设计模式" scheme="https://qtspace.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="接口隔离原则" scheme="https://qtspace.cn/tags/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>六大设计模式原则-迪米特法则</title>
    <link href="https://qtspace.cn/2022/03/16/deisgn-model-lod/"/>
    <id>https://qtspace.cn/2022/03/16/deisgn-model-lod/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-04-08T11:40:29.145Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、迪米特法则定义"><a href="#一、迪米特法则定义" class="headerlink" title="一、迪米特法则定义"></a>一、迪米特法则定义</h3><p>迪米特法则又最少知识原则，其定义如下：</p><p><strong>迪米特法则(Law of Demeter, LoD)：一个软件实体应当尽可能少的与其他实体发生相互作用。</strong></p><h3 id="二、迪米特法则描述"><a href="#二、迪米特法则描述" class="headerlink" title="二、迪米特法则描述"></a>二、迪米特法则描述</h3><p>如果一个系统满足迪米特法则，那么当其中一个软件实体发生变化时，就会尽量少的影响其他软件实体，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可以降低系统的耦合度，使类与类之间保持松耦合状态。</strong></p><p>迪米特法则还有几种定义形式，包括：<strong>不要和”陌生人”说话、只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><ul><li>当前对象本身(this)</li><li>以参数形式传入到当前对象方法中的对象</li><li>当前对象的成员对象</li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。</li><li>当前对象创建的对象</li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不能与“陌生人”发生直接交互，这样子可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象不必直接通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中一个对象需要调用另外一个对象的某个方法时，可以通过第三者转发这个调用。</strong>就是<strong>通过引入一个合理的第三者来降低先有对象之间的耦合度</strong>。</p><p>在迪米特法则运用到系统设计中时，要注意以下几点：</p><ul><li>在类的划分上，应该尽可能的创建松耦合的类，类之间的耦合度越低，复用率越高，一个松耦合的类发生修改不会对关联的类造成太大的影响。</li><li>在类的结构设计上，每一个类都应当尽可能的降低其成员变量和成员方法的访问权限。</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类。</li><li>在对其他类的引用上，一个对象对其他对象的引用应该降到最低。</li></ul><h3 id="三、迪米特法则栗子"><a href="#三、迪米特法则栗子" class="headerlink" title="三、迪米特法则栗子"></a>三、迪米特法则栗子</h3><h4 id="栗子一"><a href="#栗子一" class="headerlink" title="栗子一"></a>栗子一</h4><p>以下是关于关闭计算机的很经典的案例，当我们手动按下计算机的关闭按钮时，电脑还会附带其他的动作，比如关闭电脑正在执行的任务，关闭其他运行的程序，然后关闭显示器，最后才把电源关闭。</p><h5 id="不满足迪米特法则"><a href="#不满足迪米特法则" class="headerlink" title="不满足迪米特法则"></a>不满足迪米特法则</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveCurrentTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closeScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">closePower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">       saveCurrentTask();</span><br><span class="line">       closeService();</span><br><span class="line">       closeScreen();</span><br><span class="line">       closePower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickCloseButton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭计算机, 正常来说你只要调用close()方法即可</span></span><br><span class="line">        <span class="comment">// 但是你发现Computer类所有的方法都是公开的, 不知道怎么调用了</span></span><br><span class="line">        computer.saveCurrentTask();</span><br><span class="line">        computer.closePower();</span><br><span class="line">        computer.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也可以是</span></span><br><span class="line">        computer.closePower();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//还可以是</span></span><br><span class="line">        computer.close();</span><br><span class="line">        computer.closePower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上的代码我们可以看出，人这个类在调用电脑类的方法时发现电脑类暴露的方法有很多，不知道该调用哪一个，很明显，电脑这个类中的方法有些杂乱，对于我们人来说，我们只需要调用关闭电脑的操作，关闭电脑的方法就可以了，其他的方法完全没有必要暴露在外。</p><h5 id="满足迪米特法则"><a href="#满足迪米特法则" class="headerlink" title="满足迪米特法则"></a>满足迪米特法则</h5><p>根据迪米特法则只暴露该暴露的方法的要义作出如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">saveCurrentTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closePower</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">       saveCurrentTask();</span><br><span class="line">       closeService();</span><br><span class="line">       closeScreen();</span><br><span class="line">       closePower();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Computer computer;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clickCloseButton</span><span class="params">()</span> &#123;</span><br><span class="line">        computer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栗子二"><a href="#栗子二" class="headerlink" title="栗子二"></a>栗子二</h4><p>明星与经纪人的例子，像我们普通的明星工作繁忙，他的日常工作、日程安排都是由那个经纪人带做，明星是不可能自己亲力亲为的，不然的话会很累。</p><h5 id="不满足迪米特法则-1"><a href="#不满足迪米特法则-1" class="headerlink" title="不满足迪米特法则"></a>不满足迪米特法则</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Project project;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do</span><span class="params">()</span> &#123;</span><br><span class="line">        project.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Project</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码明星直接和安排行程直接有关系了，按道理明星不可能自己亲力亲为，这个时候就可以通过引入一个经纪人类将明星和行程关联起来，任何事物都交由经纪人类代为安排，这样的话便符合最小依赖原则，明星类只依赖经纪人类，改造如下：</p><h5 id="满足迪米特法则-1"><a href="#满足迪米特法则-1" class="headerlink" title="满足迪米特法则"></a>满足迪米特法则</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Business business;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do</span><span class="params">()</span> &#123;</span><br><span class="line">        business.<span class="keyword">do</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Business</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Project project;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">do</span><span class="params">()</span> &#123;</span><br><span class="line">        project.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Project</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">make</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、迪米特法则定义&quot;&gt;&lt;a href=&quot;#一、迪米特法则定义&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="设计模式" scheme="https://qtspace.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="迪米特法则" scheme="https://qtspace.cn/tags/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JVM-内存模型</title>
    <link href="https://qtspace.cn/2022/03/16/jvm-memory-model/"/>
    <id>https://qtspace.cn/2022/03/16/jvm-memory-model/</id>
    <published>2022-03-15T16:00:00.000Z</published>
    <updated>2022-04-08T11:41:22.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、JDK1-6、JDK1-7、JDK1-8内存模型演变"><a href="#一、JDK1-6、JDK1-7、JDK1-8内存模型演变" class="headerlink" title="一、JDK1.6、JDK1.7、JDK1.8内存模型演变"></a>一、JDK1.6、JDK1.7、JDK1.8内存模型演变</h3><p>JDK1.6、JDK1.7、JDK1.8内存模型演变规程如下图：</p><p><img src="https://qtspace.cn/contentimg/7.jpg"></p><p>从上图我们可以看出这些版本的JVM内存模型主要有以下差异：</p><ul><li>JDK1.6：有永久代，静态变量存放在永久代（方法区）。</li><li>JDK1.7：有永久代，但是已经把字符串常量池、静态变量存放到堆中，逐渐减少永久代的使用。</li><li>JDK1.8：无永久代，运行时常量池、类常量池都保存到元数据区，也就是常说的元空间。但字符串常量池仍存在堆中。</li></ul><h3 id="二、JVM运行时内存区域概述"><a href="#二、JVM运行时内存区域概述" class="headerlink" title="二、JVM运行时内存区域概述"></a>二、JVM运行时内存区域概述</h3><p><code>JVM</code>在运行时<code>Java程序</code>时，会把管理的内存划分为若干个区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有区域和线程共享区域。线程私有区域包括：虚拟机栈、本地方法栈、程序计数器，线程共享区域包括：Java堆、方法区。</p><p><img src="https://qtspace.cn/contentimg/6.jpg"></p><h4 id="线程私有区域"><a href="#线程私有区域" class="headerlink" title="线程私有区域"></a>线程私有区域</h4><h5 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h5><p>线程私有的，与线程同一时间创建，管理Java方法执行时的内存模式。每个方法执行的时候都会创建一个帧栈来储存方法的局部变量表、操作数帧、动态链接方法、返回值、返回地址等信息。栈的大小决定了方法可调用的深度（递归多少层次，或嵌套调用多少层其他方法，<code>-Xss</code>参数可以设置虚拟机栈大小）。栈的大小可以是固定的，或者是动态扩展的。如果请求的深度超过最大可用深度，则会抛出<code>stackOverflowError</code>错误；如果栈是可动态扩展的，但没有内存空间支持扩展，则抛出<code>OutofMemeryError</code>错误。</p><ul><li>局部变量表：是一组<strong>变量值存储空间</strong>，存放方法的参数以及局部变量，以及编译期间可知的八大基本数据类型，对象引用和 returnAddress类型（指向了一条字节码指令的地址）。</li><li>操作数帧：保存计算过程中的中间结果，同时作为计算过程中变量的临时储存空间。</li></ul><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈结构作用相似。不同的是虚拟机栈为Java方法服务，本地方法栈为本地方法服务（native方法）。</p><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>较小的内存空间，记录这当前线程所执行的字节码的行号，字节码解析的时候通过改变程序计数器的值来获取下一条需要执行的指定。在多线程程序中，每个线程都有独立的程序计数器，所以程序计数器是私有的。如果程序执行的是Java方法，那么这个程序计数器记录着当前执行的字节码指令地址，如果执行的是一个<code>navtive</code>方法，则计数器为空。程序计数器区域没有任何<code>OutOfMemoryError</code>定义。</p><h4 id="线程共享区域"><a href="#线程共享区域" class="headerlink" title="线程共享区域"></a>线程共享区域</h4><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>Java堆是被所有线程共享的一块内存区域，存放对象实例和数组，是垃圾回收的主要区域，分为新生代和老生代。刚创建的对象在新生代<code>Eden区</code>中，经过GC后进入新生代的<code>S0区</code>，再经过GC进入新生代的<code>S1区</code>，<code>15</code>次GC后扔存在则进入<code>老生代</code>。若堆的空间不够实例的分配，则会抛出<code>OutofMemeryError</code>错误。</p><h5 id="JDK8元空间"><a href="#JDK8元空间" class="headerlink" title="JDK8元空间"></a>JDK8元空间</h5><p>元空间是从虚拟机Java堆中转移到本地内存，默认情况下，元空间的大小受本地内存的限制，说白了也就是以后不会因为永久代空间不够而抛出 OOM 异常出现了。 jdk1.8 以前版本的 class 和 JAR 包数据存储在 PermGen 下面 PermGen 大小是固定的，而且项目之间无法共用，公有的 class ，所以比较容易出现 OOM 异常。</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区是线程共享的，用于存放虚拟机加载的类信息、常量、静态变量以及即时编译期编译后的代码。</p><h3 id="三、堆和栈的区别"><a href="#三、堆和栈的区别" class="headerlink" title="三、堆和栈的区别"></a>三、堆和栈的区别</h3><p>栈是运行时单位，代表这逻辑，储存基本类型和堆中对象引用，所在区连续，没有碎片，是线程私有的。</p><p>堆是储存单位，代表这数据，可被多个栈共享，所在区域连续，会有碎片，是线程共享的。</p><ul><li>功能不同：栈内存是存储局部变量和方法调用、堆中对象引用，而堆是用来储存对象的，无论是成员变量、局部变量还是类变量，它们指向的对象都储存在堆内存中。</li><li>共享性不同：栈是线程私有的，堆是线程共享的。</li><li>异常错误不同：如果栈内存或者堆内存不足都会抛出异常，栈抛出的错是<code>java.lang.StackOverFlowError</code>，堆内存抛出的错是<code>java.lang.OutOfMemoryError</code>。</li><li>空间大小：栈的空间远远小于堆的。</li></ul><h3 id="四、OOM常见的原因"><a href="#四、OOM常见的原因" class="headerlink" title="四、OOM常见的原因"></a>四、OOM常见的原因</h3><ul><li>内存加载的数据量太大：一次性从数据库读取多数据。</li><li>集合类中有对对象的引用，使用后未清空，GC不能进行回收。</li><li>代码中存在循环产生过多的对象。</li><li>启动参数堆内存值小。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、JDK1-6、JDK1-7、JDK1-8内存模型演变&quot;&gt;&lt;a href=&quot;#一、JDK1-6、JDK1</summary>
      
    
    
    
    <category term="Java" scheme="https://qtspace.cn/categories/Java/"/>
    
    <category term="JVM" scheme="https://qtspace.cn/categories/Java/JVM/"/>
    
    
    <category term="内存模型" scheme="https://qtspace.cn/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>六大设计模式原则-里氏替换原则</title>
    <link href="https://qtspace.cn/2022/03/15/design-mode-lsp/"/>
    <id>https://qtspace.cn/2022/03/15/design-mode-lsp/</id>
    <published>2022-03-14T16:00:00.000Z</published>
    <updated>2022-04-08T11:40:37.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>热衷学习，热衷生活！😄</p><p>沉淀、分享、成长，让自己和他人都能有所收获！😄</p></blockquote><h3 id="一、里氏替换原则定义"><a href="#一、里氏替换原则定义" class="headerlink" title="一、里氏替换原则定义"></a>一、里氏替换原则定义</h3><p>里氏替换原则是实现开闭原则的重要方式之一，定义如下：<br>里氏替换原则（Liskov Substitution Principle，LSP）：<strong>继承必须确保超类所拥有的性质在子类中必须仍然成立</strong>。</p><p>里氏替换原则讲述了有关继承的一些原则，定义了什么时候该用继承，什么时候不该用继承。里氏替换原则是继承复用的基础，反应了父类和子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><h3 id="二、里氏替换原则的作用"><a href="#二、里氏替换原则的作用" class="headerlink" title="二、里氏替换原则的作用"></a>二、里氏替换原则的作用</h3><p>里氏替换原则的作用主要如下：</p><ul><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>克服了继承中重写父类造成的可复用性变差的缺点。</li><li>是动作正确性的确保，即类的扩展不会给已有的系统造成错误，降低代码代码出错的可能性。</li><li>加强程序的健壮性，同时做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更带来的风险。</li></ul><h3 id="三、里氏替换原则的实现方法"><a href="#三、里氏替换原则的实现方法" class="headerlink" title="三、里氏替换原则的实现方法"></a>三、里氏替换原则的实现方法</h3><p>里氏替换原则通俗的讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。也就是说，子类继承父类的时候，除了添加新的方法扩展功能之外，尽量不要重写父类的方法。</p><p>根据上述理解，对里氏替换原则的实现可以总结如下：</p><ul><li>子类可以实现父类的抽象方法，但是不能覆盖父类非抽象的方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类重写父类的方法时，方法的入参应该比父类的方法更加宽松。</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载&#x2F;或实现抽象方法），方法的返回值应该比父类更加严格或者相等。</li></ul><p>通过重写父类的方法来完成新的功能写起来简单，但是整个继承体系中复用性很比较差，特别是运用多态比较频繁时，程序出错的概率会非常大。如果违背了里氏替换原则，则继承类的对象再父类出现的地方就会出现运行错误，修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h3 id="四、里氏替换原则栗子"><a href="#四、里氏替换原则栗子" class="headerlink" title="四、里氏替换原则栗子"></a>四、里氏替换原则栗子</h3><p>关于里氏替换原则最有名的栗子就是“正方形不是长方形”。当然，生活中还很多类似的栗子，比如：企鹅、鸵鸟和几维鸟从生物学的角度来划分是属于鸟类，但是从类的继承关系来说，由于它们不能继承”鸟”会飞的功能，所以不能把它们定义为”鸟”的子类。</p><h4 id="不满足里氏替换原则"><a href="#不满足里氏替换原则" class="headerlink" title="不满足里氏替换原则"></a>不满足里氏替换原则</h4><p>几维鸟不是鸟不满足里氏替换原则栗子。</p><p>分析：鸟一般都会飞行，如燕子的飞行速度大概是每小时120千米。但是新西兰的几维鸟由于翅膀退化基本不会飞行，假如要设计一个实例，计算这两种鸟飞行300千米要花费的时间，显然拿燕子来测试这段代码没问题，但是拿几维鸟来这测试，结果会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrownKiwi</span>();</span><br><span class="line">        bird1.setFlySpeed(<span class="number">120</span>);</span><br><span class="line">        bird2.setFlySpeed(<span class="number">120</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;燕子将飞行&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;几维鸟将飞行&quot;</span> + bird2.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="type">double</span> flySpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flySpeed = flySpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (distance/ flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swallow</span>  <span class="keyword">extends</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrownKiwi</span> <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> speed)</span> &#123;</span><br><span class="line">        flySpeed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果飞行300公里：</span><br><span class="line">燕子将飞行2.5小时.</span><br><span class="line">几维鸟将飞行Infinity小时。</span><br></pre></td></tr></table></figure><p>程序出错的原因是因为几维鸟不会飞行，所以没有飞行速度，所以重写了<code>setSpeed()</code>方法，导致<code>getFlyTime()</code>方法报错，违背了里氏替换原则。</p><h4 id="重构满足里氏替换原则"><a href="#重构满足里氏替换原则" class="headerlink" title="重构满足里氏替换原则"></a>重构满足里氏替换原则</h4><p>取消几维鸟和鸟的继承关系，定义鸟和几维鸟更一般的父类，如动物类，他们都具备奔跑的能力，几维鸟的飞行速度虽然为0，但是奔跑速度不为0，所以我们新增一个父类<code>Animal</code>类，<code>BrownKiwi</code>类继承<code>Animal</code>类，拥有奔跑速度，通过奔跑速度计算时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LSPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swallow</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">bird2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrownKiwi</span>();</span><br><span class="line">        bird1.setSpeed(<span class="number">120</span>);</span><br><span class="line">        bird2.setRunSpeed(<span class="number">120</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;如果飞行300公里：&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;燕子将飞行&quot;</span> + bird1.getFlyTime(<span class="number">300</span>) + <span class="string">&quot;小时.&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;几维鸟将飞行&quot;</span> + bird2.getRunTime(<span class="number">300</span>) + <span class="string">&quot;小时。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发生错误了!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> runSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRunSpeed</span><span class="params">(<span class="type">double</span> runSpeed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.runSpeed = runSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRunTime</span> <span class="params">(<span class="type">double</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (distance/ runSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> flySpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlySpeed</span><span class="params">(<span class="type">double</span> flySpeed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flySpeed = flySpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getFlyTime</span><span class="params">(<span class="type">double</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (distance/ flySpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Swallow</span>  <span class="keyword">extends</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BrownKiwi</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出结果为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果飞行300公里：</span><br><span class="line">燕子将飞行2.5小时.</span><br><span class="line">几维鸟将飞行2.5小时。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;热衷学习，热衷生活！😄&lt;/p&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、里氏替换原则定义&quot;&gt;&lt;a href=&quot;#一、里氏替换原则定义&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="设计模式" scheme="https://qtspace.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="里氏替换原则" scheme="https://qtspace.cn/tags/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
</feed>
